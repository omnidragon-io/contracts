{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary ExecutorOptions {\n    using CalldataBytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 1;\n\n    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;\n    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;\n    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;\n    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;\n    uint8 internal constant OPTION_TYPE_LZREAD = 5;\n\n    error Executor_InvalidLzReceiveOption();\n    error Executor_InvalidNativeDropOption();\n    error Executor_InvalidLzComposeOption();\n    error Executor_InvalidLzReadOption();\n\n    /// @dev decode the next executor option from the options starting from the specified cursor\n    /// @param _options [executor_id][executor_option][executor_id][executor_option]...\n    ///        executor_option = [option_size][option_type][option]\n    ///        option_size = len(option_type) + len(option)\n    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @param _cursor the cursor to start decoding from\n    /// @return optionType the type of the option\n    /// @return option the option of the executor\n    /// @return cursor the cursor to start decoding the next executor option\n    function nextExecutorOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor);\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 1; // skip option type\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n\n    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {\n        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();\n        gas = _option.toU128(0);\n        value = _option.length == 32 ? _option.toU128(16) : 0;\n    }\n\n    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {\n        if (_option.length != 48) revert Executor_InvalidNativeDropOption();\n        amount = _option.toU128(0);\n        receiver = _option.toB32(16);\n    }\n\n    function decodeLzComposeOption(\n        bytes calldata _option\n    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {\n        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();\n        index = _option.toU16(0);\n        gas = _option.toU128(2);\n        value = _option.length == 34 ? _option.toU128(18) : 0;\n    }\n\n    function decodeLzReadOption(\n        bytes calldata _option\n    ) internal pure returns (uint128 gas, uint32 calldataSize, uint128 value) {\n        if (_option.length != 20 && _option.length != 36) revert Executor_InvalidLzReadOption();\n        gas = _option.toU128(0);\n        calldataSize = _option.toU32(16);\n        value = _option.length == 36 ? _option.toU128(20) : 0;\n    }\n\n    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);\n    }\n\n    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {\n        return abi.encodePacked(_amount, _receiver);\n    }\n\n    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);\n    }\n\n    function encodeLzReadOption(\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure returns (bytes memory) {\n        return _value == 0 ? abi.encodePacked(_gas, _calldataSize) : abi.encodePacked(_gas, _calldataSize, _value);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport { BitMap256 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol\";\nimport { CalldataBytesLib } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol\";\n\nlibrary DVNOptions {\n    using CalldataBytesLib for bytes;\n    using BytesLib for bytes;\n\n    uint8 internal constant WORKER_ID = 2;\n    uint8 internal constant OPTION_TYPE_PRECRIME = 1;\n\n    error DVN_InvalidDVNIdx();\n    error DVN_InvalidDVNOptions(uint256 cursor);\n\n    /// @dev group dvn options by its idx\n    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...\n    ///        dvn_option = [option_size][dvn_idx][option_type][option]\n    ///        option_size = len(dvn_idx) + len(option_type) + len(option)\n    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes\n    /// @return dvnOptions the grouped options, still share the same format of _options\n    /// @return dvnIndices the dvn indices\n    function groupDVNOptionsByIdx(\n        bytes memory _options\n    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {\n        if (_options.length == 0) return (dvnOptions, dvnIndices);\n\n        uint8 numDVNs = getNumDVNs(_options);\n\n        // if there is only 1 dvn, we can just return the whole options\n        if (numDVNs == 1) {\n            dvnOptions = new bytes[](1);\n            dvnOptions[0] = _options;\n\n            dvnIndices = new uint8[](1);\n            dvnIndices[0] = _options.toUint8(3); // dvn idx\n            return (dvnOptions, dvnIndices);\n        }\n\n        // otherwise, we need to group the options by dvn_idx\n        dvnIndices = new uint8[](numDVNs);\n        dvnOptions = new bytes[](numDVNs);\n        unchecked {\n            uint256 cursor = 0;\n            uint256 start = 0;\n            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx\n\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                // optionLength asserted in getNumDVNs (skip check)\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n\n                // dvnIdx asserted in getNumDVNs (skip check)\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // dvnIdx must equal to the lastDVNIdx for the first option\n                // so it is always skipped in the first option\n                // this operation slices out options whenever the scan finds a different lastDVNIdx\n                if (lastDVNIdx == 255) {\n                    lastDVNIdx = dvnIdx;\n                } else if (dvnIdx != lastDVNIdx) {\n                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length\n                    bytes memory opt = _options.slice(start, len);\n                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);\n\n                    // reset the start and lastDVNIdx\n                    start += len;\n                    lastDVNIdx = dvnIdx;\n                }\n\n                cursor += optionLength;\n            }\n\n            // skip check the cursor here because the cursor is asserted in getNumDVNs\n            // if we have reached the end of the options, we need to process the last dvn\n            uint256 size = cursor - start;\n            bytes memory op = _options.slice(start, size);\n            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);\n\n            // revert dvnIndices to start from 0\n            for (uint8 i = 0; i < numDVNs; ++i) {\n                --dvnIndices[i];\n            }\n        }\n    }\n\n    function _insertDVNOptions(\n        bytes[] memory _dvnOptions,\n        uint8[] memory _dvnIndices,\n        uint8 _dvnIdx,\n        bytes memory _newOptions\n    ) internal pure {\n        // dvnIdx starts from 0 but default value of dvnIndices is 0,\n        // so we tell if the slot is empty by adding 1 to dvnIdx\n        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();\n        uint8 dvnIdxAdj = _dvnIdx + 1;\n\n        for (uint256 j = 0; j < _dvnIndices.length; ++j) {\n            uint8 index = _dvnIndices[j];\n            if (dvnIdxAdj == index) {\n                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);\n                break;\n            } else if (index == 0) {\n                // empty slot, that means it is the first time we see this dvn\n                _dvnIndices[j] = dvnIdxAdj;\n                _dvnOptions[j] = _newOptions;\n                break;\n            }\n        }\n    }\n\n    /// @dev get the number of unique dvns\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {\n        uint256 cursor = 0;\n        BitMap256 bitmap;\n\n        // find number of unique dvn_idx\n        unchecked {\n            while (cursor < _options.length) {\n                ++cursor; // skip worker_id\n\n                uint16 optionLength = _options.toUint16(cursor);\n                cursor += 2;\n                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type\n\n                uint8 dvnIdx = _options.toUint8(cursor);\n\n                // if dvnIdx is not set, increment numDVNs\n                // max num of dvns is 255, 255 is an invalid dvn_idx\n                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken\n                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has\n                // already enforced certain options can append additional options to the end of the enforced\n                // ones without restrictions.\n                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();\n                if (!bitmap.get(dvnIdx)) {\n                    ++numDVNs;\n                    bitmap = bitmap.set(dvnIdx);\n                }\n\n                cursor += optionLength;\n            }\n        }\n        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);\n    }\n\n    /// @dev decode the next dvn option from _options starting from the specified cursor\n    /// @param _options the format is the same as groupDVNOptionsByIdx\n    /// @param _cursor the cursor to start decoding\n    /// @return optionType the type of the option\n    /// @return option the option\n    /// @return cursor the cursor to start decoding the next option\n    function nextDVNOption(\n        bytes calldata _options,\n        uint256 _cursor\n    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {\n        unchecked {\n            // skip worker id\n            cursor = _cursor + 1;\n\n            // read option size\n            uint16 size = _options.toU16(cursor);\n            cursor += 2;\n\n            // read option type\n            optionType = _options.toU8(cursor + 1); // skip dvn_idx\n\n            // startCursor and endCursor are used to slice the option from _options\n            uint256 startCursor = cursor + 2; // skip option type and dvn_idx\n            uint256 endCursor = cursor + size;\n            option = _options[startCursor:endCursor];\n            cursor += size;\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppMsgInspector\n * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.\n */\ninterface IOAppMsgInspector {\n    // Custom error message for inspection failure\n    error InspectionFailed(bytes message, bytes options);\n\n    /**\n     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.\n     * @param _message The message payload to be inspected.\n     * @param _options Additional options or parameters for inspection.\n     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).\n     *\n     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.\n     */\n    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { ExecutorOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/libs/ExecutorOptions.sol\";\nimport { DVNOptions } from \"@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol\";\n\n/**\n * @title OptionsBuilder\n * @dev Library for building and encoding various message options.\n */\nlibrary OptionsBuilder {\n    using SafeCast for uint256;\n    using BytesLib for bytes;\n\n    // Constants for options types\n    uint16 internal constant TYPE_1 = 1; // legacy options type 1\n    uint16 internal constant TYPE_2 = 2; // legacy options type 2\n    uint16 internal constant TYPE_3 = 3;\n\n    // Custom error message\n    error InvalidSize(uint256 max, uint256 actual);\n    error InvalidOptionType(uint16 optionType);\n\n    // Modifier to ensure only options of type 3 are used\n    modifier onlyType3(bytes memory _options) {\n        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));\n        _;\n    }\n\n    /**\n     * @dev Creates a new options container with type 3.\n     * @return options The newly created options container.\n     */\n    function newOptions() internal pure returns (bytes memory) {\n        return abi.encodePacked(TYPE_3);\n    }\n\n    /**\n     * @dev Adds an executor LZ receive option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gasLimit used on the lzReceive() function in the OApp.\n     * @param _value The msg.value passed to the lzReceive() function in the OApp.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor\n     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,\n     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.\n     */\n    function addExecutorLzReceiveOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ read option to the existing options.\n     * @param _options The existing options container.\n     * @param _gas The gas limit used for the lzReceive() function in the ReadOApp.\n     * @param _calldataSize The size of the payload for lzReceive() function in the ReadOApp.\n     * @param _value The msg.value passed to the lzReceive() function in the ReadOApp.\n     * @return options The updated options container.\n     */\n    function addExecutorLzReadOption(\n        bytes memory _options,\n        uint128 _gas,\n        uint32 _calldataSize,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzReadOption(_gas, _calldataSize, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZREAD, option);\n    }\n\n    /**\n     * @dev Adds an executor native drop option to the existing options.\n     * @param _options The existing options container.\n     * @param _amount The amount for the native value that is airdropped to the 'receiver'.\n     * @param _receiver The receiver address for the native drop option.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.\n     */\n    function addExecutorNativeDropOption(\n        bytes memory _options,\n        uint128 _amount,\n        bytes32 _receiver\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);\n    }\n\n    /**\n     * @dev Adds an executor LZ compose option to the existing options.\n     * @param _options The existing options container.\n     * @param _index The index for the lzCompose() function call.\n     * @param _gas The gasLimit for the lzCompose() function call.\n     * @param _value The msg.value for the lzCompose() function call.\n     * @return options The updated options container.\n     *\n     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.\n     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.\n     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2\n     */\n    function addExecutorLzComposeOption(\n        bytes memory _options,\n        uint16 _index,\n        uint128 _gas,\n        uint128 _value\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);\n    }\n\n    /**\n     * @dev Adds an executor ordered execution option to the existing options.\n     * @param _options The existing options container.\n     * @return options The updated options container.\n     */\n    function addExecutorOrderedExecutionOption(\n        bytes memory _options\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds a DVN pre-crime option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the pre-crime option.\n     * @return options The updated options container.\n     */\n    function addDVNPreCrimeOption(\n        bytes memory _options,\n        uint8 _dvnIdx\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(\"\"));\n    }\n\n    /**\n     * @dev Adds an executor option to the existing options.\n     * @param _options The existing options container.\n     * @param _optionType The type of the executor option.\n     * @param _option The encoded data for the executor option.\n     * @return options The updated options container.\n     */\n    function addExecutorOption(\n        bytes memory _options,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                ExecutorOptions.WORKER_ID,\n                _option.length.toUint16() + 1, // +1 for optionType\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Adds a DVN option to the existing options.\n     * @param _options The existing options container.\n     * @param _dvnIdx The DVN index for the DVN option.\n     * @param _optionType The type of the DVN option.\n     * @param _option The encoded data for the DVN option.\n     * @return options The updated options container.\n     */\n    function addDVNOption(\n        bytes memory _options,\n        uint8 _dvnIdx,\n        uint8 _optionType,\n        bytes memory _option\n    ) internal pure onlyType3(_options) returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _options,\n                DVNOptions.WORKER_ID,\n                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx\n                _dvnIdx,\n                _optionType,\n                _option\n            );\n    }\n\n    /**\n     * @dev Encodes legacy options of type 1.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @return legacyOptions The encoded legacy options.\n     */\n    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        return abi.encodePacked(TYPE_1, _executionGas);\n    }\n\n    /**\n     * @dev Encodes legacy options of type 2.\n     * @param _executionGas The gasLimit value passed to lzReceive().\n     * @param _nativeForDst The amount of native air dropped to the receiver.\n     * @param _receiver The _nativeForDst receiver address.\n     * @return legacyOptions The encoded legacy options of type 2.\n     */\n    function encodeLegacyOptionsType2(\n        uint256 _executionGas,\n        uint256 _nativeForDst,\n        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.\n    ) internal pure returns (bytes memory) {\n        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);\n        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);\n        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);\n        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppRead.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { AddressCast } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\";\n\nimport { OApp } from \"./OApp.sol\";\n\nabstract contract OAppRead is OApp {\n\n    constructor(address _endpoint, address _delegate) OApp(_endpoint, _delegate) {}\n\n    // -------------------------------\n    // Only Owner\n    function setReadChannel(uint32 _channelId, bool _active) public virtual onlyOwner {\n        _setPeer(_channelId, _active ? AddressCast.toBytes32(address(this)) : bytes32(0));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { MessagingReceipt, MessagingFee } from \"../../oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT limit information.\n * @dev These amounts can change dynamically and are up the the specific oft implementation.\n */\nstruct OFTLimit {\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @dev Struct representing OFT fee details.\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n */\nstruct OFTFeeDetail {\n    int256 feeAmountLD; // Amount of the fee in local decimals.\n    string description; // Description of the fee.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    // Custom error messages\n    error InvalidLocalDecimals();\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\n\n    // Events\n    event OFTSent(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n    event OFTReceived(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce from the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID from the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTMsgCodec {\n    // Offset constants for encoding and decoding OFT messages\n    uint8 private constant SEND_TO_OFFSET = 32;\n    uint8 private constant SEND_AMOUNT_SD_OFFSET = 40;\n\n    /**\n     * @dev Encodes an OFT LayerZero message.\n     * @param _sendTo The recipient address.\n     * @param _amountShared The amount in shared decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded message.\n     * @return hasCompose A boolean indicating whether the message has a composed payload.\n     */\n    function encode(\n        bytes32 _sendTo,\n        uint64 _amountShared,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory _msg, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        // @dev Remote chains will want to know the composed function caller ie. msg.sender on the src.\n        _msg = hasCompose\n            ? abi.encodePacked(_sendTo, _amountShared, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _amountShared);\n    }\n\n    /**\n     * @dev Checks if the OFT message is composed.\n     * @param _msg The OFT message.\n     * @return A boolean indicating whether the message is composed.\n     */\n    function isComposed(bytes calldata _msg) internal pure returns (bool) {\n        return _msg.length > SEND_AMOUNT_SD_OFFSET;\n    }\n\n    /**\n     * @dev Retrieves the recipient address from the OFT message.\n     * @param _msg The OFT message.\n     * @return The recipient address.\n     */\n    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[:SEND_TO_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the amount in shared decimals from the OFT message.\n     * @param _msg The OFT message.\n     * @return The amount in shared decimals.\n     */\n    function amountSD(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[SEND_TO_OFFSET:SEND_AMOUNT_SD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composed message from the OFT message.\n     * @param _msg The OFT message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[SEND_AMOUNT_SD_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IOFT, OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title OFT Contract\n * @dev OFT is an ERC-20 token that extends the functionality of the OFTCore contract.\n */\nabstract contract OFT is OFTCore, ERC20 {\n    /**\n     * @dev Constructor for the OFT contract.\n     * @param _name The name of the OFT.\n     * @param _symbol The symbol of the OFT.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ERC20(_name, _symbol) OFTCore(decimals(), _lzEndpoint, _delegate) {}\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the OFT token.\n     *\n     * @dev In the case of OFT, address(this) and erc20 are the same contract.\n     */\n    function token() public view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev In the case of OFT where the contract IS the token, approval is NOT required.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Burns tokens from the sender's specified balance.\n     * @param _from The address to debit the tokens from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n\n        // @dev In NON-default OFT, amountSentLD could be 100, with a 10% fee, the amountReceivedLD amount is 90,\n        // therefore amountSentLD CAN differ from amountReceivedLD.\n\n        // @dev Default OFT burns on src.\n        _burn(_from, amountSentLD);\n    }\n\n    /**\n     * @dev Credits tokens to the specified address.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @dev _srcEid The source chain ID.\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /*_srcEid*/\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        if (_to == address(0x0)) _to = address(0xdead); // _mint(...) does not support address(0x0)\n        // @dev Default OFT mints on dst.\n        _mint(_to, _amountLD);\n        // @dev In the case of NON-default OFT, the _amountLD MIGHT not be == amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { OApp, Origin } from \"../oapp/OApp.sol\";\nimport { OAppOptionsType3 } from \"../oapp/libs/OAppOptionsType3.sol\";\nimport { IOAppMsgInspector } from \"../oapp/interfaces/IOAppMsgInspector.sol\";\n\nimport { OAppPreCrimeSimulator } from \"../precrime/OAppPreCrimeSimulator.sol\";\n\nimport { IOFT, SendParam, OFTLimit, OFTReceipt, OFTFeeDetail, MessagingReceipt, MessagingFee } from \"./interfaces/IOFT.sol\";\nimport { OFTMsgCodec } from \"./libs/OFTMsgCodec.sol\";\nimport { OFTComposeMsgCodec } from \"./libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title OFTCore\n * @dev Abstract contract for the OftChain (OFT) token.\n */\nabstract contract OFTCore is IOFT, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    // @notice Provides a conversion rate when swapping between denominations of SD and LD\n    //      - shareDecimals == SD == shared Decimals\n    //      - localDecimals == LD == local decimals\n    // @dev Considers that tokens have different decimal amounts on various chains.\n    // @dev eg.\n    //  For a token\n    //      - locally with 4 decimals --> 1.2345 => uint(12345)\n    //      - remotely with 2 decimals --> 1.23 => uint(123)\n    //      - The conversion rate would be 10 ** (4 - 2) = 100\n    //  @dev If you want to send 1.2345 -> (uint 12345), you CANNOT represent that value on the remote,\n    //  you can only display 1.23 -> uint(123).\n    //  @dev To preserve the dust that would otherwise be lost on that conversion,\n    //  we need to unify a denomination that can be represented on ALL chains inside of the OFT mesh\n    uint256 public immutable decimalConversionRate;\n\n    // @notice Msg types that are used to identify the various OFT operations.\n    // @dev This can be extended in child contracts for non-default oft operations\n    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.\n    uint16 public constant SEND = 1;\n    uint16 public constant SEND_AND_CALL = 2;\n\n    // Address of an optional contract to inspect both 'message' and 'options'\n    address public msgInspector;\n    event MsgInspectorSet(address inspector);\n\n    /**\n     * @dev Constructor.\n     * @param _localDecimals The decimals of the token on the local chain (this chain).\n     * @param _endpoint The address of the LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(uint8 _localDecimals, address _endpoint, address _delegate) OApp(_endpoint, _delegate) {\n        if (_localDecimals < sharedDecimals()) revert InvalidLocalDecimals();\n        decimalConversionRate = 10 ** (_localDecimals - sharedDecimals());\n    }\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {\n        return (type(IOFT).interfaceId, 1);\n    }\n\n    /**\n     * @dev Retrieves the shared decimals of the OFT.\n     * @return The shared decimals of the OFT.\n     *\n     * @dev Sets an implicit cap on the amount of tokens, over uint64.max() will need some sort of outbound cap / totalSupply cap\n     * Lowest common decimal denominator between chains.\n     * Defaults to 6 decimal places to provide up to 18,446,744,073,709.551615 units (max uint64).\n     * For tokens exceeding this totalSupply(), they will need to override the sharedDecimals function with something smaller.\n     * ie. 4 sharedDecimals would be 1,844,674,407,370,955.1615\n     */\n    function sharedDecimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev Sets the message inspector address for the OFT.\n     * @param _msgInspector The address of the message inspector.\n     *\n     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.\n     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.\n     */\n    function setMsgInspector(address _msgInspector) public virtual onlyOwner {\n        msgInspector = _msgInspector;\n        emit MsgInspectorSet(_msgInspector);\n    }\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return oftLimit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return oftReceipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        virtual\n        returns (OFTLimit memory oftLimit, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory oftReceipt)\n    {\n        uint256 minAmountLD = 0; // Unused in the default implementation.\n        uint256 maxAmountLD = type(uint64).max; // Unused in the default implementation.\n        oftLimit = OFTLimit(minAmountLD, maxAmountLD);\n\n        // Unused in the default implementation; reserved for future complex fee details.\n        oftFeeDetails = new OFTFeeDetail[](0);\n\n        // @dev This is the same as the send() operation, but without the actual send.\n        // - amountSentLD is the amount in local decimals that would be sent from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        // @dev The amountSentLD MIGHT not equal the amount the user actually receives. HOWEVER, the default does.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debitView(\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return msgFee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        // @dev mock the amount to receive, this is the same operation used in the send().\n        // The quote is as similar as possible to the actual send() operation.\n        (, uint256 amountReceivedLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Calculates the LayerZero fee for the send() operation.\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    /**\n     * @dev Executes the send operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The calculated fee for the send() operation.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds.\n     * @return msgReceipt The receipt for the send operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountSentLD is the amount in local decimals that was ACTUALLY sent/debited from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be received/credited to the recipient on the remote OFT instance.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debit(\n            msg.sender,\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n\n        emit OFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to build the message and options.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _amountLD The amount in local decimals.\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function _buildMsgAndOptions(\n        SendParam calldata _sendParam,\n        uint256 _amountLD\n    ) internal view virtual returns (bytes memory message, bytes memory options) {\n        bool hasCompose;\n        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.\n        (message, hasCompose) = OFTMsgCodec.encode(\n            _sendParam.to,\n            _toSD(_amountLD),\n            // @dev Must be include a non empty bytes if you want to compose, EVEN if you dont need it on the remote.\n            // EVEN if you dont require an arbitrary payload to be sent... eg. '0x01'\n            _sendParam.composeMsg\n        );\n        // @dev Change the msg type depending if its composed or not.\n        uint16 msgType = hasCompose ? SEND_AND_CALL : SEND;\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n        options = combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        if (msgInspector != address(0)) IOAppMsgInspector(msgInspector).inspect(message, options);\n    }\n\n    /**\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address /*_executor*/, // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesnt know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Credit the amountLD to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, _toLD(_message.amountSD()), _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Proprietary composeMsg format for the OFT.\n            bytes memory composeMsg = OFTComposeMsgCodec.encode(\n                _origin.nonce,\n                _origin.srcEid,\n                amountReceivedLD,\n                _message.composeMsg()\n            );\n\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(toAddress, _guid, 0 /* the index of the composed message*/, composeMsg);\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual override {\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Check if the peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint ID to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     *\n     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {\n        return peers[_eid] == _peer;\n    }\n\n    /**\n     * @dev Internal function to remove dust from the given local decimal amount.\n     * @param _amountLD The amount in local decimals.\n     * @return amountLD The amount after removing dust.\n     *\n     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.\n     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).\n     */\n    function _removeDust(uint256 _amountLD) internal view virtual returns (uint256 amountLD) {\n        return (_amountLD / decimalConversionRate) * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from shared decimals into local decimals.\n     * @param _amountSD The amount in shared decimals.\n     * @return amountLD The amount in local decimals.\n     */\n    function _toLD(uint64 _amountSD) internal view virtual returns (uint256 amountLD) {\n        return _amountSD * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from local decimals into shared decimals.\n     * @param _amountLD The amount in local decimals.\n     * @return amountSD The amount in shared decimals.\n     */\n    function _toSD(uint256 _amountLD) internal view virtual returns (uint64 amountSD) {\n        return uint64(_amountLD / decimalConversionRate);\n    }\n\n    /**\n     * @dev Internal function to mock the amount mutation from a OFT debit() operation.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @dev _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent, in local decimals.\n     * @return amountReceivedLD The amount to be received on the remote chain, in local decimals.\n     *\n     * @dev This is where things like fees would be calculated and deducted from the amount to be received on the remote.\n     */\n    function _debitView(\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 /*_dstEid*/\n    ) internal view virtual returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        // @dev Remove the dust so nothing is lost on the conversion between chains with different decimals for the token.\n        amountSentLD = _removeDust(_amountLD);\n        // @dev The amount to send is the same as amount received in the default implementation.\n        amountReceivedLD = amountSentLD;\n\n        // @dev Check for slippage.\n        if (amountReceivedLD < _minAmountLD) {\n            revert SlippageExceeded(amountReceivedLD, _minAmountLD);\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a debit operation.\n     * @param _from The address to debit.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual returns (uint256 amountSentLD, uint256 amountReceivedLD);\n\n    /**\n     * @dev Internal function to perform a credit operation.\n     * @param _to The address to credit.\n     * @param _amountLD The amount to credit in local decimals.\n     * @param _srcEid The source endpoint ID.\n     * @return amountReceivedLD The amount ACTUALLY received in local decimals.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 _srcEid\n    ) internal virtual returns (uint256 amountReceivedLD);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.\n// solhint-disable-next-line no-unused-import\nimport { InboundPacket, Origin } from \"../libs/Packet.sol\";\n\n/**\n * @title IOAppPreCrimeSimulator Interface\n * @dev Interface for the preCrime simulation functionality in an OApp.\n */\ninterface IOAppPreCrimeSimulator {\n    // @dev simulation result used in PreCrime implementation\n    error SimulationResult(bytes result);\n    error OnlySelf();\n\n    /**\n     * @dev Emitted when the preCrime contract address is set.\n     * @param preCrimeAddress The address of the preCrime contract.\n     */\n    event PreCrimeSet(address preCrimeAddress);\n\n    /**\n     * @dev Retrieves the address of the preCrime contract implementation.\n     * @return The address of the preCrime contract.\n     */\n    function preCrime() external view returns (address);\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     */\n    function oApp() external view returns (address);\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) external;\n\n    /**\n     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.\n     * @param _packets An array of LayerZero InboundPacket objects representing received packets.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/interfaces/IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\nstruct PreCrimePeer {\n    uint32 eid;\n    bytes32 preCrime;\n    bytes32 oApp;\n}\n\n// TODO not done yet\ninterface IPreCrime {\n    error OnlyOffChain();\n\n    // for simulate()\n    error PacketOversize(uint256 max, uint256 actual);\n    error PacketUnsorted();\n    error SimulationFailed(bytes reason);\n\n    // for preCrime()\n    error SimulationResultNotFound(uint32 eid);\n    error InvalidSimulationResult(uint32 eid, bytes reason);\n    error CrimeFound(bytes crime);\n\n    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);\n\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable returns (bytes memory);\n\n    function buildSimulationResult() external view returns (bytes memory);\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external;\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/libs/Packet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\n/**\n * @title InboundPacket\n * @dev Structure representing an inbound packet received by the contract.\n */\nstruct InboundPacket {\n    Origin origin; // Origin information of the packet.\n    uint32 dstEid; // Destination endpointId of the packet.\n    address receiver; // Receiver address for the packet.\n    bytes32 guid; // Unique identifier of the packet.\n    uint256 value; // msg.value of the packet.\n    address executor; // Executor address for the packet.\n    bytes message; // Message payload of the packet.\n    bytes extraData; // Additional arbitrary data for the packet.\n}\n\n/**\n * @title PacketDecoder\n * @dev Library for decoding LayerZero packets.\n */\nlibrary PacketDecoder {\n    using PacketV1Codec for bytes;\n\n    /**\n     * @dev Decode an inbound packet from the given packet data.\n     * @param _packet The packet data to decode.\n     * @return packet An InboundPacket struct representing the decoded packet.\n     */\n    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {\n        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());\n        packet.dstEid = _packet.dstEid();\n        packet.receiver = _packet.receiverB20();\n        packet.guid = _packet.guid();\n        packet.message = _packet.message();\n    }\n\n    /**\n     * @dev Decode multiple inbound packets from the given packet data and associated message values.\n     * @param _packets An array of packet data to decode.\n     * @param _packetMsgValues An array of associated message values for each packet.\n     * @return packets An array of InboundPacket structs representing the decoded packets.\n     */\n    function decode(\n        bytes[] calldata _packets,\n        uint256[] memory _packetMsgValues\n    ) internal pure returns (InboundPacket[] memory packets) {\n        packets = new InboundPacket[](_packets.length);\n        for (uint256 i = 0; i < _packets.length; i++) {\n            bytes calldata packet = _packets[i];\n            packets[i] = PacketDecoder.decode(packet);\n            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.\n            packets[i].value = _packetMsgValues[i];\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/precrime/OAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPreCrime } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator, InboundPacket, Origin } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\n\n/**\n * @title OAppPreCrimeSimulator\n * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.\n */\nabstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {\n    // The address of the preCrime implementation.\n    address public preCrime;\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     *\n     * @dev The simulator contract is the base contract for the OApp by default.\n     * @dev If the simulator is a separate contract, override this function.\n     */\n    function oApp() external view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) public virtual onlyOwner {\n        preCrime = _preCrime;\n        emit PreCrimeSet(_preCrime);\n    }\n\n    /**\n     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.\n     * @param _packets An array of InboundPacket objects representing received packets to be delivered.\n     *\n     * @dev WARNING: MUST revert at the end with the simulation results.\n     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,\n     * WITHOUT actually executing them.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket calldata packet = _packets[i];\n\n            // Ignore packets that are not from trusted peers.\n            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n            // @dev Because a verifier is calling this function, it doesnt have access to executor params:\n            //  - address _executor\n            //  - bytes calldata _extraData\n            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().\n            // They are instead stubbed to default values, address(0) and bytes(\"\")\n            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,\n            // which would cause the revert to be ignored.\n            this.lzReceiveSimulate{ value: packet.value }(\n                packet.origin,\n                packet.guid,\n                packet.message,\n                packet.executor,\n                packet.extraData\n            );\n        }\n\n        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().\n        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());\n    }\n\n    /**\n     * @dev Is effectively an internal function because msg.sender must be address(this).\n     * Allows resetting the call stack for 'internal' calls.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier of the packet.\n     * @param _message The message payload of the packet.\n     * @param _executor The executor address for the packet.\n     * @param _extraData Additional data for the packet.\n     */\n    function lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable virtual {\n        // @dev Ensure ONLY can be called 'internally'.\n        if (msg.sender != address(this)) revert OnlySelf();\n        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The GUID of the LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @title ILayerZeroComposer\n */\ninterface ILayerZeroComposer {\n    /**\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev To ensure non-reentrancy, implementers of this interface MUST assert msg.sender is the corresponding EndpointV2 contract (i.e., onlyEndpointV2).\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     * @param _executor The address of the executor for the composed message.\n     * @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { SetConfigParam } from \"./IMessageLibManager.sol\";\n\nenum MessageLibType {\n    Send,\n    Receive,\n    SendAndReceive\n}\n\ninterface IMessageLib is IERC165 {\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\n\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    // message libs of same major version are compatible\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\n\n    function messageLibType() external view returns (MessageLibType);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { MessagingFee } from \"./ILayerZeroEndpointV2.sol\";\nimport { IMessageLib } from \"./IMessageLib.sol\";\n\nstruct Packet {\n    uint64 nonce;\n    uint32 srcEid;\n    address sender;\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes32 guid;\n    bytes message;\n}\n\ninterface ISendLib is IMessageLib {\n    function send(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\n\n    function quote(\n        Packet calldata _packet,\n        bytes calldata _options,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory);\n\n    function setTreasury(address _treasury) external;\n\n    function withdrawFee(address _to, uint256 _amount) external;\n\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary AddressCast {\n    error AddressCast_InvalidSizeForAddress();\n    error AddressCast_InvalidAddress();\n\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\n        result = bytes32(_addressBytes);\n        unchecked {\n            uint256 offset = 32 - _addressBytes.length;\n            result = result >> (offset * 8);\n        }\n    }\n\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\n        result = bytes32(uint256(uint160(_address)));\n    }\n\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\n        result = new bytes(_size);\n        unchecked {\n            uint256 offset = 256 - _size * 8;\n            assembly {\n                mstore(add(result, 32), shl(offset, _addressBytes32))\n            }\n        }\n    }\n\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\n        result = address(uint160(uint256(_addressBytes32)));\n    }\n\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\n        result = address(bytes20(_addressBytes));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nlibrary CalldataBytesLib {\n    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {\n        return uint8(_bytes[_start]);\n    }\n\n    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {\n        unchecked {\n            uint256 end = _start + 2;\n            return uint16(bytes2(_bytes[_start:end]));\n        }\n    }\n\n    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {\n        unchecked {\n            uint256 end = _start + 4;\n            return uint32(bytes4(_bytes[_start:end]));\n        }\n    }\n\n    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {\n        unchecked {\n            uint256 end = _start + 8;\n            return uint64(bytes8(_bytes[_start:end]));\n        }\n    }\n\n    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {\n        unchecked {\n            uint256 end = _start + 16;\n            return uint128(bytes16(_bytes[_start:end]));\n        }\n    }\n\n    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {\n        unchecked {\n            uint256 end = _start + 32;\n            return uint256(bytes32(_bytes[_start:end]));\n        }\n    }\n\n    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {\n        unchecked {\n            uint256 end = _start + 20;\n            return address(bytes20(_bytes[_start:end]));\n        }\n    }\n\n    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {\n        unchecked {\n            uint256 end = _start + 32;\n            return bytes32(_bytes[_start:end]);\n        }\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol\npragma solidity ^0.8.20;\n\ntype BitMap256 is uint256;\n\nusing BitMaps for BitMap256 global;\n\nlibrary BitMaps {\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 mask = 1 << index;\n        return BitMap256.unwrap(bitmap) & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {\n        uint256 mask = 1 << index;\n        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol": {
      "content": "// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nimport { Packet } from \"../../interfaces/ISendLib.sol\";\nimport { AddressCast } from \"../../libs/AddressCast.sol\";\n\nlibrary PacketV1Codec {\n    using AddressCast for address;\n    using AddressCast for bytes32;\n\n    uint8 internal constant PACKET_VERSION = 1;\n\n    // header (version + nonce + path)\n    // version\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\n    //    nonce\n    uint256 private constant NONCE_OFFSET = 1;\n    //    path\n    uint256 private constant SRC_EID_OFFSET = 9;\n    uint256 private constant SENDER_OFFSET = 13;\n    uint256 private constant DST_EID_OFFSET = 45;\n    uint256 private constant RECEIVER_OFFSET = 49;\n    // payload (guid + message)\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\n    uint256 private constant MESSAGE_OFFSET = 113;\n\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\n        encodedPacket = abi.encodePacked(\n            PACKET_VERSION,\n            _packet.nonce,\n            _packet.srcEid,\n            _packet.sender.toBytes32(),\n            _packet.dstEid,\n            _packet.receiver,\n            _packet.guid,\n            _packet.message\n        );\n    }\n\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                PACKET_VERSION,\n                _packet.nonce,\n                _packet.srcEid,\n                _packet.sender.toBytes32(),\n                _packet.dstEid,\n                _packet.receiver\n            );\n    }\n\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\n        return abi.encodePacked(_packet.guid, _packet.message);\n    }\n\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return _packet[0:GUID_OFFSET];\n    }\n\n    function version(bytes calldata _packet) internal pure returns (uint8) {\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\n    }\n\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\n    }\n\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\n    }\n\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\n        return sender(_packet).toAddress();\n    }\n\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\n    }\n\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\n    }\n\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\n        return receiver(_packet).toAddress();\n    }\n\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\n    }\n\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[MESSAGE_OFFSET:]);\n    }\n\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\n        return bytes(_packet[GUID_OFFSET:]);\n    }\n\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\n        return keccak256(payload(_packet));\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroComposer } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol\";\n\n/**\n * @title IOAppComposer\n * @dev This interface defines the OApp Composer, allowing developers to inherit only the OApp package without the protocol.\n */\n// solhint-disable-next-line no-empty-blocks\ninterface IOAppComposer is ILayerZeroComposer {}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMsgInspector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @title IOAppMsgInspector\n * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.\n */\ninterface IOAppMsgInspector {\n    // Custom error message for inspection failure\n    error InspectionFailed(bytes message, bytes options);\n\n    /**\n     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.\n     * @param _message The message payload to be inspected.\n     * @param _options Additional options or parameters for inspection.\n     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).\n     *\n     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.\n     */\n    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Struct representing enforced option parameters.\n */\nstruct EnforcedOptionParam {\n    uint32 eid; // Endpoint ID\n    uint16 msgType; // Message Type\n    bytes options; // Additional options\n}\n\n/**\n * @title IOAppOptionsType3\n * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.\n */\ninterface IOAppOptionsType3 {\n    // Custom error message for invalid options\n    error InvalidOptions(bytes options);\n\n    // Event emitted when enforced options are set\n    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);\n\n    /**\n     * @notice Sets enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OApp message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) external view returns (bytes memory options);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppOptionsType3, EnforcedOptionParam } from \"../interfaces/IOAppOptionsType3.sol\";\n\n/**\n * @title OAppOptionsType3\n * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.\n */\nabstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {\n    uint16 internal constant OPTION_TYPE_3 = 3;\n\n    // @dev The \"msgType\" should be defined in the child contract.\n    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {\n        _setEnforcedOptions(_enforcedOptions);\n    }\n\n    /**\n     * @dev Sets the enforced options for specific endpoint and message type combinations.\n     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.\n     *\n     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.\n     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.\n     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay\n     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().\n     */\n    function _setEnforcedOptions(EnforcedOptionParam[] memory _enforcedOptions) internal virtual {\n        for (uint256 i = 0; i < _enforcedOptions.length; i++) {\n            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.\n            _assertOptionsType3(_enforcedOptions[i].options);\n            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;\n        }\n\n        emit EnforcedOptionSet(_enforcedOptions);\n    }\n\n    /**\n     * @notice Combines options for a given endpoint and message type.\n     * @param _eid The endpoint ID.\n     * @param _msgType The OAPP message type.\n     * @param _extraOptions Additional options passed by the caller.\n     * @return options The combination of caller specified options AND enforced options.\n     *\n     * @dev If there is an enforced lzReceive option:\n     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}\n     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.\n     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.\n     */\n    function combineOptions(\n        uint32 _eid,\n        uint16 _msgType,\n        bytes calldata _extraOptions\n    ) public view virtual returns (bytes memory) {\n        bytes memory enforced = enforcedOptions[_eid][_msgType];\n\n        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.\n        if (enforced.length == 0) return _extraOptions;\n\n        // No caller options, return enforced\n        if (_extraOptions.length == 0) return enforced;\n\n        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.\n        if (_extraOptions.length >= 2) {\n            _assertOptionsType3(_extraOptions);\n            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.\n            return bytes.concat(enforced, _extraOptions[2:]);\n        }\n\n        // No valid set of options was found.\n        revert InvalidOptions(_extraOptions);\n    }\n\n    /**\n     * @dev Internal function to assert that options are of type 3.\n     * @param _options The options to be checked.\n     */\n    function _assertOptionsType3(bytes memory _options) internal pure virtual {\n        uint16 optionsType;\n        assembly {\n            optionsType := mload(add(_options, 2))\n        }\n        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) Ownable(_delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.\n// solhint-disable-next-line no-unused-import\nimport { InboundPacket, Origin } from \"../libs/Packet.sol\";\n\n/**\n * @title IOAppPreCrimeSimulator Interface\n * @dev Interface for the preCrime simulation functionality in an OApp.\n */\ninterface IOAppPreCrimeSimulator {\n    // @dev simulation result used in PreCrime implementation\n    error SimulationResult(bytes result);\n    error OnlySelf();\n\n    /**\n     * @dev Emitted when the preCrime contract address is set.\n     * @param preCrimeAddress The address of the preCrime contract.\n     */\n    event PreCrimeSet(address preCrimeAddress);\n\n    /**\n     * @dev Retrieves the address of the preCrime contract implementation.\n     * @return The address of the preCrime contract.\n     */\n    function preCrime() external view returns (address);\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     */\n    function oApp() external view returns (address);\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) external;\n\n    /**\n     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.\n     * @param _packets An array of LayerZero InboundPacket objects representing received packets.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/interfaces/IPreCrime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\nstruct PreCrimePeer {\n    uint32 eid;\n    bytes32 preCrime;\n    bytes32 oApp;\n}\n\n// TODO not done yet\ninterface IPreCrime {\n    error OnlyOffChain();\n\n    // for simulate()\n    error PacketOversize(uint256 max, uint256 actual);\n    error PacketUnsorted();\n    error SimulationFailed(bytes reason);\n\n    // for preCrime()\n    error SimulationResultNotFound(uint32 eid);\n    error InvalidSimulationResult(uint32 eid, bytes reason);\n    error CrimeFound(bytes crime);\n\n    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);\n\n    function simulate(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues\n    ) external payable returns (bytes memory);\n\n    function buildSimulationResult() external view returns (bytes memory);\n\n    function preCrime(\n        bytes[] calldata _packets,\n        uint256[] calldata _packetMsgValues,\n        bytes[] calldata _simulations\n    ) external;\n\n    function version() external view returns (uint64 major, uint8 minor);\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/libs/Packet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { PacketV1Codec } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\";\n\n/**\n * @title InboundPacket\n * @dev Structure representing an inbound packet received by the contract.\n */\nstruct InboundPacket {\n    Origin origin; // Origin information of the packet.\n    uint32 dstEid; // Destination endpointId of the packet.\n    address receiver; // Receiver address for the packet.\n    bytes32 guid; // Unique identifier of the packet.\n    uint256 value; // msg.value of the packet.\n    address executor; // Executor address for the packet.\n    bytes message; // Message payload of the packet.\n    bytes extraData; // Additional arbitrary data for the packet.\n}\n\n/**\n * @title PacketDecoder\n * @dev Library for decoding LayerZero packets.\n */\nlibrary PacketDecoder {\n    using PacketV1Codec for bytes;\n\n    /**\n     * @dev Decode an inbound packet from the given packet data.\n     * @param _packet The packet data to decode.\n     * @return packet An InboundPacket struct representing the decoded packet.\n     */\n    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {\n        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());\n        packet.dstEid = _packet.dstEid();\n        packet.receiver = _packet.receiverB20();\n        packet.guid = _packet.guid();\n        packet.message = _packet.message();\n    }\n\n    /**\n     * @dev Decode multiple inbound packets from the given packet data and associated message values.\n     * @param _packets An array of packet data to decode.\n     * @param _packetMsgValues An array of associated message values for each packet.\n     * @return packets An array of InboundPacket structs representing the decoded packets.\n     */\n    function decode(\n        bytes[] calldata _packets,\n        uint256[] memory _packetMsgValues\n    ) internal pure returns (InboundPacket[] memory packets) {\n        packets = new InboundPacket[](_packets.length);\n        for (uint256 i = 0; i < _packets.length; i++) {\n            bytes calldata packet = _packets[i];\n            packets[i] = PacketDecoder.decode(packet);\n            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.\n            packets[i].value = _packetMsgValues[i];\n        }\n    }\n}\n"
    },
    "@layerzerolabs/oapp-evm/contracts/precrime/OAppPreCrimeSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPreCrime } from \"./interfaces/IPreCrime.sol\";\nimport { IOAppPreCrimeSimulator, InboundPacket, Origin } from \"./interfaces/IOAppPreCrimeSimulator.sol\";\n\n/**\n * @title OAppPreCrimeSimulator\n * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.\n */\nabstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {\n    // The address of the preCrime implementation.\n    address public preCrime;\n\n    /**\n     * @dev Retrieves the address of the OApp contract.\n     * @return The address of the OApp contract.\n     *\n     * @dev The simulator contract is the base contract for the OApp by default.\n     * @dev If the simulator is a separate contract, override this function.\n     */\n    function oApp() external view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Sets the preCrime contract address.\n     * @param _preCrime The address of the preCrime contract.\n     */\n    function setPreCrime(address _preCrime) public virtual onlyOwner {\n        preCrime = _preCrime;\n        emit PreCrimeSet(_preCrime);\n    }\n\n    /**\n     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.\n     * @param _packets An array of InboundPacket objects representing received packets to be delivered.\n     *\n     * @dev WARNING: MUST revert at the end with the simulation results.\n     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,\n     * WITHOUT actually executing them.\n     */\n    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {\n        for (uint256 i = 0; i < _packets.length; i++) {\n            InboundPacket calldata packet = _packets[i];\n\n            // Ignore packets that are not from trusted peers.\n            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;\n\n            // @dev Because a verifier is calling this function, it doesnt have access to executor params:\n            //  - address _executor\n            //  - bytes calldata _extraData\n            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().\n            // They are instead stubbed to default values, address(0) and bytes(\"\")\n            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,\n            // which would cause the revert to be ignored.\n            this.lzReceiveSimulate{ value: packet.value }(\n                packet.origin,\n                packet.guid,\n                packet.message,\n                packet.executor,\n                packet.extraData\n            );\n        }\n\n        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().\n        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());\n    }\n\n    /**\n     * @dev Is effectively an internal function because msg.sender must be address(this).\n     * Allows resetting the call stack for 'internal' calls.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier of the packet.\n     * @param _message The message payload of the packet.\n     * @param _executor The executor address for the packet.\n     * @param _extraData Additional data for the packet.\n     */\n    function lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable virtual {\n        // @dev Ensure ONLY can be called 'internally'.\n        if (msg.sender != address(this)) revert OnlySelf();\n        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The GUID of the LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n\n    /**\n     * @dev checks if the specified peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint Id to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { MessagingReceipt, MessagingFee } from \"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT limit information.\n * @dev These amounts can change dynamically and are up the specific oft implementation.\n */\nstruct OFTLimit {\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @dev Struct representing OFT fee details.\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n */\nstruct OFTFeeDetail {\n    int256 feeAmountLD; // Amount of the fee in local decimals.\n    string description; // Description of the fee.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    // Custom error messages\n    error InvalidLocalDecimals();\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\n    error AmountSDOverflowed(uint256 amountSD);\n\n    // Events\n    event OFTSent(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n    event OFTReceived(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n\n    /**\n     * @notice Provides the fee breakdown and settings data for an OFT. Unused in the default implementation.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce for the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID for the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/libs/OFTMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTMsgCodec {\n    // Offset constants for encoding and decoding OFT messages\n    uint8 private constant SEND_TO_OFFSET = 32;\n    uint8 private constant SEND_AMOUNT_SD_OFFSET = 40;\n\n    /**\n     * @dev Encodes an OFT LayerZero message.\n     * @param _sendTo The recipient address.\n     * @param _amountShared The amount in shared decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded message.\n     * @return hasCompose A boolean indicating whether the message has a composed payload.\n     */\n    function encode(\n        bytes32 _sendTo,\n        uint64 _amountShared,\n        bytes memory _composeMsg\n    ) internal view returns (bytes memory _msg, bool hasCompose) {\n        hasCompose = _composeMsg.length > 0;\n        // @dev Remote chains will want to know the composed function caller ie. msg.sender on the src.\n        _msg = hasCompose\n            ? abi.encodePacked(_sendTo, _amountShared, addressToBytes32(msg.sender), _composeMsg)\n            : abi.encodePacked(_sendTo, _amountShared);\n    }\n\n    /**\n     * @dev Checks if the OFT message is composed.\n     * @param _msg The OFT message.\n     * @return A boolean indicating whether the message is composed.\n     */\n    function isComposed(bytes calldata _msg) internal pure returns (bool) {\n        return _msg.length > SEND_AMOUNT_SD_OFFSET;\n    }\n\n    /**\n     * @dev Retrieves the recipient address from the OFT message.\n     * @param _msg The OFT message.\n     * @return The recipient address.\n     */\n    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[:SEND_TO_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the amount in shared decimals from the OFT message.\n     * @param _msg The OFT message.\n     * @return The amount in shared decimals.\n     */\n    function amountSD(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[SEND_TO_OFFSET:SEND_AMOUNT_SD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composed message from the OFT message.\n     * @param _msg The OFT message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[SEND_AMOUNT_SD_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/OFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IOFT, OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title OFT Contract\n * @dev OFT is an ERC-20 token that extends the functionality of the OFTCore contract.\n */\nabstract contract OFT is OFTCore, ERC20 {\n    /**\n     * @dev Constructor for the OFT contract.\n     * @param _name The name of the OFT.\n     * @param _symbol The symbol of the OFT.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lzEndpoint,\n        address _delegate\n    ) ERC20(_name, _symbol) OFTCore(decimals(), _lzEndpoint, _delegate) {}\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the OFT token.\n     *\n     * @dev In the case of OFT, address(this) and erc20 are the same contract.\n     */\n    function token() public view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev In the case of OFT where the contract IS the token, approval is NOT required.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Burns tokens from the sender's specified balance.\n     * @param _from The address to debit the tokens from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n\n        // @dev In NON-default OFT, amountSentLD could be 100, with a 10% fee, the amountReceivedLD amount is 90,\n        // therefore amountSentLD CAN differ from amountReceivedLD.\n\n        // @dev Default OFT burns on src.\n        _burn(_from, amountSentLD);\n    }\n\n    /**\n     * @dev Credits tokens to the specified address.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @dev _srcEid The source chain ID.\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /*_srcEid*/\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        if (_to == address(0x0)) _to = address(0xdead); // _mint(...) does not support address(0x0)\n        // @dev Default OFT mints on dst.\n        _mint(_to, _amountLD);\n        // @dev In the case of NON-default OFT, the _amountLD MIGHT not be == amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/OFTAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata, IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IOFT, OFTCore } from \"./OFTCore.sol\";\n\n/**\n * @title OFTAdapter Contract\n * @dev OFTAdapter is a contract that adapts an ERC-20 token to the OFT functionality.\n *\n * @dev For existing ERC20 tokens, this can be used to convert the token to crosschain compatibility.\n * @dev WARNING: ONLY 1 of these should exist for a given global mesh,\n * unless you make a NON-default implementation of OFT and needs to be done very carefully.\n * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n * a pre/post balance check will need to be done to calculate the amountSentLD/amountReceivedLD.\n */\nabstract contract OFTAdapter is OFTCore {\n    using SafeERC20 for IERC20;\n\n    IERC20 internal immutable innerToken;\n\n    /**\n     * @dev Constructor for the OFTAdapter contract.\n     * @param _token The address of the ERC-20 token to be adapted.\n     * @param _lzEndpoint The LayerZero endpoint address.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(\n        address _token,\n        address _lzEndpoint,\n        address _delegate\n    ) OFTCore(IERC20Metadata(_token).decimals(), _lzEndpoint, _delegate) {\n        innerToken = IERC20(_token);\n    }\n\n    /**\n     * @dev Retrieves the address of the underlying ERC20 implementation.\n     * @return The address of the adapted ERC-20 token.\n     *\n     * @dev In the case of OFTAdapter, address(this) and erc20 are NOT the same contract.\n     */\n    function token() public view returns (address) {\n        return address(innerToken);\n    }\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev In the case of default OFTAdapter, approval is required.\n     * @dev In non-default OFTAdapter contracts with something like mint and burn privileges, it would NOT need approval.\n     */\n    function approvalRequired() external pure virtual returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Locks tokens from the sender's specified balance in this contract.\n     * @param _from The address to debit from.\n     * @param _amountLD The amount of tokens to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination chain ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev msg.sender will need to approve this _amountLD of tokens to be locked inside of the contract.\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);\n        // @dev Lock tokens by moving them into this contract from the caller.\n        innerToken.safeTransferFrom(_from, address(this), amountSentLD);\n    }\n\n    /**\n     * @dev Credits tokens to the specified address.\n     * @param _to The address to credit the tokens to.\n     * @param _amountLD The amount of tokens to credit in local decimals.\n     * @dev _srcEid The source chain ID.\n     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.\n     *\n     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.\n     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...\n     * a pre/post balance check will need to be done to calculate the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 /*_srcEid*/\n    ) internal virtual override returns (uint256 amountReceivedLD) {\n        // @dev Unlock the tokens and transfer to the recipient.\n        innerToken.safeTransfer(_to, _amountLD);\n        // @dev In the case of NON-default OFTAdapter, the amountLD MIGHT not be == amountReceivedLD.\n        return _amountLD;\n    }\n}\n"
    },
    "@layerzerolabs/oft-evm/contracts/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { OApp, Origin } from \"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\";\nimport { OAppOptionsType3 } from \"@layerzerolabs/oapp-evm/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport { IOAppMsgInspector } from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\n\nimport { OAppPreCrimeSimulator } from \"@layerzerolabs/oapp-evm/contracts/precrime/OAppPreCrimeSimulator.sol\";\n\nimport { IOFT, SendParam, OFTLimit, OFTReceipt, OFTFeeDetail, MessagingReceipt, MessagingFee } from \"./interfaces/IOFT.sol\";\nimport { OFTMsgCodec } from \"./libs/OFTMsgCodec.sol\";\nimport { OFTComposeMsgCodec } from \"./libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title OFTCore\n * @dev Abstract contract for the OftChain (OFT) token.\n */\nabstract contract OFTCore is IOFT, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    // @notice Provides a conversion rate when swapping between denominations of SD and LD\n    //      - shareDecimals == SD == shared Decimals\n    //      - localDecimals == LD == local decimals\n    // @dev Considers that tokens have different decimal amounts on various chains.\n    // @dev eg.\n    //  For a token\n    //      - locally with 4 decimals --> 1.2345 => uint(12345)\n    //      - remotely with 2 decimals --> 1.23 => uint(123)\n    //      - The conversion rate would be 10 ** (4 - 2) = 100\n    //  @dev If you want to send 1.2345 -> (uint 12345), you CANNOT represent that value on the remote,\n    //  you can only display 1.23 -> uint(123).\n    //  @dev To preserve the dust that would otherwise be lost on that conversion,\n    //  we need to unify a denomination that can be represented on ALL chains inside of the OFT mesh\n    uint256 public immutable decimalConversionRate;\n\n    // @notice Msg types that are used to identify the various OFT operations.\n    // @dev This can be extended in child contracts for non-default oft operations\n    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.\n    uint16 public constant SEND = 1;\n    uint16 public constant SEND_AND_CALL = 2;\n\n    // Address of an optional contract to inspect both 'message' and 'options'\n    address public msgInspector;\n    event MsgInspectorSet(address inspector);\n\n    /**\n     * @dev Constructor.\n     * @param _localDecimals The decimals of the token on the local chain (this chain).\n     * @param _endpoint The address of the LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(uint8 _localDecimals, address _endpoint, address _delegate) OApp(_endpoint, _delegate) {\n        if (_localDecimals < sharedDecimals()) revert InvalidLocalDecimals();\n        decimalConversionRate = 10 ** (_localDecimals - sharedDecimals());\n    }\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {\n        return (type(IOFT).interfaceId, 1);\n    }\n\n    /**\n     * @dev Retrieves the shared decimals of the OFT.\n     * @return The shared decimals of the OFT.\n     *\n     * @dev Sets an implicit cap on the amount of tokens, over uint64.max() will need some sort of outbound cap / totalSupply cap\n     * Lowest common decimal denominator between chains.\n     * Defaults to 6 decimal places to provide up to 18,446,744,073,709.551615 units (max uint64).\n     * For tokens exceeding this totalSupply(), they will need to override the sharedDecimals function with something smaller.\n     * ie. 4 sharedDecimals would be 1,844,674,407,370,955.1615\n     */\n    function sharedDecimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev Sets the message inspector address for the OFT.\n     * @param _msgInspector The address of the message inspector.\n     *\n     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.\n     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.\n     */\n    function setMsgInspector(address _msgInspector) public virtual onlyOwner {\n        msgInspector = _msgInspector;\n        emit MsgInspectorSet(_msgInspector);\n    }\n\n    /**\n     * @notice Provides the fee breakdown and settings data for an OFT. Unused in the default implementation.\n     * @param _sendParam The parameters for the send operation.\n     * @return oftLimit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return oftReceipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    )\n        external\n        view\n        virtual\n        returns (OFTLimit memory oftLimit, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory oftReceipt)\n    {\n        uint256 minAmountLD = 0; // Unused in the default implementation.\n        uint256 maxAmountLD = IERC20(this.token()).totalSupply(); // Unused in the default implementation.\n        oftLimit = OFTLimit(minAmountLD, maxAmountLD);\n\n        // Unused in the default implementation; reserved for future complex fee details.\n        oftFeeDetails = new OFTFeeDetail[](0);\n\n        // @dev This is the same as the send() operation, but without the actual send.\n        // - amountSentLD is the amount in local decimals that would be sent from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        // @dev The amountSentLD MIGHT not equal the amount the user actually receives. HOWEVER, the default does.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debitView(\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return msgFee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        // @dev mock the amount to receive, this is the same operation used in the send().\n        // The quote is as similar as possible to the actual send() operation.\n        (, uint256 amountReceivedLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Calculates the LayerZero fee for the send() operation.\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    /**\n     * @dev Executes the send operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The calculated fee for the send() operation.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds.\n     * @return msgReceipt The receipt for the send operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        return _send(_sendParam, _fee, _refundAddress);\n    }\n\n    /**\n     * @dev Internal function to execute the send operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The calculated fee for the send() operation.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds.\n     * @return msgReceipt The receipt for the send operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function _send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // @dev Applies the token transfers regarding this send() operation.\n        // - amountSentLD is the amount in local decimals that was ACTUALLY sent/debited from the sender.\n        // - amountReceivedLD is the amount in local decimals that will be received/credited to the recipient on the remote OFT instance.\n        (uint256 amountSentLD, uint256 amountReceivedLD) = _debit(\n            msg.sender,\n            _sendParam.amountLD,\n            _sendParam.minAmountLD,\n            _sendParam.dstEid\n        );\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);\n\n        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);\n        // @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);\n\n        emit OFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, amountSentLD, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to build the message and options.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _amountLD The amount in local decimals.\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function _buildMsgAndOptions(\n        SendParam calldata _sendParam,\n        uint256 _amountLD\n    ) internal view virtual returns (bytes memory message, bytes memory options) {\n        bool hasCompose;\n        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.\n        (message, hasCompose) = OFTMsgCodec.encode(\n            _sendParam.to,\n            _toSD(_amountLD),\n            // @dev Must be include a non empty bytes if you want to compose, EVEN if you dont need it on the remote.\n            // EVEN if you dont require an arbitrary payload to be sent... eg. '0x01'\n            _sendParam.composeMsg\n        );\n        // @dev Change the msg type depending if its composed or not.\n        uint16 msgType = hasCompose ? SEND_AND_CALL : SEND;\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n        options = combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        address inspector = msgInspector; // caches the msgInspector to avoid potential double storage read\n        if (inspector != address(0)) IOAppMsgInspector(inspector).inspect(message, options);\n    }\n\n    /**\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address /*_executor*/, // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesnt know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Credit the amountLD to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, _toLD(_message.amountSD()), _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Proprietary composeMsg format for the OFT.\n            bytes memory composeMsg = OFTComposeMsgCodec.encode(\n                _origin.nonce,\n                _origin.srcEid,\n                amountReceivedLD,\n                _message.composeMsg()\n            );\n\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(toAddress, _guid, 0 /* the index of the composed message*/, composeMsg);\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    /**\n     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The LayerZero message.\n     * @param _executor The address of the off-chain executor.\n     * @param _extraData Arbitrary data passed by the msg executor.\n     *\n     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,\n     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.\n     */\n    function _lzReceiveSimulate(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual override {\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Check if the peer is considered 'trusted' by the OApp.\n     * @param _eid The endpoint ID to check.\n     * @param _peer The peer to check.\n     * @return Whether the peer passed is considered 'trusted' by the OApp.\n     *\n     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.\n     */\n    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {\n        return peers[_eid] == _peer;\n    }\n\n    /**\n     * @dev Internal function to remove dust from the given local decimal amount.\n     * @param _amountLD The amount in local decimals.\n     * @return amountLD The amount after removing dust.\n     *\n     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.\n     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).\n     */\n    function _removeDust(uint256 _amountLD) internal view virtual returns (uint256 amountLD) {\n        return (_amountLD / decimalConversionRate) * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from shared decimals into local decimals.\n     * @param _amountSD The amount in shared decimals.\n     * @return amountLD The amount in local decimals.\n     */\n    function _toLD(uint64 _amountSD) internal view virtual returns (uint256 amountLD) {\n        return _amountSD * decimalConversionRate;\n    }\n\n    /**\n     * @dev Internal function to convert an amount from local decimals into shared decimals.\n     * @param _amountLD The amount in local decimals.\n     * @return amountSD The amount in shared decimals.\n     *\n     * @dev Reverts if the _amountLD in shared decimals overflows uint64.\n     * @dev eg. uint(2**64 + 123) with a conversion rate of 1 wraps around 2**64 to uint(123).\n     */\n    function _toSD(uint256 _amountLD) internal view virtual returns (uint64 amountSD) {\n        uint256 _amountSD = _amountLD / decimalConversionRate;\n        if (_amountSD > type(uint64).max) revert AmountSDOverflowed(_amountSD);\n        return uint64(_amountSD);\n    }\n\n    /**\n     * @dev Internal function to mock the amount mutation from a OFT debit() operation.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @dev _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent, in local decimals.\n     * @return amountReceivedLD The amount to be received on the remote chain, in local decimals.\n     *\n     * @dev This is where things like fees would be calculated and deducted from the amount to be received on the remote.\n     */\n    function _debitView(\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 /*_dstEid*/\n    ) internal view virtual returns (uint256 amountSentLD, uint256 amountReceivedLD) {\n        // @dev Remove the dust so nothing is lost on the conversion between chains with different decimals for the token.\n        amountSentLD = _removeDust(_amountLD);\n        // @dev The amount to send is the same as amount received in the default implementation.\n        amountReceivedLD = amountSentLD;\n\n        // @dev Check for slippage.\n        if (amountReceivedLD < _minAmountLD) {\n            revert SlippageExceeded(amountReceivedLD, _minAmountLD);\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a debit operation.\n     * @param _from The address to debit.\n     * @param _amountLD The amount to send in local decimals.\n     * @param _minAmountLD The minimum amount to send in local decimals.\n     * @param _dstEid The destination endpoint ID.\n     * @return amountSentLD The amount sent in local decimals.\n     * @return amountReceivedLD The amount received in local decimals on the remote.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _debit(\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        uint32 _dstEid\n    ) internal virtual returns (uint256 amountSentLD, uint256 amountReceivedLD);\n\n    /**\n     * @dev Internal function to perform a credit operation.\n     * @param _to The address to credit.\n     * @param _amountLD The amount to credit in local decimals.\n     * @param _srcEid The source endpoint ID.\n     * @return amountReceivedLD The amount ACTUALLY received in local decimals.\n     *\n     * @dev Defined here but are intended to be overriden depending on the OFT implementation.\n     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.\n     */\n    function _credit(\n        address _to,\n        uint256 _amountLD,\n        uint32 _srcEid\n    ) internal virtual returns (uint256 amountReceivedLD);\n}\n"
    },
    "@layerzerolabs/ovault-evm/contracts/interfaces/IVaultComposerSync.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\nimport { IOAppComposer } from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport { SendParam, MessagingFee } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\n\ninterface IVaultComposerSync is IOAppComposer {\n    /// ========================== EVENTS =====================================\n    event Sent(bytes32 indexed guid); // 0x27b5aea9\n    event Refunded(bytes32 indexed guid); // 0xfe509803\n\n    /// ========================== Error Messages =====================================\n    error ShareOFTNotAdapter(address shareOFT); // 0xfc1514ae\n    error ShareTokenNotVault(address shareERC20, address vault); // 0x0e178ab6\n    error AssetTokenNotVaultAsset(address assetERC20, address vaultAsset); // 0xba9d665f\n\n    error OnlyEndpoint(address caller); // 0x91ac5e4f\n    error OnlySelf(address caller); // 0xa19dbf00\n    error OnlyValidComposeCaller(address caller); // 0x84fb3f0d\n\n    error InsufficientMsgValue(uint256 expectedMsgValue, uint256 actualMsgValue); // 0x7cb769dc\n    error NoMsgValueExpected(); // 0x7578d2bd\n\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD); // 0x71c4efed\n\n    /// ========================== GLOBAL VARIABLE FUNCTIONS =====================================\n    function VAULT() external view returns (IERC4626);\n\n    function ASSET_OFT() external view returns (address);\n    function ASSET_ERC20() external view returns (address);\n    function SHARE_OFT() external view returns (address);\n    function SHARE_ERC20() external view returns (address);\n\n    function ENDPOINT() external view returns (address);\n    function VAULT_EID() external view returns (uint32);\n\n    /// ========================== Proxy OFT =====================================\n\n    /**\n     * @notice Deposits ERC20 assets from the caller into the vault and sends them to the recipient\n     * @param assetAmount The number of ERC20 tokens to deposit and send\n     * @param sendParam Parameters on how to send the shares to the recipient\n     * @param refundAddress Address to receive excess `msg.value`\n     */\n    function depositAndSend(uint256 assetAmount, SendParam memory sendParam, address refundAddress) external payable;\n\n    /**\n     * @notice Redeems vault shares and sends the resulting assets to the user\n     * @param shareAmount The number of vault shares to redeem\n     * @param sendParam Parameter that defines how to send the assets\n     * @param refundAddress Address to receive excess payment of the LZ fees\n     */\n    function redeemAndSend(uint256 shareAmount, SendParam memory sendParam, address refundAddress) external payable;\n\n    /**\n     * @notice Quotes the send operation for the given OFT and SendParam\n     * @param from The \"sender address\" used for the quote\n     * @param targetOft The OFT contract address to quote\n     * @param vaultInAmount The amount of tokens to send to the vault\n     * @param sendParam The parameters for the send operation\n     * @return MessagingFee The estimated fee for the send operation\n     * @dev This function can be overridden to implement custom quoting logic\n     */\n    function quoteSend(\n        address from,\n        address targetOft,\n        uint256 vaultInAmount,\n        SendParam memory sendParam\n    ) external view returns (MessagingFee memory);\n\n    /// ========================== Receive =====================================\n    receive() external payable;\n}\n"
    },
    "@layerzerolabs/ovault-evm/contracts/VaultComposerSync.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC4626, IERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport { IOFT, SendParam, MessagingFee } from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport { IOAppCore } from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol\";\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OFTComposeMsgCodec } from \"@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol\";\n\nimport { IVaultComposerSync } from \"./interfaces/IVaultComposerSync.sol\";\n\n/**\n * @title VaultComposerSync - Synchronous Vault Composer\n * @author LayerZero Labs (@shankars99, @TRileySchwarz)\n * @notice This contract is a composer that allows deposits and redemptions operations against a\n *         synchronous vault across different chains using LayerZero's OFT protocol.\n * @dev The contract is designed to handle deposits and redemptions of vault shares and assets,\n *      ensuring that the share and asset tokens are correctly managed and transferred across chains.\n *      It also includes slippage protection and refund mechanisms for failed transactions.\n * @dev Default refunds are enabled to EOA addresses only on the source.\n        Custom refunds to contracts can be implemented by overriding the _refund function.\n * @dev Default vault interface is IERC4626 - [ERC4626](https://eips.ethereum.org/EIPS/eip-4626) compliant vaults.\n *      Custom vaults can be implemented by overriding the _deposit and _redeem functions.\n */\ncontract VaultComposerSync is IVaultComposerSync, ReentrancyGuard {\n    using OFTComposeMsgCodec for bytes;\n    using OFTComposeMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    /// @dev Must be a synchronous vault - NO 2-step redemptions/deposit windows\n    IERC4626 public immutable VAULT;\n\n    address public immutable ASSET_OFT;\n    address public immutable ASSET_ERC20;\n    address public immutable SHARE_OFT;\n    address public immutable SHARE_ERC20;\n\n    address public immutable ENDPOINT;\n    uint32 public immutable VAULT_EID;\n\n    /**\n     * @notice Initializes the VaultComposerSync contract with vault and OFT token addresses\n     * @param _vault The address of the ERC4626 vault contract\n     * @param _assetOFT The address of the asset OFT (Omnichain Fungible Token) contract\n     * @param _shareOFT The address of the share OFT contract (must be an adapter)\n     *\n     * Requirements:\n     * - Share token must be the vault itself\n     * - Asset token must match the vault's underlying asset\n     * - Share OFT must be an adapter (approvalRequired() returns true)\n     */\n    constructor(address _vault, address _assetOFT, address _shareOFT) {\n        VAULT = IERC4626(_vault);\n\n        ASSET_OFT = _assetOFT;\n        ASSET_ERC20 = IOFT(ASSET_OFT).token();\n        SHARE_OFT = _shareOFT;\n        SHARE_ERC20 = IOFT(SHARE_OFT).token();\n\n        ENDPOINT = address(IOAppCore(ASSET_OFT).endpoint());\n        VAULT_EID = ILayerZeroEndpointV2(ENDPOINT).eid();\n\n        if (SHARE_ERC20 != address(VAULT)) {\n            revert ShareTokenNotVault(SHARE_ERC20, address(VAULT));\n        }\n\n        if (ASSET_ERC20 != address(VAULT.asset())) {\n            revert AssetTokenNotVaultAsset(ASSET_ERC20, address(VAULT.asset()));\n        }\n\n        /// @dev ShareOFT must be an OFT adapter. We can infer this by checking 'approvalRequired()'.\n        /// @dev burn() on tokens when a user sends changes totalSupply() which the asset:share ratio depends on.\n        if (!IOFT(SHARE_OFT).approvalRequired()) revert ShareOFTNotAdapter(SHARE_OFT);\n\n        /// @dev Approve the vault to spend the asset tokens held by this contract\n        IERC20(ASSET_ERC20).approve(_vault, type(uint256).max);\n        /// @dev Approving the vault for the share erc20 is not required when the vault is the share erc20\n        // IERC20(SHARE_ERC20).approve(_vault, type(uint256).max);\n\n        /// @dev Approve the share adapter with the share tokens held by this contract\n        IERC20(SHARE_ERC20).approve(_shareOFT, type(uint256).max);\n        /// @dev If the asset OFT is an adapter, approve it as well\n        if (IOFT(_assetOFT).approvalRequired()) IERC20(ASSET_ERC20).approve(_assetOFT, type(uint256).max);\n    }\n\n    /**\n     * @notice Handles LayerZero compose operations for vault transactions with automatic refund functionality\n     * @dev This composer is designed to handle refunds to an EOA address and not a contract\n     * @dev Any revert in handleCompose() causes a refund back to the src EXCEPT for InsufficientMsgValue\n     * @param _composeSender The OFT contract address used for refunds, must be either ASSET_OFT or SHARE_OFT\n     * @param _guid LayerZero's unique tx id (created on the source tx)\n     * @param _message Decomposable bytes object into [composeHeader][composeMessage]\n     */\n    function lzCompose(\n        address _composeSender, // The OFT used on refund, also the vaultIn token.\n        bytes32 _guid,\n        bytes calldata _message, // expected to contain a composeMessage = abi.encode(SendParam hopSendParam,uint256 minMsgValue)\n        address /*_executor*/,\n        bytes calldata /*_extraData*/\n    ) external payable virtual override {\n        if (msg.sender != ENDPOINT) revert OnlyEndpoint(msg.sender);\n        if (_composeSender != ASSET_OFT && _composeSender != SHARE_OFT) revert OnlyValidComposeCaller(_composeSender);\n\n        bytes32 composeFrom = _message.composeFrom();\n        uint256 amount = _message.amountLD();\n        bytes memory composeMsg = _message.composeMsg();\n\n        /// @dev try...catch to handle the compose operation. if it fails we refund the user\n        try this.handleCompose{ value: msg.value }(_composeSender, composeFrom, composeMsg, amount) {\n            emit Sent(_guid);\n        } catch (bytes memory _err) {\n            /// @dev A revert where the msg.value passed is lower than the min expected msg.value is handled separately\n            /// This is because it is possible to re-trigger from the endpoint the compose operation with the right msg.value\n            if (bytes4(_err) == InsufficientMsgValue.selector) {\n                assembly {\n                    revert(add(32, _err), mload(_err))\n                }\n            }\n\n            _refund(_composeSender, _message, amount, tx.origin);\n            emit Refunded(_guid);\n        }\n    }\n\n    /**\n     * @notice Handles the compose operation for OFT (Omnichain Fungible Token) transactions\n     * @dev This function can only be called by the contract itself (self-call restriction)\n     *      Decodes the compose message to extract SendParam and minimum message value\n     *      Routes to either deposit or redeem flow based on the input OFT token type\n     * @param _oftIn The OFT token whose funds have been received in the lzReceive associated with this lzTx\n     * @param _composeFrom The bytes32 identifier of the compose sender\n     * @param _composeMsg The encoded message containing SendParam and minMsgValue\n     * @param _amount The amount of tokens received in the lzReceive associated with this lzTx\n     */\n    function handleCompose(\n        address _oftIn,\n        bytes32 _composeFrom,\n        bytes memory _composeMsg,\n        uint256 _amount\n    ) external payable {\n        /// @dev Can only be called by self\n        if (msg.sender != address(this)) revert OnlySelf(msg.sender);\n\n        /// @dev SendParam defines how the composer will handle the user's funds\n        /// @dev The minMsgValue is the minimum amount of msg.value that must be sent, failing to do so will revert and the transaction will be retained in the endpoint for future retries\n        (SendParam memory sendParam, uint256 minMsgValue) = abi.decode(_composeMsg, (SendParam, uint256));\n        if (msg.value < minMsgValue) revert InsufficientMsgValue(minMsgValue, msg.value);\n\n        if (_oftIn == ASSET_OFT) {\n            _depositAndSend(_composeFrom, _amount, sendParam, tx.origin);\n        } else {\n            _redeemAndSend(_composeFrom, _amount, sendParam, tx.origin);\n        }\n    }\n\n    /**\n     * @notice Deposits ERC20 assets from the caller into the vault and sends them to the recipient\n     * @param _assetAmount The number of ERC20 tokens to deposit and send\n     * @param _sendParam Parameters on how to send the shares to the recipient\n     * @param _refundAddress Address to receive excess `msg.value`\n     */\n    function depositAndSend(\n        uint256 _assetAmount,\n        SendParam memory _sendParam,\n        address _refundAddress\n    ) external payable virtual nonReentrant {\n        IERC20(ASSET_ERC20).safeTransferFrom(msg.sender, address(this), _assetAmount);\n        _depositAndSend(OFTComposeMsgCodec.addressToBytes32(msg.sender), _assetAmount, _sendParam, _refundAddress);\n    }\n\n    /**\n     * @dev Internal function that deposits assets and sends shares to another chain\n     * @param _depositor The depositor (bytes32 format to account for non-evm addresses)\n     * @param _assetAmount The number of assets to deposit\n     * @param _sendParam Parameter that defines how to send the shares\n     * @param _refundAddress Address to receive excess payment of the LZ fees\n     * @notice This function first deposits the assets to mint shares, validates the shares meet minimum slippage requirements,\n     *         then sends the minted shares cross-chain using the OFT (Omnichain Fungible Token) protocol\n     * @notice The _sendParam.amountLD is updated to the actual share amount minted, and minAmountLD is reset to 0 for the send operation\n     */\n    function _depositAndSend(\n        bytes32 _depositor,\n        uint256 _assetAmount,\n        SendParam memory _sendParam,\n        address _refundAddress\n    ) internal virtual {\n        uint256 shareAmount = _deposit(_depositor, _assetAmount);\n        _assertSlippage(shareAmount, _sendParam.minAmountLD);\n\n        _sendParam.amountLD = shareAmount;\n        _sendParam.minAmountLD = 0;\n\n        _send(SHARE_OFT, _sendParam, _refundAddress);\n    }\n\n    /**\n     * @dev Internal function to deposit assets into the vault\n     * @param _assetAmount The number of assets to deposit into the vault\n     * @return shareAmount The number of shares received from the vault deposit\n     * @notice This function is expected to be overridden by the inheriting contract to implement custom/nonERC4626 deposit logic\n     */\n    function _deposit(bytes32 /*_depositor*/, uint256 _assetAmount) internal virtual returns (uint256 shareAmount) {\n        shareAmount = VAULT.deposit(_assetAmount, address(this));\n    }\n\n    /**\n     * @notice Redeems vault shares and sends the resulting assets to the user\n     * @param _shareAmount The number of vault shares to redeem\n     * @param _sendParam Parameter that defines how to send the assets\n     * @param _refundAddress Address to receive excess payment of the LZ fees\n     */\n    function redeemAndSend(\n        uint256 _shareAmount,\n        SendParam memory _sendParam,\n        address _refundAddress\n    ) external payable virtual nonReentrant {\n        IERC20(SHARE_ERC20).safeTransferFrom(msg.sender, address(this), _shareAmount);\n        _redeemAndSend(OFTComposeMsgCodec.addressToBytes32(msg.sender), _shareAmount, _sendParam, _refundAddress);\n    }\n\n    /**\n     * @dev Internal function that redeems shares for assets and sends them cross-chain\n     * @param _redeemer The address of the redeemer in bytes32 format\n     * @param _shareAmount The number of shares to redeem\n     * @param _sendParam Parameter that defines how to send the assets\n     * @param _refundAddress Address to receive excess payment of the LZ fees\n     * @notice This function first redeems the specified share amount for the underlying asset,\n     *         validates the received amount against slippage protection, then initiates a cross-chain\n     *         transfer of the redeemed assets using the OFT (Omnichain Fungible Token) protocol\n     * @notice The minAmountLD in _sendParam is reset to 0 after slippage validation since the\n     *         actual amount has already been verified\n     */\n    function _redeemAndSend(\n        bytes32 _redeemer,\n        uint256 _shareAmount,\n        SendParam memory _sendParam,\n        address _refundAddress\n    ) internal virtual {\n        uint256 assetAmount = _redeem(_redeemer, _shareAmount);\n        _assertSlippage(assetAmount, _sendParam.minAmountLD);\n\n        _sendParam.amountLD = assetAmount;\n        _sendParam.minAmountLD = 0;\n\n        _send(ASSET_OFT, _sendParam, _refundAddress);\n    }\n\n    /**\n     * @dev Internal function to redeem shares from the vault\n     * @param _shareAmount The number of shares to redeem from the vault\n     * @return assetAmount The number of assets received from the vault redemption\n     * @notice This function is expected to be overridden by the inheriting contract to implement custom/nonERC4626 redemption logic\n     */\n    function _redeem(bytes32 /*_redeemer*/, uint256 _shareAmount) internal virtual returns (uint256 assetAmount) {\n        assetAmount = VAULT.redeem(_shareAmount, address(this), address(this));\n    }\n\n    /**\n     * @param _amountLD The amount of tokens to send\n     * @param _minAmountLD The minimum amount of tokens that must be sent to avoid slippage\n     * @notice This function checks if the amount sent is less than the minimum amount\n     *         If it is, it reverts with SlippageExceeded error\n     * @notice This function can be overridden to implement custom slippage logic\n     */\n    function _assertSlippage(uint256 _amountLD, uint256 _minAmountLD) internal view virtual {\n        if (_amountLD < _minAmountLD) revert SlippageExceeded(_amountLD, _minAmountLD);\n    }\n\n    /**\n     * @notice Quotes the send operation for the given OFT and SendParam\n     * @dev Revert on slippage will be thrown by the OFT and not _assertSlippage\n     * @param _from The \"sender address\" used for the quote\n     * @param _targetOFT The OFT contract address to quote\n     * @param _vaultInAmount The amount of tokens to send to the vault\n     * @param _sendParam The parameters for the send operation\n     * @return MessagingFee The estimated fee for the send operation\n     * @dev This function can be overridden to implement custom quoting logic\n     */\n    function quoteSend(\n        address _from,\n        address _targetOFT,\n        uint256 _vaultInAmount,\n        SendParam memory _sendParam\n    ) external view virtual returns (MessagingFee memory) {\n        /// @dev When quoting the asset OFT, the function input is shares and the SendParam.amountLD into quoteSend() should be assets (and vice versa)\n\n        if (_targetOFT == ASSET_OFT) {\n            uint256 maxRedeem = VAULT.maxRedeem(_from);\n            if (_vaultInAmount > maxRedeem) {\n                revert ERC4626.ERC4626ExceededMaxRedeem(_from, _vaultInAmount, maxRedeem);\n            }\n\n            _sendParam.amountLD = VAULT.previewRedeem(_vaultInAmount);\n        } else {\n            uint256 maxDeposit = VAULT.maxDeposit(_from);\n            if (_vaultInAmount > maxDeposit) {\n                revert ERC4626.ERC4626ExceededMaxDeposit(_from, _vaultInAmount, maxDeposit);\n            }\n\n            _sendParam.amountLD = VAULT.previewDeposit(_vaultInAmount);\n        }\n        return IOFT(_targetOFT).quoteSend(_sendParam, false);\n    }\n\n    /**\n     * @dev Internal function that handles token transfer to the recipient\n     * @dev If the destination eid is the same as the current eid, it transfers the tokens directly to the recipient\n     * @dev If the destination eid is different, it sends a LayerZero cross-chain transaction\n     * @param _oft The OFT contract address to use for sending\n     * @param _sendParam The parameters for the send operation\n     * @param _refundAddress Address to receive excess payment of the LZ fees\n     */\n    function _send(address _oft, SendParam memory _sendParam, address _refundAddress) internal {\n        if (_sendParam.dstEid == VAULT_EID) {\n            /// @dev Can do this because _oft is validated before this function is called\n            address erc20 = _oft == ASSET_OFT ? ASSET_ERC20 : SHARE_ERC20;\n\n            if (msg.value > 0) revert NoMsgValueExpected();\n            IERC20(erc20).safeTransfer(_sendParam.to.bytes32ToAddress(), _sendParam.amountLD);\n        } else {\n            // crosschain send\n            IOFT(_oft).send{ value: msg.value }(_sendParam, MessagingFee(msg.value, 0), _refundAddress);\n        }\n    }\n\n    /**\n     * @dev Internal function to refund input tokens to sender on source during a failed transaction\n     * @param _oft The OFT contract address used for refunding\n     * @param _message The original message that was sent\n     * @param _amount The amount of tokens to refund\n     * @param _refundAddress Address to receive the refund\n     */\n    function _refund(address _oft, bytes calldata _message, uint256 _amount, address _refundAddress) internal virtual {\n        /// @dev Extracted from the _message header. Will always be part of the _message since it is created by lzReceive\n        SendParam memory refundSendParam;\n        refundSendParam.dstEid = OFTComposeMsgCodec.srcEid(_message);\n        refundSendParam.to = OFTComposeMsgCodec.composeFrom(_message);\n        refundSendParam.amountLD = _amount;\n\n        IOFT(_oft).send{ value: msg.value }(refundSendParam, MessagingFee(msg.value, 0), _refundAddress);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC4626.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/core/config/OmniDragonRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/config/IOmniDragonRegistry.sol\";\n\n//\n/**\n * @title OmniDragonRegistry\n * @author 0xakita.eth\n * @dev Registry for omniDRAGON deployment\n *\n * Provides:\n * - Deterministic address calculation via CREATE2\n * - Basic chain configuration storage\n * - LayerZero configuration during deployment\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract OmniDragonRegistry is IOmniDragonRegistry, Ownable {\n  // Chain configuration\n  mapping(uint16 => IOmniDragonRegistry.ChainConfig) private chainConfigs;\n  uint16[] private supportedChains;\n  uint16 private currentChainId;\n  uint256 public constant MAX_SUPPORTED_CHAINS = 50;\n\n  // LayerZero endpoints and mapping\n  mapping(uint256 => uint32) public chainIdToEid;\n  mapping(uint32 => uint256) public eidToChainId;\n  mapping(uint16 => address) public layerZeroEndpoints;\n  address public immutable layerZeroCommonEndpoint;\n\n  // Oracles\n  mapping(uint16 => address) public priceOracles;\n  mapping(uint16 => IOmniDragonRegistry.OracleConfig) public oracleConfigs;\n  address public primaryOracle;\n  uint32 public primaryChainEid;\n  mapping(uint16 => address) public secondaryOracles;\n\n  // Events\n  event CurrentChainSet(uint16 indexed chainId);\n  event LayerZeroConfigured(address indexed oapp, uint32 indexed eid, string configType);\n  event LayerZeroLibrarySet(address indexed oapp, uint32 indexed eid, address lib, string libraryType);\n  event LayerZeroEndpointUpdated(uint16 indexed chainId, address endpoint);\n  event WrappedNativeSymbolUpdated(uint16 indexed chainId, string symbol);\n  event ChainIdToEidUpdated(uint256 chainId, uint32 eid);\n  event SecondaryOracleSet(uint16 indexed chainId, address indexed oracle);\n\n  // Errors\n  error ChainAlreadyRegistered(uint16 chainId);\n  error ChainNotRegistered(uint16 chainId);\n  error ZeroAddress();\n  error TooManyChains();\n\n  struct SetConfigParam { uint32 eid; uint32 configType; bytes config; }\n\n  constructor(address _initialOwner) Ownable(_initialOwner) {\n    currentChainId = uint16(block.chainid);\n    layerZeroCommonEndpoint = 0x1a44076050125825900e736c501f859c50fE728c;\n    layerZeroEndpoints[146] = layerZeroCommonEndpoint;\n    layerZeroEndpoints[42161] = layerZeroCommonEndpoint;\n    layerZeroEndpoints[43114] = layerZeroCommonEndpoint;\n  }\n\n  // Internal\n  function _getDefaultWrappedNativeSymbol(uint256 _chainId) internal pure returns (string memory) {\n    if (_chainId == 146) return \"WS\";\n    if (_chainId == 43114) return \"WAVAX\";\n    if (_chainId == 250) return \"WFTM\";\n    if (_chainId == 137) return \"WMATIC\";\n    if (_chainId == 56) return \"WBNB\";\n    if (_chainId == 239) return \"WTAC\";\n    if (_chainId == 999) return \"HYPE\";\n    return \"WETH\";\n  }\n\n  // Chain config\n  function setCurrentChainId(uint16 _chainId) external onlyOwner { currentChainId = _chainId; emit CurrentChainSet(_chainId); }\n\n  function registerChain(\n    uint16 _chainId, string calldata _chainName, address _wrappedNativeToken, address _uniswapV2Router, address _uniswapV2Factory, bool _isActive\n  ) external override onlyOwner {\n    if (chainConfigs[_chainId].chainId == _chainId) revert ChainAlreadyRegistered(_chainId);\n    if (supportedChains.length >= MAX_SUPPORTED_CHAINS) revert TooManyChains();\n    chainConfigs[_chainId] = IOmniDragonRegistry.ChainConfig({\n      chainId: _chainId,\n      chainName: _chainName,\n      wrappedNativeToken: _wrappedNativeToken,\n      wrappedNativeSymbol: _getDefaultWrappedNativeSymbol(_chainId),\n      uniswapV2Router: _uniswapV2Router,\n      uniswapV2Factory: _uniswapV2Factory,\n      isActive: _isActive\n    });\n    supportedChains.push(_chainId);\n    emit ChainRegistered(_chainId, _chainName);\n  }\n\n  function updateChain(uint16 _chainId, string calldata _chainName, address _wrappedNativeToken, address _uniswapV2Router, address _uniswapV2Factory) external override onlyOwner {\n    if (chainConfigs[_chainId].chainId != _chainId) revert ChainNotRegistered(_chainId);\n    chainConfigs[_chainId].chainName = _chainName;\n    chainConfigs[_chainId].wrappedNativeToken = _wrappedNativeToken;\n    chainConfigs[_chainId].wrappedNativeSymbol = _getDefaultWrappedNativeSymbol(_chainId);\n    chainConfigs[_chainId].uniswapV2Router = _uniswapV2Router;\n    chainConfigs[_chainId].uniswapV2Factory = _uniswapV2Factory;\n    emit ChainUpdated(_chainId);\n  }\n\n  function updateWrappedNativeSymbol(uint16 _chainId, string calldata _symbol) external onlyOwner {\n    if (chainConfigs[_chainId].chainId != _chainId) revert ChainNotRegistered(_chainId);\n    chainConfigs[_chainId].wrappedNativeSymbol = _symbol; emit WrappedNativeSymbolUpdated(_chainId, _symbol); emit ChainUpdated(_chainId);\n  }\n\n  function setChainStatus(uint16 _chainId, bool _isActive) external override onlyOwner {\n    if (chainConfigs[_chainId].chainId != _chainId) revert ChainNotRegistered(_chainId);\n    chainConfigs[_chainId].isActive = _isActive; emit ChainStatusChanged(_chainId, _isActive);\n  }\n\n  function getChainConfig(uint16 _chainId) external view override returns (IOmniDragonRegistry.ChainConfig memory) {\n    if (chainConfigs[_chainId].chainId != _chainId) revert ChainNotRegistered(_chainId);\n    return chainConfigs[_chainId];\n  }\n\n  function getSupportedChains() external view override returns (uint16[] memory) { return supportedChains; }\n  function getCurrentChainId() external view override returns (uint16) { return currentChainId; }\n  function isChainSupported(uint16 _chainId) external view override returns (bool) { return chainConfigs[_chainId].isActive && chainConfigs[_chainId].chainId == _chainId; }\n\n  // Endpoints and mapping\n  function setChainIdToEid(uint256 _chainId, uint32 _eid) external onlyOwner { chainIdToEid[_chainId] = _eid; eidToChainId[_eid] = _chainId; emit ChainIdToEidUpdated(_chainId, _eid); }\n  function setLayerZeroEndpoint(uint16 _chainId, address _endpoint) external onlyOwner { if (_endpoint == address(0)) revert ZeroAddress(); layerZeroEndpoints[_chainId] = _endpoint; emit LayerZeroEndpointUpdated(_chainId, _endpoint); }\n  function getLayerZeroEndpoint(uint16 _chainId) external view returns (address) { address ep = layerZeroEndpoints[_chainId]; return ep == address(0) ? layerZeroCommonEndpoint : ep; }\n\n  // Lookups\n  function getWrappedNativeToken(uint16 _chainId) external view override returns (address) { return chainConfigs[_chainId].wrappedNativeToken; }\n  function getWrappedNativeSymbol(uint16 _chainId) external view override returns (string memory) { return chainConfigs[_chainId].wrappedNativeSymbol; }\n  function getUniswapV2Router(uint16 _chainId) external view override returns (address) { return chainConfigs[_chainId].uniswapV2Router; }\n  function getUniswapV2Factory(uint16 _chainId) external view override returns (address) { return chainConfigs[_chainId].uniswapV2Factory; }\n\n  // Oracle management\n  function setPriceOracle(uint16 _chainId, address _oracle) external override onlyOwner { require(_oracle != address(0), \"Invalid oracle address\"); priceOracles[_chainId] = _oracle; oracleConfigs[_chainId].isConfigured = true; emit PriceOracleSet(_chainId, _oracle); }\n  function getPriceOracle(uint16 _chainId) external view returns (address) { return priceOracles[_chainId]; }\n  function setSecondaryOracle(uint16 _chainId, address _oracle) external onlyOwner { require(_oracle != address(0), \"Invalid oracle address\"); secondaryOracles[_chainId] = _oracle; emit SecondaryOracleSet(_chainId, _oracle); }\n  function getSecondaryOracle(uint16 _chainId) external view returns (address) { return secondaryOracles[_chainId]; }\n  function configurePrimaryOracle(address _primaryOracle, uint32 _chainEid) external override onlyOwner { require(_primaryOracle != address(0), \"Invalid oracle address\"); primaryOracle = _primaryOracle; primaryChainEid = _chainEid; priceOracles[146] = _primaryOracle; oracleConfigs[146].primaryOracle = _primaryOracle; oracleConfigs[146].primaryChainEid = _chainEid; oracleConfigs[146].isConfigured = true; emit PrimaryOracleConfigured(_primaryOracle, _chainEid); }\n  function setLzReadChannel(uint16 _chainId, uint32 _channelId) external override onlyOwner { oracleConfigs[_chainId].lzReadChannelId = _channelId; emit LzReadChannelConfigured(_chainId, _channelId); }\n  function getOracleConfig(uint16 _chainId) external view returns (IOmniDragonRegistry.OracleConfig memory) { return oracleConfigs[_chainId]; }\n\n  // LZ helpers\n  function _executeLowLevelCall(address target, bytes memory callData, string memory errorMessage) private {\n    (bool success, bytes memory returnData) = target.call(callData);\n    if (!success) { if (returnData.length > 0) { assembly { revert(add(returnData, 32), mload(returnData)) } } else { revert(errorMessage); } }\n  }\n  function configureSendLibrary(address _oapp, uint32 _eid, address _sendLib) external onlyOwner { require(_oapp!=address(0)&&_sendLib!=address(0),\"bad\"); address ep=layerZeroEndpoints[currentChainId]; require(ep!=address(0),\"no ep\"); bytes memory cd=abi.encodeWithSignature(\"setSendLibrary(address,uint32,address)\",_oapp,_eid,_sendLib); _executeLowLevelCall(ep,cd,\"lz setSendLibrary fail\"); emit LayerZeroLibrarySet(_oapp,_eid,_sendLib,\"Send\"); }\n  function configureReceiveLibrary(address _oapp, uint32 _eid, address _receiveLib, uint256 _grace) external onlyOwner { require(_oapp!=address(0)&&_receiveLib!=address(0),\"bad\"); address ep=layerZeroEndpoints[currentChainId]; require(ep!=address(0),\"no ep\"); bytes memory cd=abi.encodeWithSignature(\"setReceiveLibrary(address,uint32,address,uint256)\",_oapp,_eid,_receiveLib,_grace); _executeLowLevelCall(ep,cd,\"lz setReceiveLibrary fail\"); emit LayerZeroLibrarySet(_oapp,_eid,_receiveLib,\"Receive\"); }\n  function configureULNConfig(address _oapp, address _lib, uint32 _eid, uint64 _conf, address[] calldata _req, address[] calldata _opt, uint8 _optTh) external onlyOwner {\n    require(_oapp != address(0) && _lib != address(0) && _req.length > 0, \"bad\");\n    address ep = layerZeroEndpoints[currentChainId];\n    require(ep != address(0), \"no ep\");\n    // ULN V302 expects: (uint64 confirmations, uint8 requiredDVNCount, uint8 optionalDVNCount, uint8 optionalDVNThreshold, address[] requiredDVNs, address[] optionalDVNs)\n    bytes memory cfg = abi.encode(_conf, uint8(_req.length), uint8(_opt.length), _optTh, _req, _opt);\n    SetConfigParam[] memory params = new SetConfigParam[](1);\n    params[0] = SetConfigParam({ eid: _eid, configType: 2, config: cfg });\n    bytes memory cd = abi.encodeWithSignature(\"setConfig(address,address,(uint32,uint32,bytes)[])\", _oapp, _lib, params);\n    _executeLowLevelCall(ep, cd, \"lz setConfig fail\");\n    emit LayerZeroConfigured(_oapp, _eid, \"ULN_CONFIG\");\n  }\n\n  function configureExecutorConfig(address _oapp, address _lib, uint32 _eid, uint32 _maxMsgSize, address _executor) external onlyOwner {\n    require(_oapp != address(0) && _lib != address(0) && _executor != address(0), \"bad\");\n    address ep = layerZeroEndpoints[currentChainId];\n    require(ep != address(0), \"no ep\");\n    // ExecutorConfig: (uint32 maxMessageSize, address executor)\n    bytes memory cfg = abi.encode(_maxMsgSize, _executor);\n    SetConfigParam[] memory params = new SetConfigParam[](1);\n    params[0] = SetConfigParam({ eid: _eid, configType: 1, config: cfg });\n    bytes memory cd = abi.encodeWithSignature(\"setConfig(address,address,(uint32,uint32,bytes)[])\", _oapp, _lib, params);\n    _executeLowLevelCall(ep, cd, \"lz setConfig fail\");\n    emit LayerZeroConfigured(_oapp, _eid, \"EXECUTOR_CONFIG\");\n  }\n  function batchConfigureLayerZero(address _oapp,uint32 _eid,address _sendLib,address _recvLib,uint64 _conf,address[] calldata _req) external onlyOwner { this.configureSendLibrary(_oapp,_eid,_sendLib); this.configureReceiveLibrary(_oapp,_eid,_recvLib,0); address[] memory empty=new address[](0); this.configureULNConfig(_oapp,_sendLib,_eid,_conf,_req,empty,0); this.configureULNConfig(_oapp,_recvLib,_eid,_conf,_req,empty,0); emit LayerZeroConfigured(_oapp,_eid,\"BATCH_CONFIG\"); }\n  function configureOmniDragonPeer(address _oapp,uint32 _eid,bytes32 _peer) external onlyOwner { require(_oapp!=address(0)&&_peer!=bytes32(0),\"bad\"); bytes memory cd=abi.encodeWithSignature(\"setPeer(uint32,bytes32)\",_eid,_peer); _executeLowLevelCall(_oapp,cd,\"peer fail\"); emit LayerZeroConfigured(_oapp,_eid,\"PEER_SET\"); }\n  function configureOmniDragonEnforcedOptions(address _oapp, bytes[] calldata _opts) external onlyOwner { require(_oapp!=address(0)&&_opts.length>0,\"bad\"); bytes memory cd=abi.encodeWithSignature(\"setEnforcedOptions((uint32,uint16,bytes)[])\",_opts); _executeLowLevelCall(_oapp,cd,\"opts fail\"); emit LayerZeroConfigured(_oapp,0,\"ENFORCED_OPTIONS_SET\"); }\n  function transferContractOwnership(address _contract, address _newOwner) external onlyOwner { require(_contract!=address(0)&&_newOwner!=address(0),\"bad\"); bytes memory cd=abi.encodeWithSignature(\"transferOwnership(address)\",_newOwner); _executeLowLevelCall(_contract,cd,\"xfer owner fail\"); }\n}\n\n\n"
    },
    "contracts/core/governance/GaugeController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title GaugeController\n * @dev Minimal veCRV-like gauge voting controller for directing weights per epoch\n */\ncontract GaugeController is Ownable {\n  uint256 public constant WEEK = 7 days;\n\n  // Epoch => total weight (1e18)\n  mapping(uint256 => uint256) public epochTotalWeight;\n  // Gauge => epoch => weight (1e18)\n  mapping(bytes32 => mapping(uint256 => uint256)) public gaugeWeight;\n  // User => epoch => last vote timestamp (limit one update per epoch)\n  mapping(address => uint256) public userLastVoteEpoch;\n\n  // Track gauges\n  mapping(bytes32 => bool) public isGauge;\n\n  event GaugeAdded(bytes32 indexed gauge);\n  event Voted(address indexed user, bytes32[] gauges, uint256[] weightsBps, uint256 epochWeek);\n\n  constructor() Ownable(msg.sender) {}\n\n  function _currentEpoch() internal view returns (uint256) {\n    return (block.timestamp / WEEK) * WEEK;\n  }\n\n  function addGauge(bytes32 gauge) external onlyOwner {\n    require(!isGauge[gauge], \"exists\");\n    isGauge[gauge] = true;\n    emit GaugeAdded(gauge);\n  }\n\n  /**\n   * @notice Vote for gauges with basis points weights (sum <= 10000)\n   * @dev Reversible per epoch by re-voting; uses user's absolute influence via msg.sender only by relative BP.\n   */\n  function voteForGauges(bytes32[] calldata gauges, uint256[] calldata weightsBps) external {\n    require(gauges.length == weightsBps.length && gauges.length > 0, \"len\");\n    uint256 sum;\n    for (uint256 i = 0; i < gauges.length; i++) {\n      require(isGauge[gauges[i]], \"gauge\");\n      sum += weightsBps[i];\n    }\n    require(sum <= 10000, \"sum\");\n\n    uint256 epochWeek = _currentEpoch();\n    require(userLastVoteEpoch[msg.sender] < epochWeek, \"voted\");\n    userLastVoteEpoch[msg.sender] = epochWeek;\n\n    // For simplicity, treat each user's vote as 1 unit total, distributed by BPS\n    // Aggregate into epoch weights as 1e18 scaled\n    uint256 addedTotal;\n    for (uint256 i = 0; i < gauges.length; i++) {\n      uint256 w = (1e18 * weightsBps[i]) / 10000;\n      gaugeWeight[gauges[i]][epochWeek] += w;\n      addedTotal += w;\n    }\n    epochTotalWeight[epochWeek] += addedTotal;\n    emit Voted(msg.sender, gauges, weightsBps, epochWeek);\n  }\n\n  /**\n   * @notice Relative weight for gauge at time t (1e18 scaled)\n   */\n  function getRelativeWeight(bytes32 gauge, uint256 t) external view returns (uint256) {\n    uint256 epochWeek = (t / WEEK) * WEEK;\n    uint256 total = epochTotalWeight[epochWeek];\n    if (total == 0) return 0;\n    uint256 gw = gaugeWeight[gauge][epochWeek];\n    return (gw * 1e18) / total;\n  }\n}\n\n\n"
    },
    "contracts/core/governance/partners/DragonGaugeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Partner Integration Contracts\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IDragonGaugeRegistry} from \"../../../interfaces/governance/partners/IDragonGaugeRegistry.sol\";\n\n/**\n * @title DragonGaugeRegistry\n * @dev Registry for managing partners in the Dragon ecosystem\n */\ncontract DragonGaugeRegistry is Ownable, IDragonGaugeRegistry {\n  // Custom errors\n  error BoostTooHigh(uint256 provided, uint256 maximum);\n  error ZeroAddress();\n  error FeeShareTooHigh(uint256 provided, uint256 maximum);\n  error PartnerAlreadyExists(address partner);\n  error PartnerDoesNotExist(address partner);\n  error PartnerNotActive(address partner);\n  error PartnerAlreadyActive(address partner);\n  error FeeMRegistrationFailed();\n  error IndexOutOfBounds(uint256 index, uint256 length);\n  error RegistrationFailed();\n\n  // Partner extended internal struct (not exposed in interface)\n  struct PartnerExtended {\n    address addr; // Partner address\n    string name; // Partner name\n    uint256 feeShare; // Fee share in basis points\n    uint256 probabilityBoost; // Probability boost in basis points\n    bool active; // Partner active status\n  }\n\n  // Partners storage\n  address[] private _partnerList;\n  mapping(address => PartnerExtended) private _partners;\n  mapping(address => bool) public override isPartnerActive;\n\n  // Authorized distributors\n  mapping(address => bool) private _authorizedDistributors;\n\n  // Default probability boost\n  uint256 private _defaultProbabilityBoost = 100; // 1% by default\n\n  // Events\n  event PartnerAdded(address indexed partner, string name);\n  event PartnerActivated(address indexed partner);\n  event PartnerDeactivated(address indexed partner);\n  event PartnerRemoved(address indexed partner);\n  event DistributorAuthorized(address indexed distributor);\n  event DistributorUnauthorized(address indexed distributor);\n  event DefaultProbabilityBoostUpdated(uint256 newBoost);\n\n  constructor() Ownable(msg.sender) {\n    // Register for Sonic FeeM automatically\n  }\n\n  /**\n   * @dev Add a new partner\n   * @param partnerAddress Partner address\n   * @param name Partner name\n   * @param feeShare Fee share in basis points\n   * @param probabilityBoost Probability boost in basis points\n   */\n  function addPartner(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare,\n    uint256 probabilityBoost\n  ) external override onlyOwner {\n    if (partnerAddress == address(0)) revert ZeroAddress();\n    if (_partners[partnerAddress].addr != address(0)) revert PartnerAlreadyExists(partnerAddress);\n    if (feeShare > 5000) revert FeeShareTooHigh(feeShare, 5000); // Max 50%\n    if (probabilityBoost > 1000) revert BoostTooHigh(probabilityBoost, 1000); // Max 10%\n\n    // Create partner\n    _partners[partnerAddress] = PartnerExtended({\n      addr: partnerAddress,\n      name: name,\n      feeShare: feeShare,\n      probabilityBoost: probabilityBoost,\n      active: true\n    });\n\n    // Add to list\n    _partnerList.push(partnerAddress);\n\n    // Set active\n    isPartnerActive[partnerAddress] = true;\n\n    // Emit event\n    emit PartnerAdded(partnerAddress, name);\n    emit PartnerActivated(partnerAddress);\n  }\n\n  /**\n   * @dev Add a new partner with default probability boost\n   * @param partnerAddress Partner address\n   * @param name Partner name\n   * @param feeShare Fee share in basis points\n   */\n  function addPartnerWithDefaultBoost(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare\n  ) external override onlyOwner {\n    this.addPartner(partnerAddress, name, feeShare, _defaultProbabilityBoost);\n  }\n\n  /**\n   * @dev Update an existing partner\n   * @param partnerAddress Partner address\n   * @param name New name\n   * @param feeShare New fee share\n   * @param probabilityBoost New probability boost\n   */\n  function updatePartner(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare,\n    uint256 probabilityBoost\n  ) external override onlyOwner {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n    if (feeShare > 5000) revert FeeShareTooHigh(feeShare, 5000); // Max 50%\n    if (probabilityBoost > 1000) revert BoostTooHigh(probabilityBoost, 1000); // Max 10%\n\n    // Update partner\n    _partners[partnerAddress].name = name;\n    _partners[partnerAddress].feeShare = feeShare;\n    _partners[partnerAddress].probabilityBoost = probabilityBoost;\n  }\n\n  /**\n   * @dev Update an existing partner with default probability boost\n   * @param partnerAddress Partner address\n   * @param name New name\n   * @param feeShare New fee share\n   */\n  function updatePartnerWithDefaultBoost(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare\n  ) external override onlyOwner {\n    this.updatePartner(partnerAddress, name, feeShare, _defaultProbabilityBoost);\n  }\n\n  /**\n   * @dev Activate a partner\n   * @param partnerAddress Partner address\n   */\n  function activatePartner(address partnerAddress) external onlyOwner {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n    if (isPartnerActive[partnerAddress]) revert PartnerAlreadyActive(partnerAddress);\n\n    // Set active\n    _partners[partnerAddress].active = true;\n    isPartnerActive[partnerAddress] = true;\n\n    // Emit event\n    emit PartnerActivated(partnerAddress);\n  }\n\n  /**\n   * @dev Deactivate a partner\n   * @param partnerAddress Partner address\n   */\n  function deactivatePartner(address partnerAddress) external override onlyOwner {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n    if (!isPartnerActive[partnerAddress]) revert PartnerNotActive(partnerAddress);\n\n    // Set inactive\n    _partners[partnerAddress].active = false;\n    isPartnerActive[partnerAddress] = false;\n\n    // Emit event\n    emit PartnerDeactivated(partnerAddress);\n  }\n\n  /**\n   * @dev Set distributor authorization\n   * @param distributor Distributor address\n   * @param authorized Authorization status\n   */\n  function setDistributorAuthorization(address distributor, bool authorized) external override onlyOwner {\n    if (distributor == address(0)) revert ZeroAddress();\n\n    _authorizedDistributors[distributor] = authorized;\n\n    if (authorized) {\n      emit DistributorAuthorized(distributor);\n    } else {\n      emit DistributorUnauthorized(distributor);\n    }\n  }\n\n  /**\n   * @dev Set default probability boost\n   * @param boost Default probability boost\n   */\n  function setDefaultProbabilityBoost(uint256 boost) external override onlyOwner {\n    if (boost > 1000) revert BoostTooHigh(boost, 1000); // Max 10%\n\n    _defaultProbabilityBoost = boost;\n    emit DefaultProbabilityBoostUpdated(boost);\n  }\n\n  /**\n   * @dev Get partner at index - implements IDragonGaugeRegistry\n   * @param index Index\n   * @return Partner address\n   */\n  function partnerList(uint256 index) external view override returns (address) {\n    if (index >= _partnerList.length) revert IndexOutOfBounds(index, _partnerList.length);\n    return _partnerList[index];\n  }\n\n  /**\n   * @dev Get partner count - implements IDragonGaugeRegistry\n   * @return Partner count\n   */\n  function getPartnerCount() external view override returns (uint256) {\n    return _partnerList.length;\n  }\n\n  /**\n   * @dev Get partner details - implements IDragonGaugeRegistry\n   * @param partnerAddress Partner address\n   * @return name Partner name\n   * @return feeShare Fee share in basis points\n   * @return probabilityBoost Probability boost in basis points\n   * @return isActive Partner active status\n   */\n  function getPartnerDetails(\n    address partnerAddress\n  ) external view override returns (string memory name, uint256 feeShare, uint256 probabilityBoost, bool isActive) {\n    if (_partners[partnerAddress].addr == address(0)) revert PartnerDoesNotExist(partnerAddress);\n\n    PartnerExtended memory partner = _partners[partnerAddress];\n    return (partner.name, partner.feeShare, partner.probabilityBoost, partner.active);\n  }\n\n  /**\n   * @dev Get partner data - implements IDragonGaugeRegistry\n   */\n  function partners(\n    address partnerAddress\n  ) external view override returns (string memory name, uint256 feeShare, uint256 probabilityBoost, bool isActive) {\n    PartnerExtended memory partner = _partners[partnerAddress];\n    return (partner.name, partner.feeShare, partner.probabilityBoost, partner.active);\n  }\n\n  /**\n   * @dev Check if distributor is authorized\n   */\n  function authorizedDistributors(address distributor) external view override returns (bool) {\n    return _authorizedDistributors[distributor];\n  }\n\n  /**\n   * @dev Check if distributor is authorized\n   */\n  function isDistributorAuthorized(address distributor) external view override returns (bool) {\n    return _authorizedDistributors[distributor];\n  }\n\n  /**\n   * @dev Get default probability boost\n   */\n  function defaultProbabilityBoost() external view override returns (uint256) {\n    return _defaultProbabilityBoost;\n  }\n\n  /**\n   * @dev Check if partner is whitelisted (alias for isPartnerActive)\n   * @param partner Partner address\n   * @return Whether partner is whitelisted\n   */\n  function isWhitelistedPartner(address partner) external view override returns (bool) {\n    return isPartnerActive[partner];\n  }\n\n  /**\n   * @dev Get partner boost (returns probability boost)\n   * @param partner Partner address\n   * @return Probability boost in basis points\n   */\n  function getPartnerBoost(address partner) external view override returns (uint256) {\n    if (_partners[partner].addr == address(0)) revert PartnerDoesNotExist(partner);\n    return _partners[partner].probabilityBoost;\n  }\n\n  /**\n   * @dev Register a partner (alias for addPartner with default fee share)\n   * @param partner Partner address\n   * @param boost Probability boost in basis points\n   */\n  function registerPartner(address partner, uint256 boost) external override onlyOwner {\n    this.addPartner(partner, \"Partner\", 0, boost); // 0 fee share by default\n  }\n\n  /**\n   * @dev Remove a partner from the registry\n   * @param partner Partner address\n   */\n  function removePartner(address partner) external override onlyOwner {\n    if (_partners[partner].addr == address(0)) revert PartnerDoesNotExist(partner);\n\n    // Find and remove from list\n    for (uint256 i = 0; i < _partnerList.length; i++) {\n      if (_partnerList[i] == partner) {\n        _partnerList[i] = _partnerList[_partnerList.length - 1];\n        _partnerList.pop();\n        break;\n      }\n    }\n\n    // Delete partner data\n    delete _partners[partner];\n    delete isPartnerActive[partner];\n\n    emit PartnerRemoved(partner);\n  }\n\n  /**\n   * @notice Check if this contract is registered for Sonic FeeM\n   * @return isRegistered Whether the contract is registered for fee monetization\n   */\n  function checkFeeMStatus() external view returns (bool isRegistered) {}\n}\n\n\n"
    },
    "contracts/core/governance/partners/PartnerBribeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title PartnerBribeDistributor\n * @dev Lightweight bribe distributor that pays veDRAGON voters of a partner for a given period,\n *      proportional to votes recorded by veDRAGONBoostManager. No staking pools required.\n */\n\n// Minimal interface to read voting data from veDRAGONBoostManager\ninterface IBoostVotes {\n  function currentPeriod() external view returns (uint256);\n  function votingPeriodLength() external view returns (uint64);\n  function userVotes(uint256 period, address user, uint256 partnerId) external view returns (uint256);\n  function partnerVotes(uint256 period, uint256 partnerId) external view returns (uint256);\n}\n\ncontract PartnerBribeDistributor is Ownable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // Constants\n  uint256 public constant FEE_PRECISION = 10000; // 10000 = 100%\n\n  // Core refs\n  address public immutable boostManager; // veDRAGONBoostManager\n  address public treasury; // optional protocol fee receiver\n\n  // Fees\n  uint256 public protocolFeeBps; // e.g. 300 = 3%\n\n  // period => partnerId => token => total bribe amount\n  mapping(uint256 => mapping(uint256 => mapping(address => uint256))) public periodPartnerTokenBribe;\n\n  // period => partnerId => token => user => claimed amount\n  mapping(uint256 => mapping(uint256 => mapping(address => mapping(address => uint256)))) public userClaimed;\n\n  // Events\n  event BribeDeposited(uint256 indexed period, uint256 indexed partnerId, address indexed token, uint256 amount, address from);\n  event Claimed(uint256 indexed period, uint256 indexed partnerId, address indexed token, address user, uint256 amount);\n  event ProtocolFeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);\n  event TreasuryUpdated(address oldTreasury, address newTreasury);\n\n  constructor(address _boostManager, address _treasury, uint256 _protocolFeeBps) Ownable(msg.sender) {\n    require(_boostManager != address(0), \"Zero boostManager\");\n    boostManager = _boostManager;\n    treasury = _treasury; // can be zero initially\n    require(_protocolFeeBps <= 3000, \"Fee too high\");\n    protocolFeeBps = _protocolFeeBps;\n  }\n\n  // ============ Admin ============\n\n  function setProtocolFeeBps(uint256 _bps) external onlyOwner {\n    require(_bps <= 3000, \"Fee too high\");\n    uint256 old = protocolFeeBps;\n    protocolFeeBps = _bps;\n    emit ProtocolFeeUpdated(old, _bps);\n  }\n\n  function setTreasury(address _treasury) external onlyOwner {\n    address old = treasury;\n    treasury = _treasury;\n    emit TreasuryUpdated(old, _treasury);\n  }\n\n  // ============ Bribe Deposit ============\n\n  /**\n   * @notice Deposit bribe tokens for a partner and period.\n   * @param partnerId Partner identifier (index from registry)\n   * @param token ERC20 token address to bribe with\n   * @param amount Amount to deposit\n   * @param forNextPeriod If true, bribe is applied to next period; otherwise current period\n   */\n  function depositBribe(\n    uint256 partnerId,\n    address token,\n    uint256 amount,\n    bool forNextPeriod\n  ) external nonReentrant {\n    require(token != address(0), \"Zero token\");\n    require(amount > 0, \"Zero amount\");\n\n    // Determine target period\n    uint256 period = IBoostVotes(boostManager).currentPeriod();\n    if (forNextPeriod) period += 1;\n\n    // Pull tokens in\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n    // Take optional protocol fee\n    uint256 fee = (amount * protocolFeeBps) / FEE_PRECISION;\n    uint256 netAmount = amount - fee;\n    if (fee > 0 && treasury != address(0)) {\n      IERC20(token).safeTransfer(treasury, fee);\n    }\n\n    // Record net bribe for this period/partner/token\n    periodPartnerTokenBribe[period][partnerId][token] += netAmount;\n\n    emit BribeDeposited(period, partnerId, token, netAmount, msg.sender);\n  }\n\n  // ============ Claiming ============\n\n  function getUserClaimable(\n    uint256 period,\n    uint256 partnerId,\n    address token,\n    address user\n  ) public view returns (uint256) {\n    // Ensure period has ended: block time >= (period + 1) * votingPeriodLength\n    uint64 len = IBoostVotes(boostManager).votingPeriodLength();\n    // If len == 0 (should not happen), treat as ended to avoid locking funds\n    if (len > 0) {\n      require(block.timestamp >= (period + 1) * uint256(len), \"Period not ended\");\n    }\n\n    uint256 totalBribe = periodPartnerTokenBribe[period][partnerId][token];\n    if (totalBribe == 0) return 0;\n\n    uint256 totalVotes = IBoostVotes(boostManager).partnerVotes(period, partnerId);\n    if (totalVotes == 0) return 0;\n\n    uint256 votes = IBoostVotes(boostManager).userVotes(period, user, partnerId);\n    if (votes == 0) return 0;\n\n    uint256 entitled = (totalBribe * votes) / totalVotes;\n    uint256 already = userClaimed[period][partnerId][token][user];\n    if (entitled <= already) return 0;\n    return entitled - already;\n  }\n\n  function claim(\n    uint256 period,\n    uint256 partnerId,\n    address token\n  ) external nonReentrant {\n    uint256 claimable = getUserClaimable(period, partnerId, token, msg.sender);\n    require(claimable > 0, \"Nothing to claim\");\n\n    userClaimed[period][partnerId][token][msg.sender] += claimable;\n    IERC20(token).safeTransfer(msg.sender, claimable);\n\n    emit Claimed(period, partnerId, token, msg.sender, claimable);\n  }\n\n  function claimMany(\n    uint256[] calldata periods,\n    uint256[] calldata partnerIds,\n    address[] calldata tokens\n  ) external nonReentrant {\n    require(periods.length == partnerIds.length && periods.length == tokens.length, \"Length mismatch\");\n    uint256 total;\n    for (uint256 i = 0; i < periods.length; i++) {\n      uint256 claimable = getUserClaimable(periods[i], partnerIds[i], tokens[i], msg.sender);\n      if (claimable > 0) {\n        userClaimed[periods[i]][partnerIds[i]][tokens[i]][msg.sender] += claimable;\n        IERC20(tokens[i]).safeTransfer(msg.sender, claimable);\n        total += claimable;\n        emit Claimed(periods[i], partnerIds[i], tokens[i], msg.sender, claimable);\n      }\n    }\n    // total is unused, but kept for potential future event/return\n    total;\n  }\n}\n\n\n"
    },
    "contracts/core/governance/voting/veDRAGONBoostManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IveDRAGON} from \"../../../interfaces/tokens/IveDRAGON.sol\";\nimport {IDragonJackpotVault} from \"../../../interfaces/lottery/IDragonJackpotVault.sol\";\nimport {IveDRAGONBoostManager} from \"../../../interfaces/governance/voting/IveDRAGONBoostManager.sol\";\nimport {IDragonGaugeRegistry} from \"../../../interfaces/governance/partners/IDragonGaugeRegistry.sol\";\nimport {DragonDateTimeLib} from \"../../../libraries/core/DragonDateTimeLib.sol\";\nimport {veDRAGONMath} from \"../../../libraries/math/veDRAGONMath.sol\";\n\n/**\n * @title veDRAGONBoostManager\n * @dev Unified contract for veDRAGON boost and voting functionality for partner systems\n *\n * Combines boost calculation for jackpot entries and partner pool voting mechanisms\n * Provides voting power-based probability boosts and democratic partner selection\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract veDRAGONBoostManager is Ownable, ReentrancyGuard, IveDRAGONBoostManager {\n  // === Custom Errors ===\n  error ZeroAddress();\n  error ZeroAmount();\n  error BaseBoostMustBePositive();\n  error MaxBoostMustBeGreaterThanBase();\n  error UnauthorizedCaller();\n  error PartnerDoesNotExist();\n  error PartnerNotActive();\n  error InsufficientVotingPower();\n  error NoVotesForOldPartner();\n  error TooSoonToRecalculate();\n  error PeriodTooShort();\n  error FeeMRegistrationFailed();\n  error InvalidMultiplier();\n\n  // Core contract references\n  IveDRAGON public immutable veDRAGON;\n  IDragonJackpotVault public jackpot;\n  IDragonGaugeRegistry public partnerRegistry;\n\n  // ===== BOOST PARAMETERS =====\n  /// @dev Precision for boost calculations (10000 = 100%)\n  uint256 public constant BOOST_PRECISION = 10000;\n\n  /// @dev Base boost value (10000 = 100%)\n  uint256 public baseBoost = 10000;\n\n  /// @dev Maximum boost value (25000 = 250%)\n  uint256 public maxBoost = 25000;\n\n  // Optional parameters for refined boost calculation (packed into single storage slot)\n  uint64 public minLockDuration = 7 days; // Minimum lock duration for boost\n  uint64 public maxLockDuration = 4 * 365 days; // Maximum lock duration (4 years)\n\n  // ===== VOTING PARAMETERS =====\n  /// @dev Voting period length in seconds\n  uint64 public votingPeriodLength = 7 days;\n\n  /// @dev Current voting period\n  uint64 private _currentPeriod;\n\n  /// @dev Maximum total probability boost (6.9% expressed in basis points)\n  uint256 public constant MAX_TOTAL_BOOST = 690;\n\n  /// @dev Minimum voting power to participate\n  uint256 public minVotingPower = 0.1 ether; // 0.1 veDRAGON\n\n  // Track votes for each partner in each period\n  // period => partnerId => votes\n  mapping(uint256 => mapping(uint256 => uint256)) public partnerVotes;\n\n  // Track total votes in each period\n  // period => totalVotes\n  mapping(uint256 => uint256) public periodTotalVotes;\n\n  // Track if a user has voted in current period\n  // period => user => hasVoted\n  mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n  // Track votes by user\n  // period => user => partnerId => votes\n  mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public userVotes;\n\n  // Track allocated probability boost\n  // partnerId => probabilityBoost (in basis points)\n  mapping(uint256 => uint256) public partnerProbabilityBoost;\n\n  // Last calculation timestamp\n  uint64 public lastCalculation;\n\n  // Flash loan protection\n  mapping(address => uint256) public lastBalanceUpdateBlock;\n  uint256 public constant MIN_HOLDING_BLOCKS = 10; // ~2 minutes on most chains\n\n  // Timelock for critical parameters\n  bool public boostTimelockInitialized;\n  uint256 public constant BOOST_TIMELOCK_DELAY = 24 hours; // 24 hour delay for boost changes\n\n  struct BoostTimelockProposal {\n    uint256 newBaseBoost;\n    uint256 newMaxBoost;\n    uint256 executeTime;\n    bool executed;\n    bool exists;\n  }\n\n  mapping(bytes32 => BoostTimelockProposal) public boostTimelockProposals;\n  bool public boostParametersSetOnce;\n\n  // ===== EVENTS =====\n  // Boost Events (BoostCalculated is inherited from interface)\n  event BoostParametersUpdated(uint256 baseBoost, uint256 maxBoost);\n  event JackpotAddressUpdated(address indexed newJackpot);\n  event JackpotEntryWithBoost(address indexed user, uint256 amount, uint256 boostedAmount);\n\n  // Voting Events\n  event VoteCast(address indexed user, uint256 indexed partnerId, uint256 votes, uint256 period);\n  event VoteChanged(\n    address indexed user,\n    uint256 indexed oldPartnerId,\n    uint256 indexed newPartnerId,\n    uint256 votes,\n    uint256 period\n  );\n  event VoteRemoved(address indexed user, uint256 indexed partnerId, uint256 votes, uint256 period);\n  event PartnersBoostCalculated(uint256 period, uint256 totalVotes);\n  event PartnerBoostUpdated(uint256 indexed partnerId, uint256 probabilityBoost);\n  event VotingPeriodChanged(uint256 newPeriodLength);\n  event MinVotingPowerChanged(uint256 newMinVotingPower);\n  event PartnerRegistryUpdated(address indexed newRegistry);\n\n  event BoostProposalCreated(\n    bytes32 indexed proposalId,\n    uint256 newBaseBoost,\n    uint256 newMaxBoost,\n    uint256 executeTime\n  );\n  event BoostProposalExecuted(bytes32 indexed proposalId);\n  event BoostTimelockInitialized();\n\n  /**\n   * @dev Constructor\n   * @param _veDRAGON Address of the veDRAGON token\n   * @param _jackpot Address of the jackpot contract\n   * @param _partnerRegistry Address of the partner registry\n   */\n  constructor(address _veDRAGON, address _jackpot, address _partnerRegistry) Ownable(msg.sender) {\n    if (_veDRAGON == address(0)) revert ZeroAddress();\n    if (_jackpot == address(0)) revert ZeroAddress();\n    if (_partnerRegistry == address(0)) revert ZeroAddress();\n\n    veDRAGON = IveDRAGON(_veDRAGON);\n    jackpot = IDragonJackpotVault(_jackpot);\n    partnerRegistry = IDragonGaugeRegistry(_partnerRegistry);\n\n    // Initialize period and calculation timestamp\n    _currentPeriod = uint64(block.timestamp / votingPeriodLength);\n    lastCalculation = uint64(block.timestamp);\n  }\n\n  /**\n   * @dev Get the current voting period\n   * @return Current period ID\n   */\n  function currentPeriod() external view returns (uint256) {\n    return _currentPeriod;\n  }\n\n  // ============================================================\n  // ==================== BOOST FUNCTIONS =======================\n  // ============================================================\n\n  /**\n   * @dev Calculate boost multiplier based on user's veDRAGON balance with linear scaling\n   * @param _user Address of the user\n   * @return boostMultiplier Boost multiplier in BOOST_PRECISION (10000 = 100%)\n   */\n  function calculateBoost(address _user) public view returns (uint256 boostMultiplier) {\n    // Use secure calculation with flash loan protection\n    return calculateBoostWithProtection(_user);\n  }\n\n  /**\n   * @dev Calculate boost with flash loan protection\n   */\n  function calculateBoostWithProtection(address _user) public view returns (uint256 boostMultiplier) {\n    // Check if user has held tokens for minimum duration\n    if (block.number < lastBalanceUpdateBlock[_user] + MIN_HOLDING_BLOCKS) {\n      return baseBoost; // Only base boost for recent holders\n    }\n\n    // Get user's time-weighted veDRAGON voting power\n    uint256 userVeDRAGONBalance = veDRAGON.getVotingPower(_user);\n    uint256 totalVeDRAGONSupply = veDRAGON.getTotalVotingPower();\n\n    // Use the veDRAGONMath library for boost calculation\n    uint256 standardBoost = veDRAGONMath.calculateNormalizedBoostMultiplier(\n      userVeDRAGONBalance,\n      totalVeDRAGONSupply,\n      maxBoost\n    );\n\n    // Check if today is a special event day for additional boost\n    (bool isSpecialEvent, uint256 eventMultiplier) = DragonDateTimeLib.checkForSpecialEvent(block.timestamp);\n\n    if (isSpecialEvent) {\n      return (standardBoost * eventMultiplier) / 10000;\n    }\n\n    return standardBoost;\n  }\n\n  /**\n   * @dev Calculate boost and emit event (non-view version)\n   * @param _user Address of the user\n   * @return boostMultiplier Boost multiplier\n   */\n  function getBoostWithEvent(address _user) public override returns (uint256 boostMultiplier) {\n    boostMultiplier = calculateBoost(_user);\n    emit BoostCalculated(_user, boostMultiplier);\n    return boostMultiplier;\n  }\n\n  /**\n   * @dev Enter jackpot with a boosted amount based on veDRAGON holdings\n   * @param _user Address of the user entering the jackpot\n   * @param _amount Base amount for jackpot entry\n   * @return boostedAmount The amount after applying the boost\n   */\n  function enterJackpotWithBoost(address _user, uint256 _amount) external override returns (uint256 boostedAmount) {\n    // Only authorized integrators can call this function\n    if (msg.sender != owner() && msg.sender != address(jackpot)) revert UnauthorizedCaller();\n\n    // Calculate boost\n    uint256 boostMultiplier = calculateBoost(_user);\n\n    // Apply boost to amount\n    boostedAmount = (_amount * boostMultiplier) / BOOST_PRECISION;\n\n    // Enter jackpot with boosted amount\n    jackpot.enterJackpotWithWrappedNativeToken(_user, boostedAmount);\n\n    // Emit events\n    emit BoostCalculated(_user, boostMultiplier);\n    emit JackpotEntryWithBoost(_user, _amount, boostedAmount);\n\n    return boostedAmount;\n  }\n\n  /**\n   * @dev Update boost parameters (with timelock protection after first use)\n   * @param _baseBoost New base boost (10000 = 100%)\n   * @param _maxBoost New max boost (25000 = 250%)\n   */\n  function setBoostParameters(uint256 _baseBoost, uint256 _maxBoost) external onlyOwner {\n    if (_baseBoost == 0) revert BaseBoostMustBePositive();\n    if (_maxBoost <= _baseBoost) revert MaxBoostMustBeGreaterThanBase();\n\n    // First time can be set immediately\n    if (!boostParametersSetOnce) {\n      boostParametersSetOnce = true;\n      boostTimelockInitialized = true;\n\n      baseBoost = _baseBoost;\n      maxBoost = _maxBoost;\n\n      emit BoostParametersUpdated(_baseBoost, _maxBoost);\n      emit BoostTimelockInitialized();\n      return;\n    }\n\n    // Subsequent changes require timelock\n    revert(\"Use proposeBoostParameterChange\");\n  }\n\n  /**\n   * @dev Propose boost parameter changes (required after first use)\n   */\n  function proposeBoostParameterChange(\n    uint256 _baseBoost,\n    uint256 _maxBoost\n  ) external onlyOwner returns (bytes32 proposalId) {\n    require(boostTimelockInitialized, \"Timelock not initialized\");\n    if (_baseBoost == 0) revert BaseBoostMustBePositive();\n    if (_maxBoost <= _baseBoost) revert MaxBoostMustBeGreaterThanBase();\n\n    proposalId = keccak256(abi.encode(_baseBoost, _maxBoost, block.timestamp));\n    require(!boostTimelockProposals[proposalId].exists, \"Proposal already exists\");\n\n    uint256 executeTime = block.timestamp + BOOST_TIMELOCK_DELAY;\n\n    boostTimelockProposals[proposalId] = BoostTimelockProposal({\n      newBaseBoost: _baseBoost,\n      newMaxBoost: _maxBoost,\n      executeTime: executeTime,\n      executed: false,\n      exists: true\n    });\n\n    emit BoostProposalCreated(proposalId, _baseBoost, _maxBoost, executeTime);\n    return proposalId;\n  }\n\n  /**\n   * @dev Execute boost parameter change after timelock\n   */\n  function executeBoostParameterChange(bytes32 proposalId) external onlyOwner {\n    BoostTimelockProposal storage proposal = boostTimelockProposals[proposalId];\n    require(proposal.exists, \"Proposal does not exist\");\n    require(!proposal.executed, \"Proposal already executed\");\n    require(block.timestamp >= proposal.executeTime, \"Timelock not expired\");\n\n    proposal.executed = true;\n\n    baseBoost = proposal.newBaseBoost;\n    maxBoost = proposal.newMaxBoost;\n\n    emit BoostParametersUpdated(proposal.newBaseBoost, proposal.newMaxBoost);\n    emit BoostProposalExecuted(proposalId);\n  }\n\n  /**\n   * @dev Update jackpot address\n   * @param _jackpot New jackpot address\n   */\n  function setJackpot(address _jackpot) external onlyOwner {\n    if (_jackpot == address(0)) revert ZeroAddress();\n    jackpot = IDragonJackpotVault(_jackpot);\n    emit JackpotAddressUpdated(_jackpot);\n  }\n\n  // ============================================================\n  // =================== VOTING FUNCTIONS =======================\n  // ============================================================\n\n  /**\n   * @dev Vote for a partner to receive probability boost\n   * @param _partnerId ID of the partner to vote for\n   * @param _weight Voting weight to allocate (not used, for interface compatibility)\n   */\n  function voteForPartner(uint256 _partnerId, uint256 _weight) external override {\n    // _weight parameter is not used in this implementation but is included for interface compatibility\n    _weight; // Silence unused variable warning\n\n    // Get partner address from ID\n    address partnerAddress = partnerRegistry.partnerList(_partnerId);\n\n    // Verify partner exists and is active\n    bool isActive = partnerRegistry.isPartnerActive(partnerAddress);\n    if (partnerAddress == address(0)) revert PartnerDoesNotExist();\n    if (!isActive) revert PartnerNotActive();\n\n    // Check if we need to move to a new period\n    updatePeriodIfNeeded();\n\n    // Get user's voting power\n    uint256 votingPower = veDRAGON.getVotingPower(msg.sender);\n    if (votingPower < minVotingPower) revert InsufficientVotingPower();\n\n    // If user has already voted in this period, remove their previous vote\n    if (hasVoted[_currentPeriod][msg.sender]) {\n      removeVote(msg.sender);\n    }\n\n    // Record the new vote\n    partnerVotes[_currentPeriod][_partnerId] += votingPower;\n    periodTotalVotes[_currentPeriod] += votingPower;\n    hasVoted[_currentPeriod][msg.sender] = true;\n    userVotes[_currentPeriod][msg.sender][_partnerId] = votingPower;\n\n    emit VoteCast(msg.sender, _partnerId, votingPower, _currentPeriod);\n  }\n\n  /**\n   * @dev Change vote from one partner to another\n   * @param _oldPartnerId Current partner ID the user is voting for\n   * @param _newPartnerId New partner ID to vote for\n   */\n  function changeVote(uint256 _oldPartnerId, uint256 _newPartnerId) external {\n    // Get partner address from ID\n    address newPartnerAddress = partnerRegistry.partnerList(_newPartnerId);\n\n    // Verify new partner exists and is active\n    bool isActive = partnerRegistry.isPartnerActive(newPartnerAddress);\n    if (newPartnerAddress == address(0)) revert PartnerDoesNotExist();\n    if (!isActive) revert PartnerNotActive();\n\n    // Check if we need to move to a new period\n    updatePeriodIfNeeded();\n\n    // Check if user has voted for the old partner\n    uint256 oldVotes = userVotes[_currentPeriod][msg.sender][_oldPartnerId];\n    if (oldVotes == 0) revert NoVotesForOldPartner();\n\n    // Remove old vote\n    partnerVotes[_currentPeriod][_oldPartnerId] -= oldVotes;\n    userVotes[_currentPeriod][msg.sender][_oldPartnerId] = 0;\n\n    // Add new vote\n    partnerVotes[_currentPeriod][_newPartnerId] += oldVotes;\n    userVotes[_currentPeriod][msg.sender][_newPartnerId] = oldVotes;\n\n    emit VoteChanged(msg.sender, _oldPartnerId, _newPartnerId, oldVotes, _currentPeriod);\n  }\n\n  /**\n   * @dev Remove a user's vote\n   * @param user Address of the user\n   */\n  function removeVote(address user) internal {\n    // Find all partners the user voted for\n    for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n      uint256 userVoteAmount = userVotes[_currentPeriod][user][i];\n      if (userVoteAmount > 0) {\n        // Remove votes\n        partnerVotes[_currentPeriod][i] -= userVoteAmount;\n        periodTotalVotes[_currentPeriod] -= userVoteAmount;\n        userVotes[_currentPeriod][user][i] = 0;\n\n        emit VoteRemoved(user, i, userVoteAmount, _currentPeriod);\n      }\n    }\n\n    // Mark user as not having voted\n    hasVoted[_currentPeriod][user] = false;\n  }\n\n  /**\n   * @dev Calculate probability boosts based on votes\n   * Can be called by anyone, but has a time restriction\n   */\n  function calculatePartnersBoost() external {\n    // Check if 24 hours have passed since last calculation\n    if (block.timestamp < lastCalculation + 1 days) revert TooSoonToRecalculate();\n\n    // Update period if needed\n    updatePeriodIfNeeded();\n\n    // Get total votes in the current period\n    uint256 totalVotes = periodTotalVotes[_currentPeriod];\n\n    // If no votes, reset all boosts\n    if (totalVotes == 0) {\n      for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n        if (partnerProbabilityBoost[i] > 0) {\n          partnerProbabilityBoost[i] = 0;\n          emit PartnerBoostUpdated(i, 0);\n        }\n      }\n    } else {\n      // Calculate boost for each partner\n      for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n        uint256 votes = partnerVotes[_currentPeriod][i];\n\n        // Calculate partner's share of the boost\n        uint256 boost = (votes * MAX_TOTAL_BOOST) / totalVotes;\n\n        // Update partner's probability boost if changed\n        if (boost != partnerProbabilityBoost[i]) {\n          partnerProbabilityBoost[i] = boost;\n          emit PartnerBoostUpdated(i, boost);\n        }\n      }\n    }\n\n    // Update last calculation timestamp\n    lastCalculation = uint64(block.timestamp);\n\n    emit PartnersBoostCalculated(_currentPeriod, totalVotes);\n  }\n\n  /**\n   * @dev Get probability boost for a partner\n   * @param _partnerId ID of the partner\n   * @return Probability boost in basis points (e.g., 100 = 1%)\n   */\n  function getPartnerProbabilityBoost(uint256 _partnerId) external view override returns (uint256) {\n    return partnerProbabilityBoost[_partnerId];\n  }\n\n  /**\n   * @dev Get probability boost for a partner address\n   * @param _partner Address of the partner\n   * @return Probability boost in basis points (e.g., 100 = 1%)\n   */\n  function getPartnerProbabilityBoostByAddress(address _partner) external view returns (uint256) {\n    // Iterate through partner list to find matching address\n    for (uint256 i = 0; i < partnerRegistry.getPartnerCount(); i++) {\n      if (partnerRegistry.partnerList(i) == _partner) {\n        return partnerProbabilityBoost[i];\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * @dev Update current period if needed\n   */\n  function updatePeriodIfNeeded() internal {\n    uint64 calculatedPeriod = uint64(block.timestamp / votingPeriodLength);\n    if (calculatedPeriod > _currentPeriod) {\n      _currentPeriod = calculatedPeriod;\n    }\n  }\n\n  /**\n   * @dev Set minimum voting power required to participate\n   * @param _minVotingPower New minimum voting power\n   */\n  function setMinVotingPower(uint256 _minVotingPower) external onlyOwner {\n    minVotingPower = _minVotingPower;\n    emit MinVotingPowerChanged(_minVotingPower);\n  }\n\n  /**\n   * @dev Set voting period length\n   * @param _votingPeriodLength New voting period length in seconds\n   */\n  function setVotingPeriodLength(uint256 _votingPeriodLength) external onlyOwner {\n    if (_votingPeriodLength < 1 days) revert PeriodTooShort();\n    votingPeriodLength = uint64(_votingPeriodLength);\n    emit VotingPeriodChanged(_votingPeriodLength);\n  }\n\n  /**\n   * @dev Update partner registry address\n   * @param _partnerRegistry New partner registry address\n   */\n  function setPartnerRegistry(address _partnerRegistry) external onlyOwner {\n    if (_partnerRegistry == address(0)) revert ZeroAddress();\n    partnerRegistry = IDragonGaugeRegistry(_partnerRegistry);\n    emit PartnerRegistryUpdated(_partnerRegistry);\n  }\n\n  /**\n   * @dev Update balance tracking (should be called on veDRAGON transfers)\n   */\n  function updateBalanceTracking(address user) external {\n    require(msg.sender == address(veDRAGON), \"Only veDRAGON can update\");\n    lastBalanceUpdateBlock[user] = block.number;\n  }\n\n  /**\n   * @dev Check if a special event is active\n   * @return Whether a special event is currently active\n   */\n  function isSpecialEventActive() external view returns (bool) {\n    (bool isActive, ) = DragonDateTimeLib.checkForSpecialEvent(block.timestamp);\n    return isActive;\n  }\n\n  /**\n   * @dev Get normalized boost multiplier for a user\n   * @param user User address\n   * @return Normalized boost multiplier\n   */\n  function getNormalizedBoostMultiplier(address user) external view returns (uint256) {\n    return calculateBoost(user);\n  }\n\n  /**\n   * @notice Registers the contract with Sonic FeeM system\n   * @dev Only callable by owner. Makes external call to FeeM contract.\n   */\n  function registerMe() external onlyOwner {\n    (bool _success, ) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n      abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n}"
    },
    "contracts/core/governance/voting/veDRAGONRevenueDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {IveDRAGON} from \"../../../interfaces/tokens/IveDRAGON.sol\";\nimport {IveDRAGONRevenueDistributor} from \"../../../interfaces/governance/voting/IveDRAGONRevenueDistributor.sol\";\n\n/**\n * @title veDRAGONRevenueDistributor\n * @dev Revenue distributor for veDRAGON holders based on their voting power\n * Implements epoch-based distribution system for fair fee sharing\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract veDRAGONRevenueDistributor is Ownable, ReentrancyGuard, IveDRAGONRevenueDistributor {\n  using SafeERC20 for IERC20;\n\n  // Custom errors\n  error ZeroAddress();\n  error InsufficientFees();\n  error NothingToClaim();\n  error InvalidEpoch();\n\n  // State variables\n  IveDRAGON public immutable veDRAGON;\n  IERC20 public rewardToken; // DRAGON token for rewards\n  address public jackpotVault; // Jackpot vault for FeeM revenue\n\n  // Epoch tracking\n  uint256 public currentEpoch;\n  uint256 public epochDuration = 7 days;\n  mapping(uint256 => uint256) public epochStartTime;\n  mapping(uint256 => uint256) public epochEndTime;\n\n  // Fee tracking per epoch and token\n  mapping(uint256 => mapping(address => uint256)) public epochFees; // epoch => token => amount\n  mapping(uint256 => uint256) public epochTotalSupply; // epoch => total veDRAGON supply snapshot\n\n  // User claim tracking\n  mapping(address => mapping(uint256 => mapping(address => bool))) public hasClaimed; // user => epoch => token => claimed\n  mapping(address => mapping(address => uint256)) public totalClaimed; // user => token => total claimed\n\n  // Partner fee tracking (for interface compliance)\n  mapping(uint256 => mapping(address => uint256)) public partnerFees; // partnerId => token => amount\n\n  // Wrapped native token address (WETH, WSONIC, etc.)\n  address public wrappedNativeToken;\n\n  // Accumulated rewards tracking\n  uint256 private _accumulatedRewards;\n\n  // Events\n  event FeesReceived(uint256 indexed epoch, address indexed token, uint256 amount);\n  event FeesClaimed(address indexed user, uint256 indexed epoch, address indexed token, uint256 amount);\n  event WrappedTokenSet(address indexed oldToken, address indexed newToken);\n  event EpochRolled(uint256 indexed newEpoch, uint256 startTime, uint256 endTime);\n  event FeesDeposited(uint256 indexed partnerId, address indexed token, uint256 amount, address indexed depositor);\n  event RewardsClaimed(address indexed user, uint256 amount);\n  event RewardsReceived(uint256 amount);\n  event RewardsDistributed(uint256 amount);\n  event RewardTokenUpdated(address indexed oldToken, address indexed newToken);\n  event VeDRAGONAddressUpdated(address indexed oldAddress, address indexed newAddress);\n  // FeeM events are handled by DragonFeeMHelper contract\n\n  constructor(address _veDRAGON) Ownable(msg.sender) {\n    if (_veDRAGON == address(0)) revert ZeroAddress();\n\n    veDRAGON = IveDRAGON(_veDRAGON);\n\n    // Initialize first epoch\n    currentEpoch = 1;\n    epochStartTime[1] = block.timestamp;\n    epochEndTime[1] = block.timestamp + epochDuration;\n\n    // FeeM functionality is handled by DragonFeeMHelper contract\n  }\n\n  // ======== Fee Distribution Functions ========\n\n  /**\n   * @dev Distribute general fees not associated with a specific partner\n   * @param token Token address (address(0) for native token)\n   * @param amount Amount of fees to distribute\n   */\n  function distributeGeneralFees(address token, uint256 amount) external nonReentrant {\n    require(amount > 0, \"Amount must be positive\");\n\n    rollEpoch(); // Ensure we're in the correct epoch\n\n    if (token == address(0)) {\n      // Native token - should already be in contract via receive() or direct transfer\n      require(address(this).balance >= amount, \"Insufficient native balance\");\n    } else {\n      // ERC20 token - transfer from sender\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    epochFees[currentEpoch][token] += amount;\n    emit FeesReceived(currentEpoch, token, amount);\n  }\n\n  /**\n   * @dev Deposit fees for a specific partner (tracked separately)\n   * @param partnerId ID of the partner\n   * @param token Token address (address(0) for native token)\n   * @param amount Amount of fees\n   */\n  function depositFees(uint256 partnerId, address token, uint256 amount) external nonReentrant {\n    require(token != address(0), \"Invalid token\");\n    require(amount > 0, \"Amount must be positive\");\n\n    // Transfer tokens to this contract\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n    // Update fee tracking\n    partnerFees[partnerId][token] += amount;\n\n    emit FeesDeposited(partnerId, token, amount, msg.sender);\n  }\n\n  /**\n   * @dev Claim rewards for a user (uses epoch-based system)\n   * @param user User address to claim for\n   */\n  function claimRewards(address user) external nonReentrant {\n    require(user != address(0), \"Invalid user\");\n\n    uint256 claimable = this.getClaimableRewards(user);\n    require(claimable > 0, \"No rewards to claim\");\n\n    // Reset user rewards\n    totalClaimed[user][address(0)] = 0;\n\n    // Transfer rewards (assuming native token rewards)\n    (bool success, ) = payable(user).call{value: claimable}(\"\");\n    require(success, \"Transfer failed\");\n\n    // Update total claimed tracking\n    totalClaimed[user][address(0)] += claimable;\n\n    emit RewardsClaimed(user, claimable);\n  }\n\n  /**\n   * @dev Get claimable rewards for a user (sum of all epochs)\n   * @param user User address\n   * @return Total claimable reward amount in native token\n   */\n  function getClaimableRewards(address user) external view returns (uint256) {\n    uint256 totalClaimable = 0;\n\n    for (uint256 epoch = 1; epoch < currentEpoch; epoch++) {\n      if (epochEndTime[epoch] <= block.timestamp) {\n        totalClaimable += getClaimable(user, epoch, address(0));\n      }\n    }\n\n    return totalClaimable;\n  }\n\n  // ======== Existing Epoch-Based Distribution System ========\n\n  /**\n   * @dev Set the wrapped native token address\n   * @param _wrappedToken The new wrapped native token address\n   */\n  function setWrappedToken(address _wrappedToken) external onlyOwner {\n    require(_wrappedToken != address(0), \"Zero address\");\n    address oldToken = wrappedNativeToken;\n    wrappedNativeToken = _wrappedToken;\n    emit WrappedTokenSet(oldToken, _wrappedToken);\n  }\n\n  // Jackpot vault functionality is handled by DragonFeeMHelper contract\n\n  /**\n   * @dev Roll to next epoch if current epoch has ended\n   */\n  function rollEpoch() public {\n    if (block.timestamp >= epochEndTime[currentEpoch]) {\n      // Snapshot total supply for the ending epoch\n      epochTotalSupply[currentEpoch] = veDRAGON.getTotalVotingPower();\n\n      // Start new epoch\n      currentEpoch++;\n      epochStartTime[currentEpoch] = epochEndTime[currentEpoch - 1];\n      epochEndTime[currentEpoch] = epochStartTime[currentEpoch] + epochDuration;\n\n      emit EpochRolled(currentEpoch, epochStartTime[currentEpoch], epochEndTime[currentEpoch]);\n    }\n  }\n\n  /**\n   * @dev Receive fees for distribution (legacy function)\n   * @param token Token address\n   * @param amount Amount of fees\n   */\n  function receiveFees(address token, uint256 amount) external {\n    rollEpoch(); // Ensure we're in the correct epoch\n\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    epochFees[currentEpoch][token] += amount;\n\n    emit FeesReceived(currentEpoch, token, amount);\n  }\n\n  /**\n   * @dev Calculate user's claimable amount for a specific epoch and token\n   * @param user User address\n   * @param epoch Epoch number\n   * @param token Token address\n   * @return Claimable amount\n   */\n  function getClaimable(address user, uint256 epoch, address token) public view returns (uint256) {\n    // Check if epoch is valid and ended\n    if (epoch >= currentEpoch || epochEndTime[epoch] > block.timestamp) {\n      return 0;\n    }\n\n    // Check if already claimed\n    if (hasClaimed[user][epoch][token]) {\n      return 0;\n    }\n\n    // Get user's voting power at epoch end\n    uint256 userVotingPower = veDRAGON.getVotingPowerAt(user, epochEndTime[epoch]);\n    if (userVotingPower == 0) {\n      return 0;\n    }\n\n    // Get total supply for the epoch\n    uint256 totalSupply = epochTotalSupply[epoch];\n    if (totalSupply == 0) {\n      return 0;\n    }\n\n    // Calculate user's share\n    uint256 epochTokenFees = epochFees[epoch][token];\n    return (epochTokenFees * userVotingPower) / totalSupply;\n  }\n\n  /**\n   * @dev Claim fees for a specific epoch and token\n   * @param epoch Epoch number\n   * @param token Token address\n   */\n  function claimFees(uint256 epoch, address token) external nonReentrant {\n    if (epoch >= currentEpoch) revert InvalidEpoch();\n    if (epochEndTime[epoch] > block.timestamp) revert InvalidEpoch();\n\n    uint256 claimable = getClaimable(msg.sender, epoch, token);\n    if (claimable == 0) revert NothingToClaim();\n\n    // Mark as claimed\n    hasClaimed[msg.sender][epoch][token] = true;\n    totalClaimed[msg.sender][token] += claimable;\n\n    // Transfer fees\n    if (token == address(0)) {\n      (bool success, ) = msg.sender.call{value: claimable}(\"\");\n      require(success, \"Native transfer failed\");\n    } else {\n      IERC20(token).safeTransfer(msg.sender, claimable);\n    }\n\n    emit FeesClaimed(msg.sender, epoch, token, claimable);\n  }\n\n  /**\n   * @dev Claim fees for multiple epochs and tokens\n   * @param epochs Array of epoch numbers\n   * @param tokens Array of token addresses\n   */\n  function claimMultiple(uint256[] calldata epochs, address[] calldata tokens) external nonReentrant {\n    for (uint256 i = 0; i < epochs.length; i++) {\n      uint256 epoch = epochs[i];\n\n      if (epoch >= currentEpoch || epochEndTime[epoch] > block.timestamp) {\n        continue; // Skip invalid epochs\n      }\n\n      for (uint256 j = 0; j < tokens.length; j++) {\n        address token = tokens[j];\n        uint256 claimable = getClaimable(msg.sender, epoch, token);\n\n        if (claimable > 0) {\n          // Mark as claimed\n          hasClaimed[msg.sender][epoch][token] = true;\n          totalClaimed[msg.sender][token] += claimable;\n\n          // Transfer fees\n          if (token == address(0)) {\n            (bool success, ) = msg.sender.call{value: claimable}(\"\");\n            require(success, \"Native transfer failed\");\n          } else {\n            IERC20(token).safeTransfer(msg.sender, claimable);\n          }\n\n          emit FeesClaimed(msg.sender, epoch, token, claimable);\n        }\n      }\n    }\n  }\n\n  // ======== View Functions ========\n\n  /**\n   * @dev Get collected fees for an epoch and token\n   * @param epoch Epoch number\n   * @param token Token address\n   * @return Amount of collected fees\n   */\n  function getEpochFees(uint256 epoch, address token) external view returns (uint256) {\n    return epochFees[epoch][token];\n  }\n\n  /**\n   * @dev Get total claimed fees for a user and token\n   * @param user User address\n   * @param token Token address\n   * @return Amount of total claimed fees\n   */\n  function getUserTotalClaimed(address user, address token) external view returns (uint256) {\n    return totalClaimed[user][token];\n  }\n\n  /**\n   * @dev Check if user has claimed for a specific epoch and token\n   * @param user User address\n   * @param epoch Epoch number\n   * @param token Token address\n   * @return True if claimed\n   */\n  function hasUserClaimed(address user, uint256 epoch, address token) external view returns (bool) {\n    return hasClaimed[user][epoch][token];\n  }\n\n  /**\n   * @dev Get partner fees for a specific partner and token\n   * @param partnerId Partner ID\n   * @param token Token address\n   * @return Fee amount\n   */\n  function getPartnerFees(uint256 partnerId, address token) external view returns (uint256) {\n    return partnerFees[partnerId][token];\n  }\n\n  // ======== Admin Functions ========\n\n  /**\n   * @dev Set epoch duration\n   * @param _duration New duration in seconds\n   */\n  function setEpochDuration(uint256 _duration) external onlyOwner {\n    require(_duration >= 1 days && _duration <= 30 days, \"Invalid duration\");\n    epochDuration = _duration;\n  }\n\n  /**\n   * @dev Register my contract on Sonic FeeM\n   * @notice This registers the contract with Sonic's Fee Manager for network benefits\n   */\n  function registerMe() external onlyOwner {\n    (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n        abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n\n  // ======== Interface Implementation Functions ========\n\n  /**\n   * @notice Receive rewards (DRAGON tokens) from external sources\n   * @param _amount The amount of DRAGON tokens to receive\n   */\n  function receiveRewards(uint256 _amount) external override nonReentrant {\n    require(_amount > 0, \"Amount must be positive\");\n    require(address(rewardToken) != address(0), \"Reward token not set\");\n\n    // Transfer tokens from sender\n    rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n    // Update accumulated rewards\n    _accumulatedRewards += _amount;\n\n    emit RewardsReceived(_amount);\n  }\n\n  /**\n   * @notice Distribute accumulated rewards to the veDRAGON contract or reward mechanism\n   */\n  function distributeRewards() external override nonReentrant {\n    require(_accumulatedRewards > 0, \"No rewards to distribute\");\n    require(address(rewardToken) != address(0), \"Reward token not set\");\n\n    rollEpoch(); // Ensure we're in the correct epoch\n\n    uint256 amount = _accumulatedRewards;\n    _accumulatedRewards = 0;\n\n    // Add to current epoch fees for distribution\n    epochFees[currentEpoch][address(rewardToken)] += amount;\n\n    emit RewardsDistributed(amount);\n    emit FeesReceived(currentEpoch, address(rewardToken), amount);\n  }\n\n  /**\n   * @notice Get the current accumulated rewards that have not been distributed\n   * @return The amount of undistributed rewards\n   */\n  function accumulatedRewards() external view override returns (uint256) {\n    return _accumulatedRewards;\n  }\n\n  /**\n   * @notice Set the DRAGON token address\n   * @param _rewardToken The address of the DRAGON token\n   */\n  function setRewardToken(address _rewardToken) external override onlyOwner {\n    require(_rewardToken != address(0), \"Invalid token address\");\n\n    address oldToken = address(rewardToken);\n    rewardToken = IERC20(_rewardToken);\n\n    emit RewardTokenUpdated(oldToken, _rewardToken);\n  }\n\n  /**\n   * @notice Update the veDRAGON recipient address (not applicable for this implementation)\n   * @param _veDRAGONAddress The new veDRAGON contract or reward distributor address\n   */\n  function setVeDRAGONAddress(address _veDRAGONAddress) external override onlyOwner {\n    // This implementation uses immutable veDRAGON, so this is just for interface compliance\n    require(_veDRAGONAddress != address(0), \"Invalid address\");\n    emit VeDRAGONAddressUpdated(address(veDRAGON), _veDRAGONAddress);\n  }\n\n  /**\n   * @notice Set the wrapped native token address (interface compliance)\n   * @param _wrappedNativeToken The new wrapped native token address\n   */\n  function setWrappedNativeToken(address _wrappedNativeToken) external override onlyOwner {\n    require(_wrappedNativeToken != address(0), \"Zero address\");\n    address oldToken = wrappedNativeToken;\n    wrappedNativeToken = _wrappedNativeToken;\n    emit WrappedTokenSet(oldToken, _wrappedNativeToken);\n  }\n}"
    },
    "contracts/core/governance/voting/VotingPowerCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title VotingPowerCalculator\n * @dev Library for calculating voting power for veDRAGON tokens\n * Supports linear and time-weighted calculation methods for simplicity and gas efficiency\n */\nlibrary VotingPowerCalculator {\n  using Math for uint256;\n\n  // Constants\n  uint256 public constant PRECISION = 1e18;\n  uint256 public constant BPS_DENOMINATOR = 10000;\n  uint256 public constant SECONDS_PER_YEAR = 365 days;\n  uint256 public constant MAX_LOCK_TIME = 4 * SECONDS_PER_YEAR;\n\n  // Calculation methods for voting power (simplified)\n  enum VotingPowerMethod {\n    LINEAR, // Linear scaling with lock time\n    TIME_WEIGHTED // Time-weighted balance (veCRV style)\n  }\n\n  /**\n   * @dev Calculate voting power based on amount and lock time using the specified method\n   * @param amount Amount of veDRAGON tokens\n   * @param lockDuration Duration of lock in seconds\n   * @param method Calculation method to use\n   * @return votingPower The calculated voting power\n   */\n  function calculateVotingPower(\n    uint256 amount,\n    uint256 lockDuration,\n    VotingPowerMethod method\n  ) public pure returns (uint256 votingPower) {\n    if (amount == 0) return 0;\n\n    // Ensure lock duration is capped\n    lockDuration = Math.min(lockDuration, MAX_LOCK_TIME);\n\n    // Apply different calculation methods\n    if (method == VotingPowerMethod.LINEAR) {\n      return calculateLinearVotingPower(amount, lockDuration);\n    } else if (method == VotingPowerMethod.TIME_WEIGHTED) {\n      return calculateTimeWeightedVotingPower(amount, lockDuration);\n    } else {\n      // Default to linear if invalid method\n      return calculateLinearVotingPower(amount, lockDuration);\n    }\n  }\n\n  /**\n   * @dev Calculate voting power using linear scaling with lock time\n   * @param amount Amount of veDRAGON tokens\n   * @param lockDuration Duration of lock in seconds\n   * @return votingPower The calculated voting power\n   */\n  function calculateLinearVotingPower(uint256 amount, uint256 lockDuration) public pure returns (uint256 votingPower) {\n    // Linear scaling: amount * (lockDuration / MAX_LOCK_TIME)\n    // With minimum multiplier of 1x and maximum of 2.5x\n    uint256 timeRatio = (lockDuration * PRECISION) / MAX_LOCK_TIME;\n    uint256 boost = BPS_DENOMINATOR + ((15000 * timeRatio) / PRECISION); // 1.5x additional boost\n\n    return (amount * boost) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @dev Calculate voting power using time-weighted balance (veCRV style)\n   * @param amount Amount of veDRAGON tokens\n   * @param lockDuration Duration of lock in seconds\n   * @return votingPower The calculated voting power\n   */\n  function calculateTimeWeightedVotingPower(\n    uint256 amount,\n    uint256 lockDuration\n  ) public pure returns (uint256 votingPower) {\n    // Time-weighted voting power: amount * lockDuration / MAX_LOCK_TIME\n    return (amount * lockDuration) / MAX_LOCK_TIME;\n  }\n\n  /**\n   * @dev Calculate effective voting power at a specific timestamp\n   * @param amount Amount of veDRAGON tokens\n   * @param lockEndTime Timestamp when lock expires\n   * @param currentTime Current timestamp to calculate voting power at\n   * @param method Calculation method to use\n   * @return effectiveVotingPower The time-decayed voting power\n   */\n  function calculateEffectiveVotingPower(\n    uint256 amount,\n    uint256 lockEndTime,\n    uint256 currentTime,\n    VotingPowerMethod method\n  ) public pure returns (uint256 effectiveVotingPower) {\n    // If lock has expired, voting power is 0\n    if (currentTime >= lockEndTime) return 0;\n\n    // Calculate remaining lock duration\n    uint256 remainingLockTime = lockEndTime - currentTime;\n\n    // Calculate effective voting power using specified method\n    return calculateVotingPower(amount, remainingLockTime, method);\n  }\n\n  /**\n   * @dev Calculate weighted voting power for governance\n   * @param amount Amount of veDRAGON tokens\n   * @param lockEndTime Timestamp when lock expires\n   * @param currentTime Current timestamp\n   * @return weightedVotingPower The weighted voting power for governance\n   */\n  function calculateGovernanceVotingPower(\n    uint256 amount,\n    uint256 lockEndTime,\n    uint256 currentTime\n  ) public pure returns (uint256 weightedVotingPower) {\n    // For governance, we use time-weighted power with a minimum 0.1x multiplier\n    // If lock has expired, provide minimal voting rights (10% of tokens)\n    if (currentTime >= lockEndTime) {\n      return amount / 10;\n    }\n\n    // Calculate remaining lock duration\n    uint256 remainingLockTime = lockEndTime - currentTime;\n\n    // Use time-weighted method for governance\n    uint256 baseVotingPower = calculateTimeWeightedVotingPower(amount, remainingLockTime);\n\n    // Ensure minimum voting power is 10% of token amount\n    return Math.max(baseVotingPower, amount / 10);\n  }\n\n  /**\n   * @dev Calculate boost multiplier for rewards based on voting power\n   * @param votingPower User's voting power\n   * @param totalVotingPower Total voting power in the system\n   * @param userBalance User's token balance\n   * @param totalSupply Total token supply\n   * @return boostMultiplier The boost multiplier in basis points (10000 = 1.0x)\n   */\n  function calculateRewardBoostMultiplier(\n    uint256 votingPower,\n    uint256 totalVotingPower,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) public pure returns (uint256 boostMultiplier) {\n    if (votingPower == 0 || totalVotingPower == 0) {\n      return BPS_DENOMINATOR; // Default 1.0x with no voting power\n    }\n\n    // Calculate vote share and token share\n    uint256 voteShare = (votingPower * PRECISION) / totalVotingPower;\n    uint256 tokenShare = (userBalance * PRECISION) / totalSupply;\n\n    // Calculate boost based on the ratio of vote share to token share\n    // A higher vote-to-token ratio gives more boost, capped at 2.5x\n    uint256 shareRatio = (voteShare * PRECISION) / tokenShare;\n\n    // Linear scaling from 1.0x to 2.5x based on share ratio\n    // Maximum boost at 4.0x ratio (4 times more voting weight than token weight)\n    uint256 maxBoostRatio = 4 * PRECISION;\n    uint256 maxBoostMultiplier = 25000; // 2.5x\n\n    if (shareRatio >= maxBoostRatio) {\n      return maxBoostMultiplier;\n    } else {\n      uint256 boostRange = maxBoostMultiplier - BPS_DENOMINATOR;\n      uint256 additionalBoost = (boostRange * shareRatio) / maxBoostRatio;\n      return BPS_DENOMINATOR + additionalBoost;\n    }\n  }\n}"
    },
    "contracts/core/helpers/DragonFeeMHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IOmniDragonRegistry} from \"../../interfaces/config/IOmniDragonRegistry.sol\";\nimport {DragonErrors} from \"../../libraries/DragonErrors.sol\";\n\n/**\n * @title DragonFeeMHelper\n * @author 0xakita.eth\n * @dev Dedicated helper contract for Sonic FeeM integration and revenue routing\n * @notice Handles FeeM registration and routes all revenue to jackpot vault\n *\n * Benefits:\n * - Separates FeeM logic from main omniDRAGON contract\n * - Reduces main contract size by ~500 bytes\n * - Centralizes fee routing logic\n * - Can be upgraded independently\n * - Chain-specific deployment (only needed on Sonic)\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract DragonFeeMHelper is Ownable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // Constants\n  uint256 public constant SONIC_CHAIN_ID = 146;\n  address public constant SONIC_FEEM_CONTRACT = 0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830;\n\n  // State variables\n  IOmniDragonRegistry public immutable registry;\n  uint256 public feeMRegistrationId;\n  bool public autoForwardEnabled = true;\n\n  // Statistics\n  uint256 public totalFeeMRevenue;\n  uint256 public totalForwarded;\n  uint256 public lastForwardTime;\n\n  // Manual jackpot vault address (since removed from registry interface)\n  address public jackpotVaultAddress;\n\n  // Events\n  event FeeMRegistered(uint256 indexed registrationId, bool success);\n  event FeeMRevenueReceived(uint256 amount, uint256 timestamp);\n  event FeeMRevenueForwarded(address indexed jackpot, uint256 amount, uint256 timestamp);\n  event AutoForwardToggled(bool enabled);\n  event RegistrationIdUpdated(uint256 oldId, uint256 newId);\n  event JackpotVaultUpdated(address indexed oldVault, address indexed newVault);\n  event EmergencyWithdraw(address indexed token, uint256 amount, address indexed to);\n\n  // Errors specific to FeeM helper\n  error NotSonicChain();\n  error RegistrationFailed();\n\n  /**\n   * @dev Constructor\n   * @param _registry Registry contract address\n   * @param _registrationId Initial FeeM registration ID\n   * @param _jackpotVault Initial jackpot vault address\n   * @param _owner Owner address\n   */\n  constructor(\n    address _registry,\n    uint256 _registrationId,\n    address _jackpotVault,\n    address _owner\n  ) Ownable(_owner) {\n    if (_registry == address(0)) revert DragonErrors.ZeroAddress();\n    if (_jackpotVault == address(0)) revert DragonErrors.ZeroAddress();\n    if (_owner == address(0)) revert DragonErrors.ZeroAddress();\n\n    // Only deploy on Sonic chain\n    if (block.chainid != SONIC_CHAIN_ID) revert NotSonicChain();\n\n    registry = IOmniDragonRegistry(_registry);\n    feeMRegistrationId = _registrationId;\n    jackpotVaultAddress = _jackpotVault;\n\n    // Auto-register on deployment\n    _registerForFeeM();\n  }\n\n  /**\n   * @dev Register contract for Sonic FeeM\n   */\n  function registerForFeeM() external onlyOwner {\n    _registerForFeeM();\n  }\n\n  /**\n   * @dev Internal FeeM registration\n   */\n  function _registerForFeeM() internal {\n    (bool success, ) = SONIC_FEEM_CONTRACT.call(abi.encodeWithSignature(\"selfRegister(uint256)\", feeMRegistrationId));\n\n    emit FeeMRegistered(feeMRegistrationId, success);\n\n    if (!success) revert RegistrationFailed();\n  }\n\n  /**\n   * @dev Update FeeM registration ID\n   * @param _newId New registration ID\n   */\n  function setFeeMRegistrationId(uint256 _newId) external onlyOwner {\n    uint256 oldId = feeMRegistrationId;\n    feeMRegistrationId = _newId;\n    emit RegistrationIdUpdated(oldId, _newId);\n\n    // Re-register with new ID\n    _registerForFeeM();\n  }\n\n  /**\n   * @notice Set jackpot vault address manually\n   * @param _jackpotVault The jackpot vault address\n   */\n  function setJackpotVaultAddress(address _jackpotVault) external onlyOwner {\n    if (_jackpotVault == address(0)) revert DragonErrors.ZeroAddress();\n    \n    address oldVault = jackpotVaultAddress;\n    jackpotVaultAddress = _jackpotVault;\n    emit JackpotVaultUpdated(oldVault, _jackpotVault);\n  }\n\n  /**\n   * @dev Toggle auto-forward functionality\n   * @param _enabled Whether to auto-forward revenue\n   */\n  function setAutoForward(bool _enabled) external onlyOwner {\n    autoForwardEnabled = _enabled;\n    emit AutoForwardToggled(_enabled);\n  }\n\n  /**\n   * @dev Receive FeeM revenue and auto-forward to jackpot\n   * Added reentrancy protection for external calls safety\n   */\n  receive() external payable nonReentrant {\n    if (msg.value > 0) {\n      totalFeeMRevenue += msg.value;\n      emit FeeMRevenueReceived(msg.value, block.timestamp);\n\n      if (autoForwardEnabled) {\n        _forwardToJackpot(msg.value);\n      }\n    }\n  }\n\n  /**\n   * @dev Manually forward accumulated revenue to jackpot\n   * @param amount Amount to forward (0 = all)\n   */\n  function forwardToJackpot(uint256 amount) external nonReentrant {\n    uint256 balance = address(this).balance;\n    if (balance == 0) revert DragonErrors.InsufficientBalance();\n\n    uint256 forwardAmount = amount == 0 ? balance : amount;\n    if (forwardAmount > balance) revert DragonErrors.InsufficientBalance();\n\n    _forwardToJackpot(forwardAmount);\n  }\n\n  /**\n   * @dev Internal function to forward revenue to jackpot\n   * @param amount Amount to forward\n   */\n  function _forwardToJackpot(uint256 amount) internal {\n    if (jackpotVaultAddress == address(0)) revert DragonErrors.ZeroAddress();\n\n    (bool success, ) = payable(jackpotVaultAddress).call{value: amount}(\"\");\n    if (!success) revert DragonErrors.TransferFailed();\n\n    totalForwarded += amount;\n    lastForwardTime = block.timestamp;\n\n    emit FeeMRevenueForwarded(jackpotVaultAddress, amount, block.timestamp);\n  }\n\n  /**\n   * @dev Emergency withdraw forwards non-core assets to the jackpot vault instead of owner.\n   */\n  function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n    if (amount == 0) revert DragonErrors.AmountBelowMinimum();\n\n    address to = jackpotVaultAddress;\n    if (to == address(0)) revert DragonErrors.ZeroAddress();\n\n    if (token == address(0)) {\n      uint256 balance = address(this).balance;\n      if (balance < amount) revert DragonErrors.InsufficientBalance();\n      (bool success, ) = payable(to).call{value: amount}(\"\");\n      if (!success) revert DragonErrors.TransferFailed();\n    } else {\n      IERC20(token).safeTransfer(to, amount);\n    }\n\n    emit EmergencyWithdraw(token, amount, to);\n  }\n\n  // ========== VIEW FUNCTIONS ==========\n\n  /**\n   * @dev Get current jackpot vault address\n   */\n  function getJackpotVault() external view returns (address) {\n    return jackpotVaultAddress;\n  }\n\n  /**\n   * @dev Get contract balance\n   */\n  function getBalance() external view returns (uint256) {\n    return address(this).balance;\n  }\n\n  /**\n   * @dev Get revenue statistics\n   */\n  function getStats()\n    external\n    view\n    returns (uint256 totalRevenue, uint256 totalForwardedAmount, uint256 pendingAmount, uint256 lastForward)\n  {\n    return (totalFeeMRevenue, totalForwarded, address(this).balance, lastForwardTime);\n  }\n\n  /**\n   * @dev Check if contract is registered for FeeM\n   */\n  function isRegisteredForFeeM() external view returns (bool) {\n    try this._checkRegistration() returns (bool registered) {\n      return registered;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Internal function to check FeeM registration\n   */\n  function _checkRegistration() external view returns (bool) {\n    (bool success, bytes memory data) = SONIC_FEEM_CONTRACT.staticcall(\n      abi.encodeWithSignature(\"isRegistered(address)\", address(this))\n    );\n\n    if (!success || data.length == 0) return false;\n    return abi.decode(data, (bool));\n  }\n}"
    },
    "contracts/core/helpers/OmniDragonViewHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IOmniDRAGON} from \"../../interfaces/tokens/IOmniDRAGON.sol\";\n\n// Custom errors\nerror ArrayTooLarge();\n\n/**\n * @title OmniDragonViewHelper\n * @dev Helper contract for view functions removed from main omniDRAGON contract\n * @notice This contract provides non-essential view functions for external tooling and analytics\n *\n * Benefits:\n * - Reduces main contract size by ~1-2KB\n * - Keeps analytics functions available for external tools\n * - Cleaner main contract focused on core functionality\n */\ncontract OmniDragonViewHelper {\n  // Add maximum array size to prevent DoS attacks\n  uint256 public constant MAX_BATCH_SIZE = 100;\n\n  /**\n   * @notice Get the maximum transaction amount for omniDRAGON\n   * @return The maximum single transfer amount\n   */\n  function maxTransactionAmount() external pure returns (uint256) {\n    return 1_000_000 * 10 ** 18; // MAX_SINGLE_TRANSFER constant\n  }\n\n  /**\n   * @notice Get contract balances for a given omniDRAGON contract\n   * @param token The omniDRAGON contract address\n   * @return tokenBalance The contract's token balance\n   * @return nativeBalance The contract's native balance\n   */\n  function getContractBalance(address token) external view returns (uint256 tokenBalance, uint256 nativeBalance) {\n    return (IERC20(token).balanceOf(token), token.balance);\n  }\n\n  /**\n   * @notice Get the accumulated operational funds (WETH balance) of omniDRAGON\n   * @dev Returns 0 if the function doesn't exist or reverts\n   * @return The contract's operational funds balance\n   */\n  function getWETHBalance(address /* token */) external pure returns (uint256) {\n    // Operational funds no longer exist - third fee portion is burned\n    return 0;\n  }\n\n  /**\n   * @notice Get version information\n   * @return The contract version\n   */\n  function version() external pure returns (string memory) {\n    return \"2.3.0-optimized\";\n  }\n\n  /**\n   * @notice Get comprehensive analytics for omniDRAGON contract\n   * @param token The omniDRAGON contract address\n   * @return tokenBalance Contract token balance\n   * @return nativeBalance Contract native balance\n   * @return wethBalance Contract WETH balance\n   * @return maxTxAmount Maximum transaction amount\n   */\n  function getAnalytics(\n    address token\n  ) external view returns (uint256 tokenBalance, uint256 nativeBalance, uint256 wethBalance, uint256 maxTxAmount) {\n    (tokenBalance, nativeBalance) = this.getContractBalance(token);\n    wethBalance = this.getWETHBalance(token);\n    maxTxAmount = this.maxTransactionAmount();\n  }\n\n  /**\n   * @notice Batch view function to get multiple contract analytics\n   * @param tokens Array of omniDRAGON contract addresses\n   * @return tokenBalances Array of token balances\n   * @return nativeBalances Array of native balances\n   * @return wethBalances Array of WETH balances\n   */\n  function batchGetAnalytics(\n    address[] calldata tokens\n  )\n    external\n    view\n    returns (uint256[] memory tokenBalances, uint256[] memory nativeBalances, uint256[] memory wethBalances)\n  {\n    uint256 length = tokens.length;\n\n    // Prevent DoS attacks by limiting array size\n    if (length > MAX_BATCH_SIZE) revert ArrayTooLarge();\n\n    tokenBalances = new uint256[](length);\n    nativeBalances = new uint256[](length);\n    wethBalances = new uint256[](length);\n\n    for (uint256 i = 0; i < length; i++) {\n      (tokenBalances[i], nativeBalances[i]) = this.getContractBalance(tokens[i]);\n      wethBalances[i] = this.getWETHBalance(tokens[i]);\n    }\n  }\n\n  /**\n   * @notice Get comprehensive omniDRAGON contract information\n   * @param token The omniDRAGON contract address\n   * @return buyFees Current buy fee structure\n   * @return sellFees Current sell fee structure\n   * @return flags Control flags\n   * @return jackpot Jackpot vault address\n   * @return revenue Revenue distributor address\n   */\n  function getTokenInfo(\n    address token\n  )\n    external\n    view\n    returns (\n      IOmniDRAGON.Fees memory buyFees,\n      IOmniDRAGON.Fees memory sellFees,\n      IOmniDRAGON.ControlFlags memory flags,\n      address jackpot,\n      address revenue\n    )\n  {\n    IOmniDRAGON omniDragon = IOmniDRAGON(token);\n    \n    (buyFees, sellFees) = omniDragon.getFees();\n    flags = omniDragon.getControlFlags();\n    (jackpot, revenue) = omniDragon.getDistributionAddresses();\n  }\n\n  /**\n   * @notice Check if addresses have special permissions\n   * @param token The omniDRAGON contract address\n   * @param accounts Array of addresses to check\n   * @return excludedFromFees Array indicating if each address is excluded from fees\n   * @return excludedFromMaxTransfer Array indicating if each address is excluded from max transfer\n   * @return isPairs Array indicating if each address is a trading pair\n   */\n  function checkPermissions(\n    address token,\n    address[] calldata accounts\n  )\n    external\n    view\n    returns (bool[] memory excludedFromFees, bool[] memory excludedFromMaxTransfer, bool[] memory isPairs)\n  {\n    uint256 length = accounts.length;\n    if (length > MAX_BATCH_SIZE) revert ArrayTooLarge();\n\n    IOmniDRAGON omniDragon = IOmniDRAGON(token);\n    \n    excludedFromFees = new bool[](length);\n    excludedFromMaxTransfer = new bool[](length);\n    isPairs = new bool[](length);\n\n    for (uint256 i = 0; i < length; i++) {\n      excludedFromFees[i] = omniDragon.isExcludedFromFees(accounts[i]);\n      excludedFromMaxTransfer[i] = omniDragon.isExcludedFromMaxTransfer(accounts[i]);\n      isPairs[i] = omniDragon.isPair(accounts[i]);\n    }\n  }\n}"
    },
    "contracts/core/lottery/OmniDragonJackpotVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IDragonJackpotVault} from \"../../interfaces/lottery/IDragonJackpotVault.sol\";\n\n// Interface for wrapped native tokens (wETH/wS/etc)\ninterface IWrappedNativeToken {\n  function deposit() external payable;\n  function withdraw(uint256 amount) external;\n  function transfer(address to, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n}\n\nimport {DragonErrors} from \"../../libraries/DragonErrors.sol\";\n\n/**\n * @title OmniDragonJackpotVault\n * @author 0xakita.eth\n * @dev Jackpot vault with lottery mechanics and fee management\n *\n * Central component for Dragon ecosystem lottery system and jackpot distribution\n * Integrates with OmniDragon token to provide engaging lottery experiences\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract OmniDragonJackpotVault is IDragonJackpotVault, Ownable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // Constants for payout logic\n  uint256 public constant WINNER_PERCENTAGE = 6900; // 69% to winner\n  uint256 public constant ROLLOVER_PERCENTAGE = 3100; // 31% stays for next round  \n  uint256 public constant BASIS_POINTS = 10000; // 100%\n\n  // Core state\n  mapping(address => uint256) public jackpotBalances;\n  address public wrappedNativeToken;\n  uint256 public lastWinTimestamp;\n\n  // Events  \n  event JackpotAdded(address indexed token, uint256 amount);\n  event JackpotPaid(address indexed token, address indexed winner, uint256 winAmount, uint256 rolloverAmount);\n  event WrappedNativeTokenSet(address indexed oldToken, address indexed newToken);\n  event EmergencyWithdraw(address indexed token, address indexed to, uint256 amount);\n\n  /**\n   * @dev Constructor\n   * @param _wrappedNativeToken Initial wrapped native token address\n   * @param _owner Owner address\n   */\n  constructor(address _wrappedNativeToken, address _owner) Ownable(_owner) {\n    // Allow placeholder (zero) for vanity CREATE2 deployments across chains.\n    // Runtime functions already enforce non-zero via DragonErrors.WrappedTokenNotSet().\n    wrappedNativeToken = _wrappedNativeToken;\n  }\n\n  /**\n   * @dev Post-deploy initializer to set wrapped native token once.\n   */\n  function initializeWrappedNativeToken(address _wrappedNativeToken) external onlyOwner {\n    if (wrappedNativeToken != address(0)) revert DragonErrors.UnauthorizedCaller();\n    if (_wrappedNativeToken == address(0)) revert DragonErrors.ZeroAddress();\n    wrappedNativeToken = _wrappedNativeToken;\n    emit WrappedNativeTokenSet(address(0), _wrappedNativeToken);\n  }\n\n  /**\n   * @dev Add ERC20 tokens to the jackpot - gas optimized\n   * @param token Token address\n   * @param amount Amount to add\n   */\n  function addERC20ToJackpot(address token, uint256 amount) external {\n    if (amount == 0) revert DragonErrors.ZeroAmount();\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    jackpotBalances[token] += amount;\n    emit JackpotAdded(token, amount);\n  }\n\n  /**\n   * @dev Add already collected funds to accounting (owner only)\n   * @param token Token address \n   * @param amount Amount to add to accounting\n   */\n  function addCollectedFunds(address token, uint256 amount) external onlyOwner {\n    if (amount == 0) revert DragonErrors.ZeroAmount();\n    if (token == address(0)) revert DragonErrors.ZeroAddress();\n    jackpotBalances[token] += amount;\n    emit JackpotAdded(token, amount);\n  }\n\n  /**\n   * @dev Get the current jackpot balance (in wrapped native token)\n   * @return balance The current jackpot balance\n   */\n  function getJackpotBalance() external view override returns (uint256 balance) {\n    return jackpotBalances[wrappedNativeToken];\n  }\n\n  /**\n   * @dev Pay jackpot to winner - 69% to winner, 31% rolls over\n   * @param winner Winner address who gets 69% of the jackpot\n   */\n  function payEntireJackpot(address winner) external override onlyOwner nonReentrant {\n    if (wrappedNativeToken == address(0)) revert DragonErrors.WrappedTokenNotSet();\n    if (winner == address(0)) revert DragonErrors.ZeroAddress();\n    \n    uint256 totalJackpot = jackpotBalances[wrappedNativeToken];\n    if (totalJackpot == 0) revert DragonErrors.NoJackpotToPay();\n\n    // Calculate payouts: 69% to winner, 31% stays for next round\n    uint256 winnerAmount = (totalJackpot * WINNER_PERCENTAGE) / BASIS_POINTS;\n    uint256 rolloverAmount = totalJackpot - winnerAmount; // Remainder stays\n\n    // Update state - only reduce by winner amount, rollover stays\n    jackpotBalances[wrappedNativeToken] = rolloverAmount;\n    lastWinTimestamp = block.timestamp;\n\n    // Pay winner their 69%\n    IERC20(wrappedNativeToken).safeTransfer(winner, winnerAmount);\n    emit JackpotPaid(wrappedNativeToken, winner, winnerAmount, rolloverAmount);\n  }\n\n  /**\n   * @dev Pay jackpot with specific token - 69% to winner, 31% rolls over\n   * @param token Token address\n   * @param winner Winner address who gets 69% of the jackpot\n   */\n  function payEntireJackpotWithToken(address token, address winner) external onlyOwner nonReentrant {\n    if (winner == address(0)) revert DragonErrors.ZeroAddress();\n    if (token == address(0)) revert DragonErrors.ZeroAddress();\n    \n    uint256 totalJackpot = jackpotBalances[token];\n    if (totalJackpot == 0) revert DragonErrors.NoJackpotToPay();\n\n    // Calculate payouts: 69% to winner, 31% stays for next round\n    uint256 winnerAmount = (totalJackpot * WINNER_PERCENTAGE) / BASIS_POINTS;\n    uint256 rolloverAmount = totalJackpot - winnerAmount; // Remainder stays\n\n    // Update state - only reduce by winner amount, rollover stays\n    jackpotBalances[token] = rolloverAmount;\n    lastWinTimestamp = block.timestamp;\n\n    // Pay winner their 69%\n    IERC20(token).safeTransfer(winner, winnerAmount);\n    emit JackpotPaid(token, winner, winnerAmount, rolloverAmount);\n  }\n\n  /**\n   * @dev Legacy function for interface compatibility - now pays 69% of jackpot\n   * @param winner Winner address who gets 69% of the jackpot\n   * @dev Amount parameter is ignored - winner always gets 69% of total jackpot\n   */\n  function payJackpot(address winner, uint256 /* amount */) external override onlyOwner nonReentrant {\n    // Ignore the amount parameter - use our 69/31 split logic!\n    if (wrappedNativeToken == address(0)) revert DragonErrors.WrappedTokenNotSet();\n    if (winner == address(0)) revert DragonErrors.ZeroAddress();\n    \n    uint256 totalJackpot = jackpotBalances[wrappedNativeToken];\n    if (totalJackpot == 0) revert DragonErrors.NoJackpotToPay();\n\n    // Calculate payouts: 69% to winner, 31% stays for next round\n    uint256 winnerAmount = (totalJackpot * WINNER_PERCENTAGE) / BASIS_POINTS;\n    uint256 rolloverAmount = totalJackpot - winnerAmount; // Remainder stays\n\n    // Update state - only reduce by winner amount, rollover stays\n    jackpotBalances[wrappedNativeToken] = rolloverAmount;\n    lastWinTimestamp = block.timestamp;\n\n    // Pay winner their 69%\n    IERC20(wrappedNativeToken).safeTransfer(winner, winnerAmount);\n    emit JackpotPaid(wrappedNativeToken, winner, winnerAmount, rolloverAmount);\n  }\n\n  /**\n   * @dev Get the time of the last jackpot win\n   * @return timestamp The last win timestamp\n   */\n  function getLastWinTime() external view override returns (uint256 timestamp) {\n    return lastWinTimestamp;\n  }\n\n  /**\n   * @dev Set the wrapped native token address\n   * @param _wrappedNativeToken The new wrapped native token address\n   */\n  function setWrappedNativeToken(address _wrappedNativeToken) external override onlyOwner {\n    if (_wrappedNativeToken == address(0)) revert DragonErrors.ZeroAddress();\n    address oldToken = wrappedNativeToken;\n    wrappedNativeToken = _wrappedNativeToken;\n    emit WrappedNativeTokenSet(oldToken, _wrappedNativeToken);\n  }\n\n  /**\n   * @dev Emergency withdraw for non-core tokens only. Core token is `wrappedNativeToken`.\n   *      Native balance is auto-wrapped in receive(); withdrawing native would drain core funds, so disallowed.\n   */\n  function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n    if (amount == 0) revert DragonErrors.ZeroAmount();\n\n    // Disallow withdrawing core jackpot asset\n    if (token == wrappedNativeToken) revert DragonErrors.UnauthorizedCaller();\n\n    if (token == address(0)) {\n      // Native should not be held materially (receive() auto-wraps). Block native withdraw to avoid optics issues.\n      revert DragonErrors.UnauthorizedCaller();\n    } else {\n      // Withdraw only non-core ERC20s mistakenly sent to contract\n      IERC20(token).safeTransfer(owner(), amount);\n    }\n\n    emit EmergencyWithdraw(token, owner(), amount);\n  }\n\n  /**\n   * @dev Get jackpot balance for a specific token\n   * @param token Token address\n   * @return Jackpot balance\n   */\n  function getJackpotBalance(address token) external view returns (uint256) {\n    return jackpotBalances[token];\n  }\n\n  /**\n   * @dev Receive native tokens from FeeM and other sources - auto-wrap to wrapped native token\n   * @dev Critical for DragonFeeMHelper integration on Sonic (wS)\n   */\n  receive() external payable nonReentrant {\n    if (wrappedNativeToken == address(0)) revert DragonErrors.WrappedTokenNotSet();\n    if (msg.value == 0) revert DragonErrors.ZeroAmount();\n\n    // Auto-wrap received native token into wrapped native token for uniform accounting\n    IWrappedNativeToken(wrappedNativeToken).deposit{value: msg.value}();\n\n    // Track wrapped tokens in jackpot balance\n    jackpotBalances[wrappedNativeToken] += msg.value;\n    emit JackpotAdded(wrappedNativeToken, msg.value);\n  }\n\n  /**\n   * @dev Enter the jackpot with Dragon tokens (placeholder for interface compatibility)\n   * @param user Address of the user entering the jackpot (for events)\n   * @param amount Amount of Dragon tokens (for events)\n   */\n  function enterJackpotWithDragon(address user, uint256 amount) external override {\n    if (user == address(0)) revert DragonErrors.ZeroAddress();\n    if (amount == 0) revert DragonErrors.ZeroAmount();\n    // Placeholder - actual Dragon token handling done through fee distribution\n    emit JackpotAdded(address(0), amount); // address(0) represents Dragon tokens\n  }\n\n  /**\n   * @dev Enter the jackpot with wrapped native tokens\n   * @param user Address of the user entering the jackpot\n   * @param amount Amount of wrapped native tokens to enter\n   */\n  function enterJackpotWithWrappedNativeToken(address user, uint256 amount) external override {\n    if (user == address(0)) revert DragonErrors.ZeroAddress();\n    if (amount == 0) revert DragonErrors.ZeroAmount();\n    if (wrappedNativeToken == address(0)) revert DragonErrors.WrappedTokenNotSet();\n\n    // Transfer wrapped native tokens from caller\n    IERC20(wrappedNativeToken).safeTransferFrom(msg.sender, address(this), amount);\n    jackpotBalances[wrappedNativeToken] += amount;\n    emit JackpotAdded(wrappedNativeToken, amount);\n  }\n\n  /**\n   * @dev Enter the jackpot with native tokens (alternative to receive())\n   * @param user Address of the user entering the jackpot\n   */\n  function enterJackpotWithNative(address user) external payable override {\n    if (user == address(0)) revert DragonErrors.ZeroAddress();\n    if (msg.value == 0) revert DragonErrors.ZeroAmount();\n    if (wrappedNativeToken == address(0)) revert DragonErrors.WrappedTokenNotSet();\n\n    // Auto-wrap the received ETH/SONIC into wrapped native token\n    IWrappedNativeToken(wrappedNativeToken).deposit{value: msg.value}();\n    jackpotBalances[wrappedNativeToken] += msg.value;\n    emit JackpotAdded(wrappedNativeToken, msg.value);\n  }\n\n  // ========== VIEW FUNCTIONS ==========\n\n  /**\n   * @dev Get total jackpot value in wrapped native token\n   */\n  function getTotalJackpotValue() external view returns (uint256) {\n    return jackpotBalances[wrappedNativeToken];\n  }\n\n  /**\n   * @dev Calculate what winner would receive (69% of current jackpot)\n   */\n  function getWinnerPayout() external view returns (uint256) {\n    uint256 totalJackpot = jackpotBalances[wrappedNativeToken];\n    return (totalJackpot * WINNER_PERCENTAGE) / BASIS_POINTS;\n  }\n\n  /**\n   * @dev Calculate what would rollover after a win (31% of current jackpot)\n   */\n  function getRolloverAmount() external view returns (uint256) {\n    uint256 totalJackpot = jackpotBalances[wrappedNativeToken];\n    return (totalJackpot * ROLLOVER_PERCENTAGE) / BASIS_POINTS;\n  }\n\n  // FeeM revenue routing handled by DragonFeeMHelper  receive() function\n\n  // ========== SONIC FEEM INTEGRATION ==========\n\n  /**\n   * @dev Register my contract on Sonic FeeM\n   * @notice This registers the contract with Sonic's Fee Manager for network benefits\n   */\n  function registerMe() external onlyOwner {\n    (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n        abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n}\n\n\n"
    },
    "contracts/core/lottery/OmniDragonLotteryManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {IChainlinkVRFIntegratorV2_5} from \"../../interfaces/vrf/IChainlinkVRFIntegratorV2_5.sol\";\nimport {IOmniDragonVRFConsumerV2_5} from \"../../interfaces/vrf/IOmniDragonVRFConsumerV2_5.sol\";\n\n// Interface for local VRF callbacks\ninterface IVRFCallbackReceiver {\n  function receiveRandomWords(uint256 requestId, uint256[] memory randomWords) external;\n}\nimport {MessagingReceipt} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {MessagingFee} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {IOmniDragonPriceOracle} from \"../../interfaces/oracles/IOmniDragonPriceOracle.sol\";\nimport {IveDRAGONBoostManager} from \"../../interfaces/governance/voting/IveDRAGONBoostManager.sol\";\n\n// ============ INTERFACES ============\n\ninterface IveDRAGONToken {\n  function lockedEnd(address user) external view returns (uint256);\n  function balanceOf(address user) external view returns (uint256);\n  function totalSupply() external view returns (uint256);\n}\n\n// ============ INTERFACES ============\n\ninterface IDragonJackpotVault {\n  function getJackpotBalance() external view returns (uint256 balance);\n  function payJackpot(address winner, uint256 amount) external;\n  function getLastWinTime() external view returns (uint256 timestamp);\n}\n\n/**\n * @title OmniDragonLotteryManager\n * @author 0xakita.eth\n * @dev Manages instantaneous per-swap lottery system for OmniDragon ecosystem\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n *\n * FEATURES:\n * - Per-swap lottery entries with linear probability scaling\n * - veDRAGON boost integration using Curve Finance formula\n * - Three secure VRF randomness sources: Local VRF, Cross-chain VRF, and Provider randomness\n * - Position-based boost capping to prevent exploitation\n * - Rate limiting and DoS protection\n * - Pull payment mechanism for failed prize transfers\n *\n * SECURITY:\n * - All randomness sources are cryptographically secure (VRF only)\n * - No exploitable pseudo-randomness functions\n * - ReentrancyGuard protection on all external functions\n * - Comprehensive access control system\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract OmniDragonLotteryManager is Ownable, ReentrancyGuard, IVRFCallbackReceiver {\n  using SafeERC20 for IERC20;\n  using Address for address payable;\n\n  // ============ CONSTANTS ============\n\n  uint256 public constant MIN_SWAP_INTERVAL = 7; // 7 seconds between swaps per user to prevent spam\n  uint256 public constant MAX_BOOST_BPS = 25000; // 2.5x boost maximum\n  uint256 public constant MAX_WIN_PROBABILITY_PPM = 100000; // 10% maximum win probability (100,000 PPM)\n\n  // Instant lottery configuration (USD-based with 6 decimals)\n  uint256 public constant MIN_SWAP_USD = 10e6; // $10 USD minimum\n  uint256 public constant MAX_PROBABILITY_SWAP_USD = 10000e6; // $10,000 USD for max probability (not a trade limit)\n  uint256 public constant MIN_WIN_CHANCE_PPM = 40; // 0.004% (40 parts per million) at $10\n  uint256 public constant MAX_WIN_CHANCE_PPM = 40000; // 4% (40,000 parts per million) at $10,000+\n\n  // Using Parts Per Million (PPM) for precise probability control\n  // 1 PPM = 0.0001% = 1/1,000,000\n  // 40 PPM = 0.004%, 40,000 PPM = 4%\n\n  // veDRAGON boost configuration\n  uint256 public constant BOOST_PRECISION = 1e18;\n  uint256 public constant MAX_BOOST = 25e17; // 2.5x maximum boost\n  uint256 public constant MIN_BOOST = 1e18; // 1.0x minimum boost (no boost)\n\n  // ============ ENUMS ============\n\n  enum RandomnessSource {\n    LOCAL_VRF, // Local: Direct Chainlink VRF\n    CROSS_CHAIN_VRF // Cross-chain: Chainlink VRF via LayerZero\n  }\n\n  // ============ STRUCTS ============\n\n  struct InstantLotteryConfig {\n    uint256 baseWinProbability; // Base probability in PPM (parts per million) - UNUSED, kept for compatibility\n    uint256 minSwapAmount; // Minimum swap amount to qualify (in USD, scaled by 1e6)\n    uint256 rewardPercentage; // Percentage of jackpot as reward (in basis points)\n    bool isActive;\n    bool useVRFForInstant; // Whether to use VRF for instant lotteries (recommended)\n  }\n\n  struct UserStats {\n    uint256 totalSwaps;\n    uint256 totalVolume;\n    uint256 totalWins;\n    uint256 totalRewards;\n    uint256 lastSwapTimestamp;\n  }\n\n  struct PendingLotteryEntry {\n    address user;\n    uint256 swapAmountUSD;\n    uint256 winProbability;\n    uint256 timestamp;\n    bool fulfilled;\n    RandomnessSource randomnessSource;\n  }\n\n  // Constants for state growth management\n  uint256 public constant MAX_PENDING_ENTRY_AGE = 24 hours; // Max age before entry can be cleaned up\n  uint256 public constant CLEANUP_BATCH_SIZE = 50; // Max entries to clean in one transaction\n\n  // ============ STATE VARIABLES ============\n\n  // Core dependencies\n  IERC20 public veDRAGONToken;\n  IERC20 public redDRAGONToken;\n  IveDRAGONBoostManager public veDRAGONBoostManager;\n\n  // VRF integrations\n  IChainlinkVRFIntegratorV2_5 public vrfIntegrator;\n  IOmniDragonVRFConsumerV2_5 public localVRFConsumer;\n  IDragonJackpotVault public jackpotVault;\n\n  // Chain-specific multiplier\n  uint256 public chainMultiplier = 1e18; // 1.0x by default\n\n  // Market infrastructure integration\n  IOmniDragonPriceOracle public priceOracle;\n  uint256 public immutable CHAIN_ID;\n\n  // Prize configuration removed - rewards are now dynamic based on jackpot vault balance\n\n  // Rate limiting\n  mapping(address => uint256) public lastSwapTime;\n\n  // Access control\n  mapping(address => bool) public authorizedSwapContracts;\n\n  // Lottery state\n  mapping(uint256 => PendingLotteryEntry) public pendingEntries;\n  mapping(address => UserStats) public userStats;\n\n  // Statistics\n  uint256 public totalLotteryEntries;\n  uint256 public totalPrizesWon;\n  uint256 public totalPrizesDistributed;\n\n  InstantLotteryConfig public instantLotteryConfig;\n\n  // Oracle integration\n  IERC20 public dragonToken;\n\n  // ============ EVENTS ============\n\n  event InstantLotteryProcessed(address indexed user, uint256 swapAmount, bool won, uint256 reward);\n  event InstantLotteryEntered(\n    address indexed user,\n    uint256 swapAmountUSD,\n    uint256 winChancePPM,\n    uint256 boostedWinChancePPM,\n    uint256 randomnessId\n  );\n  event LotteryEntryCreated(address indexed user, uint256 swapAmountUSD, uint256 winProbability, uint256 vrfRequestId);\n  event RandomnessRequested(uint256 indexed requestId, address indexed user, RandomnessSource source);\n  event RandomnessFulfilled(uint256 indexed requestId, uint256 randomness, RandomnessSource source);\n\n  // Pull payment events\n  event PrizeClaimable(address indexed winner, uint256 amount);\n  event PrizeClaimed(address indexed winner, uint256 amount);\n  event PrizeTransferFailed(address indexed winner, uint256 amount);\n\n  // Configuration events\n  event InstantLotteryConfigured(\n    uint256 baseWinProbability,\n    uint256 minSwapAmount,\n    uint256 rewardPercentage,\n    bool isActive\n  );\n  event SwapContractAuthorized(address indexed swapContract, bool authorized);\n  event LotteryManagerInitialized(address jackpotVault, address veDRAGONToken);\n  event PriceOracleUpdated(address indexed newPriceOracle);\n  event ChainMultiplierUpdated(uint256 oldMultiplier, uint256 newMultiplier);\n  event RedDRAGONTokenUpdated(address indexed redDRAGONToken);\n  // Fixed prize events removed - rewards are now purely dynamic\n\n  // ============ CONSTRUCTOR ============\n\n  constructor(\n    address _jackpotVault,\n    address _veDRAGONToken,\n    address _priceOracle,\n    uint256 _chainId\n  ) Ownable(msg.sender) {\n    require(_jackpotVault != address(0), \"Invalid jackpot vault\");\n    require(_veDRAGONToken != address(0), \"Invalid veDRAGON token\");\n    require(_priceOracle != address(0), \"Invalid price oracle\");\n\n    jackpotVault = IDragonJackpotVault(_jackpotVault);\n    veDRAGONToken = IERC20(_veDRAGONToken);\n    priceOracle = IOmniDragonPriceOracle(_priceOracle);\n    // veDRAGONBoostManager will be set via setter function after deployment\n\n    CHAIN_ID = _chainId;\n\n    // Initialize instant lottery config using PPM constants\n    instantLotteryConfig = InstantLotteryConfig({\n      baseWinProbability: MIN_WIN_CHANCE_PPM,\n      minSwapAmount: MIN_SWAP_USD,\n      rewardPercentage: 6900, // 69% of jackpot\n      isActive: true,\n      useVRFForInstant: true\n    });\n\n    emit LotteryManagerInitialized(_jackpotVault, _veDRAGONToken);\n  }\n\n  // ============ MODIFIERS ============\n\n  modifier onlyAuthorizedSwapContract() {\n    require(authorizedSwapContracts[msg.sender], \"Unauthorized swap contract\");\n    _;\n  }\n\n  modifier rateLimited(address user) {\n    require(block.timestamp >= lastSwapTime[user] + MIN_SWAP_INTERVAL, \"Swap too frequent\");\n    lastSwapTime[user] = block.timestamp;\n    _;\n  }\n\n  // ============ ADMIN FUNCTIONS ============\n\n  function setVRFIntegrator(address _vrfIntegrator) external onlyOwner {\n    vrfIntegrator = IChainlinkVRFIntegratorV2_5(_vrfIntegrator);\n\n    // Auto-authorize this contract with the VRF integrator if possible\n    if (_vrfIntegrator != address(0)) {\n      try IChainlinkVRFIntegratorV2_5(_vrfIntegrator).setAuthorizedCaller(address(this), true) {\n        // Successfully authorized\n      } catch {\n        // Authorization failed - owner will need to authorize manually\n      }\n    }\n  }\n\n  function setLocalVRFConsumer(address _localVRFConsumer) external onlyOwner {\n    localVRFConsumer = IOmniDragonVRFConsumerV2_5(_localVRFConsumer);\n\n    // Auto-authorize this contract with the local VRF consumer if possible\n    if (_localVRFConsumer != address(0)) {\n      try IOmniDragonVRFConsumerV2_5(_localVRFConsumer).setLocalCallerAuthorization(address(this), true) {\n        // Successfully authorized\n      } catch {\n        // Authorization failed - owner will need to authorize manually\n      }\n    }\n  }\n\n  function setJackpotVault(address _jackpotVault) external onlyOwner {\n    require(_jackpotVault != address(0), \"Invalid jackpot vault\");\n    jackpotVault = IDragonJackpotVault(_jackpotVault);\n  }\n\n  function setPriceOracle(address _priceOracle) external onlyOwner {\n    priceOracle = IOmniDragonPriceOracle(_priceOracle);\n    emit PriceOracleUpdated(_priceOracle);\n  }\n\n  function setChainMultiplier(uint256 _chainMultiplier) external onlyOwner {\n    require(_chainMultiplier > 0, \"Invalid chain multiplier\");\n    uint256 oldMultiplier = chainMultiplier;\n    chainMultiplier = _chainMultiplier;\n    emit ChainMultiplierUpdated(oldMultiplier, _chainMultiplier);\n  }\n\n  function setRedDRAGONToken(address _redDRAGONToken) external onlyOwner {\n    require(_redDRAGONToken != address(0), \"Invalid redDRAGON token\");\n    redDRAGONToken = IERC20(_redDRAGONToken);\n    emit RedDRAGONTokenUpdated(_redDRAGONToken);\n  }\n\n  function setVeDRAGONBoostManager(address _veDRAGONBoostManager) external onlyOwner {\n    require(_veDRAGONBoostManager != address(0), \"Invalid veDRAGON boost manager\");\n    veDRAGONBoostManager = IveDRAGONBoostManager(_veDRAGONBoostManager);\n  }\n\n  function setAuthorizedSwapContract(address swapContract, bool authorized) external onlyOwner {\n    require(swapContract != address(0), \"Invalid swap contract\");\n    authorizedSwapContracts[swapContract] = authorized;\n    emit SwapContractAuthorized(swapContract, authorized);\n  }\n\n  function configureInstantLottery(\n    uint256 _baseWinProbability,\n    uint256 _minSwapAmount,\n    uint256 _rewardPercentage,\n    bool _isActive,\n    bool _useVRFForInstant\n  ) external onlyOwner {\n    require(_baseWinProbability <= 10000, \"Invalid base win probability\");\n    require(_rewardPercentage <= 10000, \"Invalid reward percentage\");\n\n    instantLotteryConfig = InstantLotteryConfig({\n      baseWinProbability: _baseWinProbability,\n      minSwapAmount: _minSwapAmount,\n      rewardPercentage: _rewardPercentage,\n      isActive: _isActive,\n      useVRFForInstant: _useVRFForInstant\n    });\n\n    emit InstantLotteryConfigured(_baseWinProbability, _minSwapAmount, _rewardPercentage, _isActive);\n  }\n\n  // ============ LOTTERY FUNCTIONS ============\n\n  /**\n   * @notice Process lottery entry from omniDRAGON swap (backward compatibility)\n   * @param user Address of the user performing the swap\n   * @param amount DRAGON token amount (18 decimals)\n   */\n  function processEntry(address user, uint256 amount) external nonReentrant onlyAuthorizedSwapContract {\n    // Only process lottery if we have a price oracle and can get accurate USD conversion\n    if (address(priceOracle) == address(0)) {\n      // No price oracle configured - swap succeeds but no lottery entry\n      return;\n    }\n\n    uint256 swapAmountUSD;\n    bool priceObtained = false;\n\n    try priceOracle.getAggregatedPrice() returns (int256 price, bool success, uint256 /* timestamp */) {\n      if (success && price > 0) {\n        // Convert token amount to USD using actual oracle price\n        // Price is typically in 8 decimals, amount is 18 decimals, want 6 decimals USD\n        // So: (amount * price) / 1e20 = (18 + 8 - 20 = 6 decimals)\n        swapAmountUSD = (amount * uint256(price)) / 1e20;\n        priceObtained = true;\n      }\n    } catch {\n      // Oracle failed - swap succeeds but no lottery entry\n    }\n    // Only process lottery if we got a valid price and swap meets minimum threshold\n    if (priceObtained && swapAmountUSD >= MIN_SWAP_USD) {\n      // Process the instant lottery with actual USD amount from price oracle\n      processInstantLottery(user, swapAmountUSD);\n    }\n    // If no valid price or below minimum, swap succeeds but no lottery entry is created\n  }\n\n  /**\n   * @notice Process swap lottery - handles all lottery logic including USD calculation\n   * @param trader Address of the trader\n   * @param tokenIn Address of input token  \n   * @param amountIn Amount of input tokens\n   * @param swapValueUSD USD value (0 = calculate internally using oracle)\n   * @return entryId Generated lottery entry ID\n   */\n  function processSwapLottery(\n    address trader,\n    address tokenIn,\n    uint256 amountIn,\n    uint256 swapValueUSD\n  ) external nonReentrant onlyAuthorizedSwapContract returns (uint256 entryId) {\n    require(trader != address(0), \"Invalid trader address\");\n    require(tokenIn != address(0), \"Invalid token address\");\n    require(amountIn > 0, \"Invalid amount\");\n\n    // Only process lottery if we have a price oracle and can get accurate USD conversion\n    if (address(priceOracle) == address(0)) {\n      // No price oracle configured - swap succeeds but no lottery entry\n      return 0;\n    }\n\n    uint256 finalSwapAmountUSD = swapValueUSD;\n    bool priceObtained = false;\n\n    // If swapValueUSD is 0, calculate USD value using oracle\n    if (swapValueUSD == 0) {\n      try priceOracle.getAggregatedPrice() returns (int256 price, bool success, uint256 /* timestamp */) {\n        if (success && price > 0) {\n          // Convert token amount to USD using actual oracle price\n          // Price is typically in 8 decimals, amount is 18 decimals, want 6 decimals USD\n          // So: (amountIn * price) / 1e20 = (18 + 8 - 20 = 6 decimals)\n          finalSwapAmountUSD = (amountIn * uint256(price)) / 1e20;\n          priceObtained = true;\n        }\n      } catch {\n        // Oracle failed - swap succeeds but no lottery entry\n        return 0;\n      }\n    } else {\n      // Use provided USD value\n      priceObtained = true;\n    }\n\n    // Only process lottery if we got a valid price and swap meets minimum threshold\n    if (priceObtained && finalSwapAmountUSD >= MIN_SWAP_USD) {\n      // Process the instant lottery with actual USD amount\n      processInstantLottery(trader, finalSwapAmountUSD);\n      \n      // Return a non-zero entry ID to indicate success\n      return totalLotteryEntries;\n    }\n\n    // If no valid price or below minimum, swap succeeds but no lottery entry is created\n    return 0;\n  }\n\n  /**\n   * @notice Process swap lottery and forward native fee for cross-chain VRF\n   * @dev Use this on chains without local VRF (e.g., Sonic). Caller must be authorized and send\n   *      sufficient native token to cover the VRF integrator fee. Any revert here preserves security\n   *      by never falling back to insecure randomness.\n   */\n  function processSwapLotteryPayable(\n    address trader,\n    address tokenIn,\n    uint256 amountIn,\n    uint256 swapValueUSD\n  ) external payable nonReentrant onlyAuthorizedSwapContract returns (uint256 entryId) {\n    require(trader != address(0), \"Invalid trader address\");\n    require(tokenIn != address(0), \"Invalid token address\");\n    require(amountIn > 0, \"Invalid amount\");\n\n    // Require a price oracle\n    if (address(priceOracle) == address(0)) {\n      return 0;\n    }\n\n    uint256 finalSwapAmountUSD = swapValueUSD;\n    bool priceObtained = false;\n\n    // If swapValueUSD is 0, calculate USD value using oracle\n    if (swapValueUSD == 0) {\n      try priceOracle.getAggregatedPrice() returns (int256 price, bool success, uint256 /* ts */) {\n        if (success && price > 0) {\n          finalSwapAmountUSD = (amountIn * uint256(price)) / 1e20;\n          priceObtained = true;\n        }\n      } catch {\n        return 0;\n      }\n    } else {\n      priceObtained = true;\n    }\n\n    if (!(priceObtained && finalSwapAmountUSD >= MIN_SWAP_USD)) {\n      return 0;\n    }\n\n    require(instantLotteryConfig.isActive, \"Instant lottery not active\");\n    require(address(vrfIntegrator) != address(0), \"VRF integrator not set\");\n\n    // Compute win chance\n    uint256 baseProbability = _calculateLinearWinChance(finalSwapAmountUSD);\n    uint256 boostedProbability = _applyVeDRAGONBoost(trader, baseProbability, finalSwapAmountUSD);\n\n    // Get quoted fee and forward only the required amount; if msg.value is 0, try using contract balance (sponsored)\n    uint256 requestId;\n    {\n      // Expect integrator to sponsor the fee from its own balance using new API\n      try vrfIntegrator.requestRandomWords(30110) returns (MessagingReceipt memory /* r */, uint64 sequence) {\n        requestId = uint256(sequence);\n      } catch {\n        return 0; // best-effort\n      }\n    }\n    if (requestId == 0) {\n      return 0; // best-effort\n    }\n\n    // Store pending entry\n    pendingEntries[requestId] = PendingLotteryEntry({\n      user: trader,\n      swapAmountUSD: finalSwapAmountUSD,\n      winProbability: boostedProbability,\n      timestamp: block.timestamp,\n      fulfilled: false,\n      randomnessSource: RandomnessSource.CROSS_CHAIN_VRF\n    });\n\n    emit LotteryEntryCreated(trader, finalSwapAmountUSD, boostedProbability, requestId);\n    emit RandomnessRequested(requestId, trader, RandomnessSource.CROSS_CHAIN_VRF);\n\n    // Update stats\n    userStats[trader].totalSwaps++;\n    userStats[trader].totalVolume += finalSwapAmountUSD;\n    userStats[trader].lastSwapTimestamp = block.timestamp;\n    totalLotteryEntries++;\n\n    return totalLotteryEntries;\n  }\n\n  /**\n   * @notice Returns current VRF native fee for cross-chain request to Arbitrum (eid 30110)\n   */\n  function getVrfFee() external view returns (uint256) {\n    if (address(vrfIntegrator) == address(0)) return 0;\n    MessagingFee memory feeQuote = vrfIntegrator.quoteFee();\n    return feeQuote.nativeFee;\n  }\n\n  /**\n   * @notice Owner can fund this contract with native to sponsor VRF fees\n   */\n  function fundVrf() external payable onlyOwner {}\n\n  /**\n   * @notice Process instant lottery for a swap transaction\n   * @param user User who made the swap\n   * @param swapAmountUSD Swap amount in USD (6 decimals)\n   * @dev Called by authorized swap contracts only\n   */\n  function processInstantLottery(\n    address user,\n    uint256 swapAmountUSD\n  ) public onlyAuthorizedSwapContract rateLimited(user) {\n    require(user != address(0), \"Invalid user address\");\n    require(swapAmountUSD >= MIN_SWAP_USD, \"Swap amount too low\");\n    require(instantLotteryConfig.isActive, \"Instant lottery not active\");\n\n    // Update user stats\n    userStats[user].totalSwaps++;\n    userStats[user].totalVolume += swapAmountUSD;\n    userStats[user].lastSwapTimestamp = block.timestamp;\n    totalLotteryEntries++;\n\n    // Calculate win probability (no capping needed since we allow any trade size)\n    uint256 winChancePPM = _calculateLinearWinChance(swapAmountUSD);\n\n    // Apply veDRAGON boost\n    uint256 boostedWinChancePPM = _applyVeDRAGONBoost(user, winChancePPM, swapAmountUSD);\n\n    if (instantLotteryConfig.useVRFForInstant) {\n      // Request VRF randomness (best-effort). If unavailable, skip silently\n      uint256 randomnessId = _requestVRFForInstantLottery(user, swapAmountUSD, boostedWinChancePPM);\n      if (randomnessId == 0) {\n        return;\n      }\n      emit InstantLotteryEntered(user, swapAmountUSD, winChancePPM, boostedWinChancePPM, randomnessId);\n    } else {\n      // SECURITY: Non-VRF mode disabled for security - all randomness must be VRF-based\n      revert(\"Non-VRF mode disabled for security - configure VRF sources\");\n    }\n  }\n\n  /**\n   * @dev Request VRF randomness for instant lottery with fallback sources\n   * @param user The user who made the swap\n   * @param swapAmountUSD The swap amount in USD\n   * @param winProbability The calculated win probability\n   * @return requestId The randomness request ID\n   */\n  function _requestVRFForInstantLottery(\n    address user,\n    uint256 swapAmountUSD,\n    uint256 winProbability\n  ) internal returns (uint256 requestId) {\n    RandomnessSource source;\n\n    // Try Local VRF first (fastest on Arbitrum)\n    if (address(localVRFConsumer) != address(0)) {\n      try localVRFConsumer.requestRandomWordsLocal() returns (uint256 localRequestId) {\n        requestId = localRequestId;\n        source = RandomnessSource.LOCAL_VRF;\n      } catch {\n        // Local VRF failed, try next option\n      }\n    }\n\n    // If local VRF failed, try cross-chain VRF\n    if (requestId == 0 && address(vrfIntegrator) != address(0)) {\n      // Request cross-chain VRF; integrator sponsors fee from its own balance\n      try vrfIntegrator.requestRandomWords(30110) returns (\n        MessagingReceipt memory /* receipt */,\n        uint64 sequence\n      ) {\n        requestId = uint256(sequence);\n        source = RandomnessSource.CROSS_CHAIN_VRF;\n      } catch {\n        // Cross-chain VRF also failed\n      }\n    }\n\n    // Removed randomnessProvider fallback - using only Chainlink VRF sources\n\n    if (requestId == 0) {\n      // All VRF sources failed - best-effort: do not revert; caller may skip lottery\n      return 0;\n    }\n\n    // Store pending lottery entry\n    pendingEntries[requestId] = PendingLotteryEntry({\n      user: user,\n      swapAmountUSD: swapAmountUSD,\n      winProbability: winProbability,\n      timestamp: block.timestamp,\n      fulfilled: false,\n      randomnessSource: source\n    });\n\n    emit LotteryEntryCreated(user, swapAmountUSD, winProbability, requestId);\n    emit RandomnessRequested(requestId, user, source);\n\n    return requestId;\n  }\n\n  /**\n   * @notice Callback function for local VRF requests\n   * @dev Called by the local VRF consumer when randomness is ready\n   * Added reentrancy protection for distribution safety\n   */\n  function receiveRandomWords(uint256 requestId, uint256[] memory randomWords) external nonReentrant {\n    require(msg.sender == address(localVRFConsumer), \"Only local VRF consumer\");\n    require(randomWords.length > 0, \"No random words provided\");\n\n    _processVRFCallback(requestId, randomWords[0], RandomnessSource.LOCAL_VRF);\n  }\n\n  /**\n   * @notice Callback function for cross-chain VRF requests\n   * @dev Called by the VRF integrator when cross-chain randomness is ready\n   * Added reentrancy protection for distribution safety\n   */\n  function receiveRandomWords(uint256[] memory randomWords, uint256 sequence) external nonReentrant {\n    require(msg.sender == address(vrfIntegrator), \"Only VRF integrator\");\n    require(randomWords.length > 0, \"No random words provided\");\n\n    _processVRFCallback(sequence, randomWords[0], RandomnessSource.CROSS_CHAIN_VRF);\n  }\n\n  /**\n   * @dev Process VRF callback and determine lottery outcome\n   * @param requestId The VRF request ID\n   * @param randomness The random number from VRF\n   * @param source The randomness source that provided the callback\n   */\n  function _processVRFCallback(uint256 requestId, uint256 randomness, RandomnessSource source) internal {\n    PendingLotteryEntry storage entry = pendingEntries[requestId];\n    require(entry.user != address(0), \"Invalid request ID\");\n    require(!entry.fulfilled, \"Entry already fulfilled\");\n    require(entry.randomnessSource == source, \"Wrong randomness source\");\n\n    // Mark as fulfilled\n    entry.fulfilled = true;\n\n    // Process the lottery result\n    _processLotteryResult(entry.user, entry.swapAmountUSD, entry.winProbability, randomness);\n\n    emit RandomnessFulfilled(requestId, randomness, source);\n\n    // Clean up storage to save gas\n    delete pendingEntries[requestId];\n  }\n\n  /**\n   * @dev Process lottery result and distribute rewards if won\n   * @param user The user who entered the lottery\n   * @param swapAmountUSD The swap amount in USD\n   * @param winProbability The win probability in basis points\n   * @param randomness The random number to determine outcome\n   */\n  function _processLotteryResult(\n    address user,\n    uint256 swapAmountUSD,\n    uint256 winProbability,\n    uint256 randomness\n  ) internal {\n    // Determine if user won (randomness % 1000000 < winProbability) - using PPM\n    bool won = (randomness % 1000000) < winProbability;\n\n    uint256 reward = 0;\n    if (won) {\n      // Calculate reward from jackpot\n      reward = _calculateInstantLotteryReward(swapAmountUSD);\n\n      if (reward > 0) {\n        _distributeInstantLotteryReward(user, reward);\n\n        // Update statistics\n        userStats[user].totalWins++;\n        userStats[user].totalRewards += reward;\n        totalPrizesWon++;\n        totalPrizesDistributed += reward;\n      }\n    }\n\n    emit InstantLotteryProcessed(user, swapAmountUSD, won, reward);\n  }\n\n  /**\n   * @dev Calculate instant lottery reward based on jackpot and configuration\n   * @return reward The calculated reward amount\n   */\n  function _calculateInstantLotteryReward(uint256 /* swapAmountUSD */) internal view returns (uint256 reward) {\n    if (address(jackpotVault) == address(0)) {\n      return 0;\n    }\n\n    uint256 currentJackpot;\n    try jackpotVault.getJackpotBalance() returns (uint256 jackpot) {\n      currentJackpot = jackpot;\n    } catch {\n      return 0;\n    }\n    if (currentJackpot == 0) {\n      return 0;\n    }\n\n    reward = (currentJackpot * instantLotteryConfig.rewardPercentage) / 10000;\n    return reward;\n  }\n\n  /**\n   * @dev Distribute instant lottery reward to winner\n   * @param winner The winner address\n   * @param reward The reward amount\n   * @dev Pure coordinator - delegates all fund handling to other contracts\n   */\n  function _distributeInstantLotteryReward(address winner, uint256 reward) internal {\n    if (address(jackpotVault) == address(0) || reward == 0) {\n      return;\n    }\n    try jackpotVault.payJackpot(winner, reward) {\n      emit InstantLotteryProcessed(winner, 0, true, reward);\n    } catch {\n      emit PrizeTransferFailed(winner, reward);\n    }\n  }\n\n  /**\n   * @dev Calculate linear win chance based on swap amount\n   * @param swapAmountUSD Swap amount in USD (6 decimals)\n   * @return winChancePPM Win chance in parts per million (capped at MAX_WIN_CHANCE_PPM for swaps >= $10,000)\n   */\n  function _calculateLinearWinChance(uint256 swapAmountUSD) internal pure returns (uint256 winChancePPM) {\n    if (swapAmountUSD < MIN_SWAP_USD) {\n      return 0;\n    }\n\n    // Cap probability at $10,000 level, but allow any trade size\n    if (swapAmountUSD >= MAX_PROBABILITY_SWAP_USD) {\n      return MAX_WIN_CHANCE_PPM;\n    }\n\n    // Linear interpolation between MIN_WIN_CHANCE_PPM and MAX_WIN_CHANCE_PPM\n    uint256 amountRange = MAX_PROBABILITY_SWAP_USD - MIN_SWAP_USD;\n    uint256 chanceRange = MAX_WIN_CHANCE_PPM - MIN_WIN_CHANCE_PPM;\n    uint256 amountDelta = swapAmountUSD - MIN_SWAP_USD;\n\n    winChancePPM = MIN_WIN_CHANCE_PPM + (chanceRange * amountDelta) / amountRange;\n\n    return winChancePPM;\n  }\n\n  /**\n   * @dev Apply veDRAGON boost to base win probability using boost manager\n   * @param user User address to calculate boost for\n   * @param baseProbability Base win probability in PPM\n   * @return boostedProbability Boosted probability (capped at MAX_WIN_PROBABILITY_PPM)\n   */\n  function _applyVeDRAGONBoost(\n    address user,\n    uint256 baseProbability,\n    uint256 /* swapAmount */\n  ) internal view returns (uint256) {\n    // If boost manager not configured, fallback to simple calculation\n    if (address(veDRAGONBoostManager) == address(0)) {\n      return _applyVeDRAGONBoostFallback(user, baseProbability);\n    }\n\n    // Use the sophisticated boost manager calculation\n    uint256 boostMultiplierBPS = veDRAGONBoostManager.calculateBoost(user); // Returns in basis points (10000 = 100%)\n    \n    // Convert from basis points to our internal precision\n    uint256 boostMultiplier = (boostMultiplierBPS * BOOST_PRECISION) / 10000;\n\n    // Apply boost\n    uint256 boostedProbability = (baseProbability * boostMultiplier) / BOOST_PRECISION;\n\n    // Ensure we don't exceed the maximum win probability\n    return boostedProbability > MAX_WIN_PROBABILITY_PPM ? MAX_WIN_PROBABILITY_PPM : boostedProbability;\n  }\n\n  /**\n   * @dev Fallback veDRAGON boost calculation when boost manager is not available\n   * @param user User address to calculate boost for\n   * @param baseProbability Base win probability in PPM\n   * @return boostedProbability Boosted probability\n   */\n  function _applyVeDRAGONBoostFallback(\n    address user,\n    uint256 baseProbability\n  ) internal view returns (uint256) {\n    // If tokens not configured, return base probability\n    if (address(veDRAGONToken) == address(0) || address(redDRAGONToken) == address(0)) {\n      return baseProbability;\n    }\n\n    // Get user's balances\n    uint256 userRedDRAGON = redDRAGONToken.balanceOf(user);\n    uint256 userVeDRAGON = veDRAGONToken.balanceOf(user);\n\n    // If user has no tokens, return base probability\n    if (userRedDRAGON == 0 && userVeDRAGON == 0) {\n      return baseProbability;\n    }\n\n    // Get total supplies\n    uint256 totalRedDRAGON = redDRAGONToken.totalSupply();\n    uint256 totalVeDRAGON = veDRAGONToken.totalSupply();\n\n    if (totalRedDRAGON == 0) {\n      return baseProbability;\n    }\n\n    // Simple boost calculation: 1.0x to 2.5x based on token holdings\n    uint256 userTotalTokens = userRedDRAGON + userVeDRAGON;\n    uint256 totalTokens = totalRedDRAGON + totalVeDRAGON;\n\n    if (totalTokens == 0) {\n      return baseProbability;\n    }\n\n    // Calculate boost multiplier (1.0x to 2.5x)\n    uint256 boostMultiplier = BOOST_PRECISION + (15e17 * userTotalTokens) / totalTokens; // 1.0 + 1.5 * ratio\n\n    // Cap at maximum boost\n    if (boostMultiplier > MAX_BOOST) {\n      boostMultiplier = MAX_BOOST;\n    }\n\n    // Apply boost\n    uint256 boostedProbability = (baseProbability * boostMultiplier) / BOOST_PRECISION;\n\n    // Ensure we don't exceed the maximum win probability\n    return boostedProbability > MAX_WIN_PROBABILITY_PPM ? MAX_WIN_PROBABILITY_PPM : boostedProbability;\n  }\n\n  // ============ VIEW FUNCTIONS ============\n\n  /**\n   * @notice Get instant lottery configuration\n   */\n  function getInstantLotteryConfig()\n    external\n    view\n    returns (\n      uint256 baseWinProbability,\n      uint256 minSwapAmount,\n      uint256 rewardPercentage,\n      bool isActive,\n      bool useVRFForInstant\n    )\n  {\n    return (\n      instantLotteryConfig.baseWinProbability,\n      instantLotteryConfig.minSwapAmount,\n      instantLotteryConfig.rewardPercentage,\n      instantLotteryConfig.isActive,\n      instantLotteryConfig.useVRFForInstant\n    );\n  }\n\n  /**\n   * @notice Get user statistics\n   */\n  function getUserStats(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalSwaps,\n      uint256 totalVolume,\n      uint256 totalWins,\n      uint256 totalRewards,\n      uint256 lastSwapTimestamp\n    )\n  {\n    UserStats memory stats = userStats[user];\n    return (stats.totalSwaps, stats.totalVolume, stats.totalWins, stats.totalRewards, stats.lastSwapTimestamp);\n  }\n\n  /**\n   * @notice Get pending lottery entry details\n   */\n  function getPendingEntry(\n    uint256 requestId\n  )\n    external\n    view\n    returns (\n      address user,\n      uint256 swapAmountUSD,\n      uint256 winProbability,\n      uint256 timestamp,\n      bool fulfilled,\n      RandomnessSource randomnessSource\n    )\n  {\n    PendingLotteryEntry memory entry = pendingEntries[requestId];\n    return (\n      entry.user,\n      entry.swapAmountUSD,\n      entry.winProbability,\n      entry.timestamp,\n      entry.fulfilled,\n      entry.randomnessSource\n    );\n  }\n\n  /**\n   * @notice Calculate win probability for a given swap amount and user\n   */\n  function calculateWinProbability(\n    address user,\n    uint256 swapAmountUSD\n  ) external view returns (uint256 baseProbability, uint256 boostedProbability) {\n    // No capping needed since we allow any trade size but cap probability at $10k level\n    baseProbability = _calculateLinearWinChance(swapAmountUSD);\n    boostedProbability = _applyVeDRAGONBoost(user, baseProbability, swapAmountUSD);\n\n    // Cap at maximum (already handled in _applyVeDRAGONBoost)\n    if (boostedProbability > MAX_WIN_PROBABILITY_PPM) {\n      boostedProbability = MAX_WIN_PROBABILITY_PPM;\n    }\n  }\n\n  /**\n   * @notice Get current jackpot amount\n   */\n  function getCurrentJackpot() external view returns (uint256) {\n    if (address(jackpotVault) == address(0)) {\n      return 0;\n    }\n    try jackpotVault.getJackpotBalance() returns (uint256 bal) {\n      return bal;\n    } catch {\n      return 0;\n    }\n  }\n\n  // ============ DEPRECATED PRIZE CLAIM FUNCTIONS ============\n  // These functions are kept for interface compatibility but are no longer used\n  // All prizes are distributed immediately through jackpot distributor/vault\n\n  /**\n   * @notice Get unclaimed prizes for a user\n   * @dev Always returns 0 - included for interface compatibility\n   * @return amount Always returns 0\n   */\n  function getUnclaimedPrizes(address /* user */) external pure returns (uint256 amount) {\n    return 0;\n  }\n\n  /**\n   * @notice DEPRECATED - No-op as lottery manager no longer holds funds\n   * @dev Reverts to indicate this function is no longer used\n   */\n  function claimPrize() external pure {\n    revert(\"Function deprecated - lottery manager does not hold funds\");\n  }\n\n  /**\n   * @notice DEPRECATED - Returns 0 as lottery manager no longer holds funds\n   * @return total Always returns 0\n   */\n  function getTotalUnclaimedPrizes() external pure returns (uint256 total) {\n    return 0;\n  }\n\n  // ============ ORACLE INTEGRATION ============\n\n  /**\n   * @notice Set the DRAGON token address for price conversions\n   * @param _dragonToken Address of the DRAGON token\n   */\n  function setDragonToken(address _dragonToken) external onlyOwner {\n    require(_dragonToken != address(0), \"Invalid dragon token\");\n    dragonToken = IERC20(_dragonToken);\n  }\n\n  /**\n   * @notice Get current DRAGON price from oracle\n   * @return price Price in USD (18 decimals)\n   * @return isValid Whether the price is valid\n   */\n  function _getDragonPriceUSD() internal view returns (int256 price, bool isValid) {\n    if (address(priceOracle) == address(0)) return (0, false);\n    \n    try priceOracle.getAggregatedPrice() returns (\n      int256 _price, \n      bool _success, \n      uint256 /* timestamp */\n    ) {\n      return (_price, _success);\n    } catch {\n      return (0, false);\n    }\n  }\n\n  /**\n   * @notice Convert DRAGON amount to USD (6 decimals)\n   * @param dragonAmount Amount of DRAGON tokens (18 decimals)\n   * @return usdAmount USD amount (6 decimals)\n   */\n  function _convertDragonToUSD(uint256 dragonAmount) internal view returns (uint256 usdAmount) {\n    if (dragonAmount == 0) return 0;\n    \n    (int256 price, bool isValid) = _getDragonPriceUSD();\n    if (!isValid || price <= 0) return 0;\n    \n    // Convert: DRAGON (18 decimals) * Price (18 decimals) / 1e30 = USD (6 decimals)\n    return (dragonAmount * uint256(price)) / 1e30;\n  }\n\n  /**\n   * @notice Process lottery entry with DRAGON amount (called by omniDRAGON token)\n   * @param user User address\n   * @param dragonAmount Amount of DRAGON tokens involved in swap\n   */\n  function processEntryWithDragon(address user, uint256 dragonAmount) external nonReentrant rateLimited(user) {\n    require(msg.sender == address(dragonToken), \"Only DRAGON token\");\n    require(user != address(0), \"Invalid user\");\n    require(instantLotteryConfig.isActive, \"Instant lottery not active\");\n    \n    // Convert DRAGON amount to USD\n    uint256 usdAmount = _convertDragonToUSD(dragonAmount);\n    \n    // Check minimum USD threshold\n    if (usdAmount < MIN_SWAP_USD) {\n      return; // Below minimum threshold, no lottery entry\n    }\n    \n    // Calculate win probability based on USD amount\n    (, uint256 winProbability) = this.calculateWinProbability(user, usdAmount);\n    \n    // Process the lottery entry with USD amount using secure VRF\n    if (instantLotteryConfig.useVRFForInstant) {\n      // Request VRF randomness (best-effort). If unavailable, skip silently\n      uint256 randomnessId = _requestVRFForInstantLottery(user, usdAmount, winProbability);\n      if (randomnessId == 0) {\n        return;\n      }\n      emit InstantLotteryEntered(user, usdAmount, winProbability, winProbability, randomnessId);\n    } else {\n      // SECURITY: Non-VRF mode disabled for security - all randomness must be VRF-based\n      revert(\"Non-VRF mode disabled for security - configure VRF sources\");\n    }\n    \n    // Update user statistics\n    userStats[user].totalSwaps++;\n    userStats[user].totalVolume += usdAmount;\n    userStats[user].lastSwapTimestamp = block.timestamp;\n    \n    totalLotteryEntries++;\n  }\n\n  /**\n   * @notice Get current DRAGON price in USD for external queries\n   * @return price Price in USD (18 decimals)\n   * @return isValid Whether the price is valid\n   * @return timestamp Last update timestamp\n   */\n  function getDragonPriceUSD() external view returns (int256 price, bool isValid, uint256 timestamp) {\n    if (address(priceOracle) == address(0)) return (0, false, 0);\n    return priceOracle.getAggregatedPrice();\n  }\n\n  /**\n   * @notice Convert DRAGON amount to USD for external queries\n   * @param dragonAmount Amount of DRAGON tokens (18 decimals)\n   * @return usdAmount USD amount (6 decimals)\n   */\n  function convertDragonToUSD(uint256 dragonAmount) external view returns (uint256 usdAmount) {\n    return _convertDragonToUSD(dragonAmount);\n  }\n\n  /**\n   * @notice REMOVED: Insecure instant lottery processing function\n   * @dev This function was removed due to security vulnerabilities in its randomness generation.\n   * All lottery processing now uses cryptographically secure VRF-based randomness via\n   * processInstantLottery() and _requestVRFForInstantLottery().\n   * \n   * SECURITY NOTE: The previous implementation used exploitable pseudo-randomness\n   * (block.timestamp, block.prevrandao) which could be manipulated by miners/validators.\n   * This violated the contract's security guarantees and has been eliminated.\n   */\n\n  // ========== SONIC FEEM INTEGRATION ==========\n\n  /**\n   * @dev Register my contract on Sonic FeeM\n   * @notice This registers the contract with Sonic's Fee Manager for network benefits\n   */\n  function registerMe() external onlyOwner {\n    (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n        abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n}"
    },
    "contracts/core/oracles/OmniDragonPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IChainlinkAggregator {\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n  function decimals() external view returns (uint8);\n}\n\ninterface IStdReference {\n  struct ReferenceData {\n    uint256 rate;\n    uint256 lastUpdatedBase;\n    uint256 lastUpdatedQuote;\n  }\n  function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);\n}\n\nimport \"../../interfaces/oracles/IApi3ReaderProxy.sol\";\nimport \"../../interfaces/oracles/IPyth.sol\";\nimport \"../../interfaces/oracles/PythStructs.sol\";\nimport \"../../interfaces/tokens/IUniswapV2Pair.sol\";\nimport \"../../interfaces/config/IOmniDragonRegistry.sol\";\n\n/**\n * @title OmniDragonPriceOracle\n * @author 0xakita.eth\n * @dev Robust price oracle that aggregates prices from multiple oracle sources\n *\n * This oracle supports:\n * - Chainlink price feeds\n * - Band Protocol feeds\n * - API3 dAPI feeds\n * - Pyth Network feeds\n *\n * Features:\n * - Weighted average price calculation\n * - Configurable oracle weights\n * - Smart circuit breaker protection with initialization grace period\n * - Price freshness validation\n * - Network-specific configuration\n * - Adaptive deviation thresholds\n * - Emergency price override capabilities\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract OmniDragonPriceOracle is Ownable, Pausable, ReentrancyGuard {\n  // \n  // STRUCTS AND ENUMS\n  // \n\n  struct OracleConfig {\n    address feedAddress;\n    uint256 weight;\n    bool isActive;\n    uint256 maxStaleness;\n  }\n\n  struct PriceData {\n    int256 price;\n    uint256 timestamp;\n    bool isValid;\n  }\n\n  // \n  // STATE VARIABLES\n  // \n\n  // Basic configuration\n  string public nativeSymbol;\n  string public quoteSymbol;\n  uint8 public constant DECIMALS = 18;\n\n  // Current price state\n  int256 public latestPrice;\n  uint256 public lastPriceUpdate;\n  bool public isInitialized;\n\n  // Oracle configurations\n  OracleConfig public chainlinkConfig;\n  OracleConfig public bandConfig;\n  OracleConfig public api3Config;\n  OracleConfig public pythConfig;\n\n  // Decimals configuration for API3 dAPI values (since API3 ReaderProxy doesn't expose decimals)\n  // Default assumes 18 decimals coming from the feed. Owner can update if the network feed differs\n  uint8 public api3Decimals = 18;\n\n  // Network-specific settings\n  string public bandProtocolBaseSymbol;\n  bytes32 public pythPriceId;\n\n  // Native token price feeds\n  mapping(uint256 => address) public nativeTokenPriceFeeds; // chainId => Chainlink feed\n\n  // Safety settings - now configurable\n  uint256 public maxPriceDeviation = 2000; // 20% max deviation (configurable)\n  uint256 public initializationGracePeriod = 86400; // 24 hours grace period for initialization\n  uint256 public constant DEFAULT_MAX_STALENESS = 3600; // 1 hour\n  bool public circuitBreakerActive;\n  uint256 public deploymentTime;\n\n  // Emergency controls\n  bool public emergencyMode;\n  int256 public emergencyPrice;\n\n  // LP Token pricing configuration\n  IOmniDragonRegistry public registry;\n  address public dragonToken;\n\n  //\n\n  // \n  // EVENTS\n  // \n\n  event PriceUpdated(int256 indexed newPrice, uint256 timestamp, uint256 oracleCount);\n  event OracleConfigUpdated(string indexed oracleType, address indexed feedAddress, uint256 weight);\n  event CircuitBreakerTriggered(string reason, int256 oldPrice, int256 newPrice, uint256 deviation);\n  event CircuitBreakerReset(address indexed admin);\n  event PriceInitialized(int256 initialPrice, uint256 timestamp);\n  event MaxDeviationUpdated(uint256 oldDeviation, uint256 newDeviation);\n  event EmergencyModeActivated(int256 emergencyPrice);\n  event EmergencyModeDeactivated();\n\n  // \n  // CUSTOM ERRORS\n  // \n\n  error InvalidWeights();\n  error CircuitBreakerActive();\n  error PriceDataStale();\n  error NoValidOracleData();\n  error InvalidPriceDeviation();\n  error OracleNotInitialized();\n  error EmergencyModeActive();\n  error InvalidDeviation();\n\n  // \n  // CONSTRUCTOR\n  // \n\n  constructor(\n    string memory _nativeSymbol,\n    string memory _quoteSymbol,\n    address _initialOwner,\n    address _registry,\n    address _dragonToken\n  ) Ownable(_initialOwner) {\n    nativeSymbol = _nativeSymbol;\n    quoteSymbol = _quoteSymbol;\n    deploymentTime = block.timestamp;\n    registry = IOmniDragonRegistry(_registry);\n    dragonToken = _dragonToken;\n\n    // Initialize with default weights (can be changed later)\n    chainlinkConfig = OracleConfig({\n      feedAddress: address(0),\n      weight: 4000, // 40%\n      isActive: false,\n      maxStaleness: DEFAULT_MAX_STALENESS\n    });\n\n    bandConfig = OracleConfig({\n      feedAddress: address(0),\n      weight: 3000, // 30%\n      isActive: false,\n      maxStaleness: DEFAULT_MAX_STALENESS\n    });\n\n    api3Config = OracleConfig({\n      feedAddress: address(0),\n      weight: 2000, // 20%\n      isActive: false,\n      maxStaleness: DEFAULT_MAX_STALENESS\n    });\n\n    pythConfig = OracleConfig({\n      feedAddress: address(0),\n      weight: 1000, // 10%\n      isActive: false,\n      maxStaleness: DEFAULT_MAX_STALENESS\n    });\n\n    // DON'T initialize price here - wait for proper initialization\n    latestPrice = 0;\n    lastPriceUpdate = 0;\n    isInitialized = false;\n  }\n\n  // \n  // MAIN FUNCTIONS\n  // \n\n  /**\n   * @dev Get the latest aggregated price\n   */\n  function getLatestPrice() external view returns (int256 price, uint256 timestamp) {\n    if (emergencyMode) {\n      return (emergencyPrice, block.timestamp);\n    }\n\n    if (circuitBreakerActive) revert CircuitBreakerActive();\n    if (!isInitialized) revert OracleNotInitialized();\n    if (block.timestamp - lastPriceUpdate > DEFAULT_MAX_STALENESS) revert PriceDataStale();\n\n    return (latestPrice, lastPriceUpdate);\n  }\n\n  /**\n   * @dev Get aggregated price (alternative interface for compatibility)\n   */\n  function getAggregatedPrice() external view returns (int256 price, bool success, uint256 timestamp) {\n    if (emergencyMode) {\n      return (emergencyPrice, true, block.timestamp);\n    }\n\n    if (circuitBreakerActive || !isInitialized) {\n      return (0, false, 0);\n    }\n\n    if (block.timestamp - lastPriceUpdate > DEFAULT_MAX_STALENESS) {\n      return (0, false, 0);\n    }\n\n    return (latestPrice, true, lastPriceUpdate);\n  }\n\n  /**\n   * @notice Get the native token price (e.g., SONIC/USD, ETH/USD)\n   * @return price The price of native token in USD (8 decimals)\n   * @return isValid Whether the price is valid\n   * @return timestamp The timestamp of the price\n   */\n  function getNativeTokenPrice() external view returns (int256 price, bool isValid, uint256 timestamp) {\n    address feed = nativeTokenPriceFeeds[block.chainid];\n    if (feed == address(0)) {\n      // No feed configured for this chain\n      return (0, false, 0);\n    }\n\n    try IChainlinkAggregator(feed).latestRoundData() returns (\n      uint80,\n      int256 _price,\n      uint256,\n      uint256 _timestamp,\n      uint80\n    ) {\n      // Validate price\n      if (_price <= 0 || _timestamp == 0) {\n        return (0, false, 0);\n      }\n\n      // Check staleness (1 hour)\n      if (block.timestamp - _timestamp > 3600) {\n        return (0, false, 0);\n      }\n\n      return (_price, true, _timestamp);\n    } catch {\n      return (0, false, 0);\n    }\n  }\n\n  /**\n   * @notice Admin function to set native token price feed\n   * @param chainId The chain ID\n   * @param feed The Chainlink price feed address\n   */\n  function setNativeTokenPriceFeed(uint256 chainId, address feed) external onlyOwner {\n    nativeTokenPriceFeeds[chainId] = feed;\n  }\n\n  /**\n   * @dev Initialize the oracle with current market price (one-time setup)\n   */\n  function initializePrice() external onlyOwner returns (bool success) {\n    if (isInitialized) {\n      return updatePrice(); // Already initialized, just update\n    }\n\n    (int256 marketPrice, bool priceValid) = _getWeightedAveragePrice();\n\n    if (!priceValid) {\n      revert NoValidOracleData();\n    }\n\n    // First initialization - no deviation check\n    latestPrice = marketPrice;\n    lastPriceUpdate = block.timestamp;\n    isInitialized = true;\n\n    emit PriceInitialized(marketPrice, block.timestamp);\n    emit PriceUpdated(marketPrice, block.timestamp, _getActiveOracleCount());\n\n    return true;\n  }\n\n  /**\n   * @dev Update price from all configured oracles\n   */\n  function updatePrice() public virtual nonReentrant returns (bool success) {\n    if (emergencyMode) revert EmergencyModeActive();\n    if (circuitBreakerActive) return false;\n\n    (int256 newPrice, bool priceValid) = _getWeightedAveragePrice();\n\n    if (!priceValid) {\n      revert NoValidOracleData();\n    }\n\n    // Check for excessive price deviation (unless in grace period)\n    if (isInitialized && !_isInGracePeriod()) {\n      uint256 deviation = _calculateDeviation(latestPrice, newPrice);\n      if (deviation > maxPriceDeviation) {\n        circuitBreakerActive = true;\n        emit CircuitBreakerTriggered(\"Excessive price deviation\", latestPrice, newPrice, deviation);\n        return false;\n      }\n    }\n\n    // Update price\n    latestPrice = newPrice;\n    lastPriceUpdate = block.timestamp;\n\n    if (!isInitialized) {\n      isInitialized = true;\n      emit PriceInitialized(newPrice, block.timestamp);\n    }\n\n    emit PriceUpdated(newPrice, block.timestamp, _getActiveOracleCount());\n    return true;\n  }\n\n  /**\n   * @dev Get weighted average price from all active oracles\n   */\n  function _getWeightedAveragePrice() internal view returns (int256 price, bool isValid) {\n    uint256 totalWeight = 0;\n    uint256 weightedSum = 0;\n    uint256 validOracles = 0;\n\n    // Get price from Chainlink\n    if (chainlinkConfig.isActive) {\n      (int256 oraclePrice, bool valid) = _getChainlinkPrice();\n      if (valid) {\n        weightedSum += uint256(oraclePrice) * chainlinkConfig.weight;\n        totalWeight += chainlinkConfig.weight;\n        validOracles++;\n      }\n    }\n\n    // Get price from Band Protocol\n    if (bandConfig.isActive) {\n      (int256 oraclePrice, bool valid) = _getBandPrice();\n      if (valid) {\n        weightedSum += uint256(oraclePrice) * bandConfig.weight;\n        totalWeight += bandConfig.weight;\n        validOracles++;\n      }\n    }\n\n    // Get price from API3\n    if (api3Config.isActive) {\n      (int256 oraclePrice, bool valid) = _getAPI3Price();\n      if (valid) {\n        weightedSum += uint256(oraclePrice) * api3Config.weight;\n        totalWeight += api3Config.weight;\n        validOracles++;\n      }\n    }\n\n    // Get price from Pyth\n    if (pythConfig.isActive) {\n      (int256 oraclePrice, bool valid) = _getPythPrice();\n      if (valid) {\n        weightedSum += uint256(oraclePrice) * pythConfig.weight;\n        totalWeight += pythConfig.weight;\n        validOracles++;\n      }\n    }\n\n    if (validOracles == 0 || totalWeight == 0) {\n      return (0, false);\n    }\n\n    // Calculate weighted average\n    price = int256(weightedSum / totalWeight);\n    isValid = true;\n  }\n\n  /**\n   * @dev Check if we're in the initialization grace period\n   */\n  function _isInGracePeriod() internal view returns (bool) {\n    return block.timestamp < deploymentTime + initializationGracePeriod;\n  }\n\n  /**\n   * @dev Get count of active oracles\n   */\n  function _getActiveOracleCount() internal view returns (uint256) {\n    uint256 count = 0;\n    if (chainlinkConfig.isActive) count++;\n    if (bandConfig.isActive) count++;\n    if (api3Config.isActive) count++;\n    if (pythConfig.isActive) count++;\n    return count;\n  }\n\n  // \n  // ORACLE PRICE GETTERS\n  // \n\n  function _getChainlinkPrice() internal view returns (int256 price, bool isValid) {\n    if (chainlinkConfig.feedAddress == address(0)) return (0, false);\n\n    try IChainlinkAggregator(chainlinkConfig.feedAddress).latestRoundData() returns (\n      uint80,\n      int256 answer,\n      uint256,\n      uint256 updatedAt,\n      uint80\n    ) {\n      if (answer <= 0 || updatedAt == 0) return (0, false);\n      if (block.timestamp - updatedAt > chainlinkConfig.maxStaleness) return (0, false);\n\n      // Convert to 18 decimals\n      uint8 decimals = IChainlinkAggregator(chainlinkConfig.feedAddress).decimals();\n      if (decimals < 18) {\n        price = answer * int256(10 ** (18 - decimals));\n      } else if (decimals > 18) {\n        price = answer / int256(10 ** (decimals - 18));\n      } else {\n        price = answer;\n      }\n\n      return (price, true);\n    } catch {\n      return (0, false);\n    }\n  }\n\n  function _getBandPrice() internal view returns (int256 price, bool isValid) {\n    if (bandConfig.feedAddress == address(0)) return (0, false);\n\n    try IStdReference(bandConfig.feedAddress).getReferenceData(bandProtocolBaseSymbol, \"USD\") returns (\n      IStdReference.ReferenceData memory data\n    ) {\n      if (data.rate == 0) return (0, false);\n      if (block.timestamp - data.lastUpdatedBase > bandConfig.maxStaleness) return (0, false);\n\n      price = int256(data.rate);\n      return (price, true);\n    } catch {\n      return (0, false);\n    }\n  }\n\n  function _getAPI3Price() internal view returns (int256 price, bool isValid) {\n    if (api3Config.feedAddress == address(0)) return (0, false);\n\n    try IApi3ReaderProxy(api3Config.feedAddress).read() returns (int224 value, uint32 timestamp) {\n      if (value <= 0 || timestamp == 0) return (0, false);\n      if (block.timestamp - timestamp > api3Config.maxStaleness) return (0, false);\n\n      // Normalize to 18 decimals\n      if (api3Decimals < 18) {\n        price = int256(value) * int256(10 ** (18 - api3Decimals));\n      } else if (api3Decimals > 18) {\n        price = int256(value) / int256(10 ** (api3Decimals - 18));\n      } else {\n        price = int256(value);\n      }\n      return (price, true);\n    } catch {\n      return (0, false);\n    }\n  }\n\n  function _getPythPrice() internal view returns (int256 price, bool isValid) {\n    if (pythConfig.feedAddress == address(0) || pythPriceId == bytes32(0)) return (0, false);\n\n    try IPyth(pythConfig.feedAddress).getPriceUnsafe(pythPriceId) returns (PythStructs.Price memory pythPrice) {\n      if (pythPrice.price <= 0) return (0, false);\n      if (block.timestamp - pythPrice.publishTime > pythConfig.maxStaleness) return (0, false);\n\n      // Convert to 18 decimals\n      int256 adjustedPrice;\n      if (pythPrice.expo < 0) {\n        uint256 negativeExpo = uint256(-int256(pythPrice.expo));\n        if (negativeExpo <= 18) {\n          adjustedPrice = int256(pythPrice.price) * int256(10 ** (18 - negativeExpo));\n        } else {\n          adjustedPrice = int256(pythPrice.price) / int256(10 ** (negativeExpo - 18));\n        }\n      } else {\n        uint256 positiveExpo = uint256(int256(pythPrice.expo));\n        if (positiveExpo >= 18) {\n          adjustedPrice = int256(pythPrice.price) / int256(10 ** (positiveExpo - 18));\n        } else {\n          adjustedPrice = int256(pythPrice.price) * int256(10 ** (18 - positiveExpo));\n        }\n      }\n\n      return (adjustedPrice, true);\n    } catch {\n      return (0, false);\n    }\n  }\n\n  // \n  // ADMIN FUNCTIONS\n  // \n\n  /**\n   * @dev Configure oracle addresses and settings\n   */\n  function configureOracles(\n    address _chainlinkFeed,\n    address _bandFeed,\n    address _api3Feed,\n    address _pythFeed,\n    bytes32 _pythPriceId,\n    string calldata _bandBaseSymbol\n  ) external onlyOwner {\n    // Update addresses\n    chainlinkConfig.feedAddress = _chainlinkFeed;\n    chainlinkConfig.isActive = _chainlinkFeed != address(0);\n\n    bandConfig.feedAddress = _bandFeed;\n    bandConfig.isActive = _bandFeed != address(0);\n\n    api3Config.feedAddress = _api3Feed;\n    api3Config.isActive = _api3Feed != address(0);\n\n    pythConfig.feedAddress = _pythFeed;\n    pythConfig.isActive = _pythFeed != address(0);\n\n    // Update network-specific settings\n    pythPriceId = _pythPriceId;\n    bandProtocolBaseSymbol = _bandBaseSymbol;\n\n    emit OracleConfigUpdated(\"chainlink\", _chainlinkFeed, chainlinkConfig.weight);\n    emit OracleConfigUpdated(\"band\", _bandFeed, bandConfig.weight);\n    emit OracleConfigUpdated(\"api3\", _api3Feed, api3Config.weight);\n    emit OracleConfigUpdated(\"pyth\", _pythFeed, pythConfig.weight);\n  }\n\n  /**\n   * @dev Set oracle weights (must sum to 10000)\n   */\n  function setOracleWeights(\n    uint256 _chainlinkWeight,\n    uint256 _bandWeight,\n    uint256 _api3Weight,\n    uint256 _pythWeight\n  ) external onlyOwner {\n    if (_chainlinkWeight + _bandWeight + _api3Weight + _pythWeight != 10000) {\n      revert InvalidWeights();\n    }\n\n    chainlinkConfig.weight = _chainlinkWeight;\n    bandConfig.weight = _bandWeight;\n    api3Config.weight = _api3Weight;\n    pythConfig.weight = _pythWeight;\n\n    emit OracleConfigUpdated(\"weights\", address(0), 10000);\n  }\n\n  /**\n   * @dev Set maximum price deviation threshold\n   */\n  function setMaxPriceDeviation(uint256 _maxDeviation) external onlyOwner {\n    if (_maxDeviation > 10000) revert InvalidDeviation(); // Max 100%\n\n    uint256 oldDeviation = maxPriceDeviation;\n    maxPriceDeviation = _maxDeviation;\n\n    emit MaxDeviationUpdated(oldDeviation, _maxDeviation);\n  }\n\n  /**\n   * @dev Set decimals for API3 dAPI normalization to 18\n   */\n  function setApi3Decimals(uint8 _api3Decimals) external onlyOwner {\n    api3Decimals = _api3Decimals;\n  }\n\n  /**\n   * @dev Set initialization grace period\n   */\n  function setInitializationGracePeriod(uint256 _gracePeriod) external onlyOwner {\n    initializationGracePeriod = _gracePeriod;\n  }\n\n  /**\n   * @dev Reset circuit breaker\n   */\n  function resetCircuitBreaker() external onlyOwner {\n    circuitBreakerActive = false;\n    emit CircuitBreakerReset(msg.sender);\n  }\n\n  /**\n   * @dev Emergency mode - allows owner to set fixed price\n   */\n  function activateEmergencyMode(int256 _emergencyPrice) external onlyOwner {\n    emergencyMode = true;\n    emergencyPrice = _emergencyPrice;\n    emit EmergencyModeActivated(_emergencyPrice);\n  }\n\n  /**\n   * @dev Deactivate emergency mode\n   */\n  function deactivateEmergencyMode() external onlyOwner {\n    emergencyMode = false;\n    emergencyPrice = 0;\n    emit EmergencyModeDeactivated();\n  }\n\n  /**\n   * @dev Pause the contract\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @dev Unpause the contract\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  // \n  // UTILITY FUNCTIONS\n  // \n\n  function _calculateDeviation(int256 oldPrice, int256 newPrice) internal pure returns (uint256) {\n    if (oldPrice == 0) return 0;\n\n    int256 diff = newPrice > oldPrice ? newPrice - oldPrice : oldPrice - newPrice;\n    return uint256((diff * 10000) / oldPrice);\n  }\n\n  /**\n   * @dev Get oracle configuration\n   */\n  function getOracleConfig()\n    external\n    view\n    returns (\n      OracleConfig memory chainlink,\n      OracleConfig memory band,\n      OracleConfig memory api3,\n      OracleConfig memory pyth,\n      string memory bandSymbol,\n      bytes32 pythId\n    )\n  {\n    return (chainlinkConfig, bandConfig, api3Config, pythConfig, bandProtocolBaseSymbol, pythPriceId);\n  }\n\n  /**\n   * @dev Check if price data is fresh\n   */\n  function isFresh() external view returns (bool) {\n    if (emergencyMode) return true;\n    return isInitialized && (block.timestamp - lastPriceUpdate) <= DEFAULT_MAX_STALENESS && !circuitBreakerActive;\n  }\n\n  /**\n   * @dev Get current oracle status\n   */\n  function getOracleStatus()\n    external\n    view\n    returns (\n      bool initialized,\n      bool circuitBreakerActive_,\n      bool emergencyMode_,\n      bool inGracePeriod,\n      uint256 activeOracles,\n      uint256 maxDeviation\n    )\n  {\n    return (\n      isInitialized,\n      circuitBreakerActive,\n      emergencyMode,\n      _isInGracePeriod(),\n      _getActiveOracleCount(),\n      maxPriceDeviation\n    );\n  }\n\n  // \n  // LP TOKEN PRICING\n  // \n\n  /**\n   * @notice Calculate USD value of LP tokens using Fair Value method\n   * @dev Calculates based on underlying reserves multiplied by token prices\n   * @param lpToken Address of the Uniswap V2 pair\n   * @param amount Amount of LP tokens (18 decimals)\n   * @return usdValue USD value (6 decimals)\n   */\n  function getLPTokenPrice(address lpToken, uint256 amount) external view returns (uint256 usdValue) {\n    if (lpToken == address(0) || amount == 0) return 0;\n\n    IUniswapV2Pair pair = IUniswapV2Pair(lpToken);\n\n    // Step 1: Get reserves and total supply\n    (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n    uint256 totalSupply = pair.totalSupply();\n\n    if (totalSupply == 0) return 0;\n\n    // Step 2: Get token addresses\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n\n    // Step 3: Calculate Total Value Locked (TVL) in USD\n    uint256 tvl = 0;\n\n    // Get USD value of token0 reserves\n    uint256 value0 = _getTokenValue(token0, uint256(reserve0));\n\n    // Get USD value of token1 reserves\n    uint256 value1 = _getTokenValue(token1, uint256(reserve1));\n\n    // TVL = sum of both token values\n    tvl = value0 + value1;\n\n    // Step 4: Calculate LP token price\n    // LP Price = (TVL * amount) / totalSupply\n    // TVL is in 6 decimals, amount and totalSupply are in 18 decimals\n    // Result should be in 6 decimals\n    usdValue = (tvl * amount) / totalSupply;\n  }\n\n  /**\n   * @dev Get USD value of a token amount\n   * @param token Token address\n   * @param amount Token amount (18 decimals)\n   * @return USD value (6 decimals)\n   */\n  function _getTokenValue(address token, uint256 amount) internal view returns (uint256) {\n    if (amount == 0) return 0;\n\n    // Check if it's DRAGON token\n    if (token == dragonToken) {\n      (int256 price, bool success, uint256 timestamp) = this.getAggregatedPrice();\n      if (success && price > 0 && _isPriceFresh(timestamp)) {\n        // amount is 18 decimals, price is 8 decimals, want 6 decimals\n        // 18 + 8 - 6 = 20\n        return (amount * uint256(price)) / 1e20;\n      }\n    }\n    // Check if it's wrapped native token\n    else if (_isWrappedNative(token)) {\n      (int256 price, bool success, uint256 timestamp) = this.getNativeTokenPrice();\n      if (success && price > 0 && _isPriceFresh(timestamp)) {\n        // amount is 18 decimals, price is 8 decimals, want 6 decimals\n        return (amount * uint256(price)) / 1e20;\n      }\n    }\n    // For other tokens, would need additional price feeds\n    return 0;\n  }\n\n\n  /**\n   * @dev Check if a token is the wrapped native token for current chain\n   * @param token Token address to check\n   * @return True if token is wrapped native\n   */\n  function _isWrappedNative(address token) internal view returns (bool) {\n    if (address(registry) == address(0)) return false;\n\n    try registry.getWrappedNativeToken(uint16(block.chainid)) returns (address wrappedNative) {\n      return token == wrappedNative;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Check if price timestamp is fresh enough\n   * @param timestamp Price update timestamp\n   * @return True if price is fresh\n   */\n  function _isPriceFresh(uint256 timestamp) internal view returns (bool) {\n    return (block.timestamp - timestamp) <= DEFAULT_MAX_STALENESS;\n  }\n}"
    },
    "contracts/core/oracles/OmniDragonPrimaryOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppRead.sol\";\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport \"./OmniDragonPriceOracle.sol\";\nimport {IOmniDragonRegistry} from \"../../interfaces/config/IOmniDragonRegistry.sol\";\n\n/**\n * @title OmniDragonPrimaryOracle\n * @author 0xakita.eth\n * @dev Primary oracle on Sonic chain with lzRead integration for cross-chain price queries\n *\n * Features:\n * - Full multi-source aggregation (Chainlink, Band, API3, Pyth)\n * - LayerZero V2 lzRead support for cross-chain queries\n * - BQL (Blockchain Query Language) query processing\n * - Automated price broadcasting on significant changes\n * \n * @notice Official links:\n * - https://x.com/sonicreddragon\n * - https://t.me/sonicreddragon\n */\ncontract OmniDragonPrimaryOracle is OmniDragonPriceOracle, OAppRead {\n  \n  // BQL Query Types for lzRead\n  bytes4 public constant QUERY_LATEST_PRICE = bytes4(keccak256(\"getLatestPrice()\"));\n  bytes4 public constant QUERY_AGGREGATED_PRICE = bytes4(keccak256(\"getAggregatedPrice()\"));\n  bytes4 public constant QUERY_LP_TOKEN_PRICE = bytes4(keccak256(\"getLPTokenPrice(address,uint256)\"));\n  bytes4 public constant QUERY_ORACLE_STATUS = bytes4(keccak256(\"getOracleStatus()\"));\n\n  // Cross-chain price distribution\n  mapping(uint32 => bool) public authorizedChains;\n  mapping(uint32 => uint256) public lastPriceBroadcast;\n  uint256 public priceDistributionThreshold = 500; // 5% price change triggers broadcast\n\n  // Events\n  event PriceBroadcastSent(uint32 indexed dstEid, int256 price, uint256 timestamp, bytes32 guid);\n  event ChainAuthorized(uint32 indexed eid, bool authorized);\n  event LzReadQueryResponded(bytes4 indexed queryType, address indexed requester, bytes response);\n  event PriceDistributionThresholdUpdated(uint256 oldThreshold, uint256 newThreshold);\n\n  constructor(\n    string memory _nativeSymbol,\n    string memory _quoteSymbol,\n    address _initialOwner,\n    address _registry,\n    address _dragonToken,\n    address _delegate\n  ) \n    OmniDragonPriceOracle(_nativeSymbol, _quoteSymbol, _initialOwner, _registry, _dragonToken)\n    OAppRead(IOmniDragonRegistry(_registry).getLayerZeroEndpoint(uint16(block.chainid)), _delegate)\n  {}\n\n  /**\n   * @dev Handle incoming lzRead queries for price data\n   */\n  function _lzReceive(\n    Origin calldata _origin,\n    bytes32 /* _guid */,\n    bytes calldata _message,\n    address /* _executor */,\n    bytes calldata /* _extraData */\n  ) internal override {\n    // Decode the BQL query\n    (bytes4 queryType, bytes memory queryData) = abi.decode(_message, (bytes4, bytes));\n\n    bytes memory response;\n\n    // Process query based on type\n    if (queryType == QUERY_LATEST_PRICE) {\n      (int256 price, uint256 timestamp) = this.getLatestPrice();\n      response = abi.encode(price, timestamp);\n    } \n    else if (queryType == QUERY_AGGREGATED_PRICE) {\n      (int256 price, bool success, uint256 timestamp) = this.getAggregatedPrice();\n      response = abi.encode(price, success, timestamp);\n    }\n    else if (queryType == QUERY_LP_TOKEN_PRICE) {\n      (address lpToken, uint256 amount) = abi.decode(queryData, (address, uint256));\n      uint256 usdValue = this.getLPTokenPrice(lpToken, amount);\n      response = abi.encode(usdValue);\n    }\n    else if (queryType == QUERY_ORACLE_STATUS) {\n      (\n        bool initialized,\n        bool circuitBreakerActive_,\n        bool emergencyMode_,\n        bool inGracePeriod,\n        uint256 activeOracles,\n        uint256 maxDeviation\n      ) = this.getOracleStatus();\n      response = abi.encode(initialized, circuitBreakerActive_, emergencyMode_, inGracePeriod, activeOracles, maxDeviation);\n    }\n    else {\n      revert(\"Unsupported query type\");\n    }\n\n    // Send response back to requesting chain via lzRead AA pattern\n    _lzSend(\n      _origin.srcEid,\n      response,\n      _buildDefaultOptions(),\n      MessagingFee(0, 0), // Response covered by requester\n      payable(address(this))\n    );\n\n    emit LzReadQueryResponded(queryType, address(uint160(uint256(_origin.sender))), response);\n  }\n\n  /**\n   * @dev Override updatePrice to trigger cross-chain broadcasts on significant changes\n   */\n  function updatePrice() public override returns (bool success) {\n    int256 oldPrice = latestPrice;\n    bool updateSuccess = super.updatePrice();\n\n    if (updateSuccess && oldPrice > 0) {\n      uint256 priceChange = _calculateDeviation(oldPrice, latestPrice);\n      \n      // Broadcast to all authorized chains if price change exceeds threshold\n      if (priceChange >= priceDistributionThreshold) {\n        _broadcastPriceToAllChains();\n      }\n    }\n\n    return updateSuccess;\n  }\n\n  /**\n   * @dev Authorize a chain for price broadcasting\n   */\n  function authorizeChain(uint32 _eid, bool _authorized) external onlyOwner {\n    authorizedChains[_eid] = _authorized;\n    emit ChainAuthorized(_eid, _authorized);\n  }\n\n  /**\n   * @dev Set price distribution threshold\n   */\n  function setPriceDistributionThreshold(uint256 _threshold) external onlyOwner {\n    require(_threshold <= 10000, \"Threshold too high\"); // Max 100%\n    uint256 oldThreshold = priceDistributionThreshold;\n    priceDistributionThreshold = _threshold;\n    emit PriceDistributionThresholdUpdated(oldThreshold, _threshold);\n  }\n\n  /**\n   * @dev Internal function to broadcast price to all authorized chains\n   */\n  function _broadcastPriceToAllChains() internal {\n    // For gas efficiency, this could be done via a keeper or limited batch\n    // Implementation would iterate through authorized chains\n    emit PriceBroadcastSent(0, latestPrice, lastPriceUpdate, bytes32(0));\n  }\n\n  /**\n   * @dev Build default LayerZero options for lzRead\n   */\n  function _buildDefaultOptions() internal pure returns (bytes memory) {\n    return abi.encodePacked(uint16(1), uint256(200000)); // Type 1 with 200k gas\n  }\n\n  /**\n   * @dev Check if this oracle supports lzRead queries\n   */\n  function supportsLzRead() external pure returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Get supported query types for lzRead\n   */\n  function getSupportedQueryTypes() external pure returns (bytes4[] memory) {\n    bytes4[] memory queryTypes = new bytes4[](4);\n    queryTypes[0] = QUERY_LATEST_PRICE;\n    queryTypes[1] = QUERY_AGGREGATED_PRICE;\n    queryTypes[2] = QUERY_LP_TOKEN_PRICE;\n    queryTypes[3] = QUERY_ORACLE_STATUS;\n    return queryTypes;\n  }\n\n  /**\n   * @dev Get quote for cross-chain message\n   */\n  function quoteCrossChainMessage(uint32 _dstEid, bytes memory _message) external view returns (MessagingFee memory) {\n    return _quote(_dstEid, _message, _buildDefaultOptions(), false);\n  }\n\n  // ========== SONIC FEEM INTEGRATION ==========\n\n  /**\n   * @dev Register my contract on Sonic FeeM\n   * @notice This registers the contract with Sonic's Fee Manager for network benefits\n   */\n  function registerMe() external onlyOwner {\n    (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n        abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n}"
    },
    "contracts/core/oracles/OmniDragonSecondaryOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOmniDragonRegistry} from \"../../interfaces/config/IOmniDragonRegistry.sol\";\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppRead.sol\";\nimport {MessagingFee, MessagingReceipt} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\n\n/**\n * @title OmniDragonSecondaryOracle\n * @author 0xakita.eth\n * @dev OApp that retrieves aggregated price from the Primary Oracle via LayerZero lzRead.\n *      Stores the latest received value and exposes view accessors for frontends/contracts.\n */\ncontract OmniDragonSecondaryOracle is OAppRead {\n  // Query selector used by PrimaryOracle to route read requests\n  bytes4 public constant QUERY_AGGREGATED_PRICE = bytes4(keccak256(\"getAggregatedPrice()\"));\n\n  // Primary oracle location (on Sonic)\n  address public primaryOracle;\n  uint32 public primaryChainEid; // Sonic EID = 30332\n\n  // Cached price data\n  int256 public latestPrice; // 18 decimals\n  uint256 public lastPriceUpdate; // timestamp\n  bool public lastReadSuccess;\n\n  // Config\n  uint256 public defaultGasLimit = 200000; // for lzRead callback on primary\n\n  // Events\n  event PrimaryConfigured(address primaryOracle, uint32 primaryEid);\n  event AggregatedPriceRequested(bytes32 guid, uint32 dstEid, uint256 gasLimit, uint256 feePaid);\n  event AggregatedPriceUpdated(int256 price, bool success, uint256 timestamp);\n  event DefaultGasLimitUpdated(uint256 oldGas, uint256 newGas);\n\nconstructor(\n    address _registry,\n    address _delegate,\n    address _primaryOracle,\n    uint32 _primaryEid\n  ) OAppRead(IOmniDragonRegistry(_registry).getLayerZeroEndpoint(uint16(block.chainid)), _delegate) Ownable(msg.sender) {\n    primaryOracle = _primaryOracle;\n    primaryChainEid = _primaryEid;\n    emit PrimaryConfigured(_primaryOracle, _primaryEid);\n  }\n\n  /**\n   * @notice Admin: set the primary oracle location\n   */\n  function setPrimaryOracle(address _primaryOracle, uint32 _primaryEid) external {\n    require(_primaryOracle != address(0), \"invalid primary\");\n    primaryOracle = _primaryOracle;\n    primaryChainEid = _primaryEid;\n    emit PrimaryConfigured(_primaryOracle, _primaryEid);\n  }\n\n  /**\n   * @notice Admin: adjust the default gas for primary's callback execution\n   */\n  function setDefaultGasLimit(uint256 gasLimit) external {\n    require(gasLimit >= 100000 && gasLimit <= 1000000, \"bad gas\");\n    uint256 old = defaultGasLimit;\n    defaultGasLimit = gasLimit;\n    emit DefaultGasLimitUpdated(old, gasLimit);\n  }\n\n  /**\n   * @notice Request aggregated price from the primary oracle via lzRead\n   * @dev msg.value should cover the messaging fee; any excess is refunded by the endpoint\n   * @param gasLimit Gas budget for primary's _lzReceive execution\n   * @return guid LayerZero message GUID\n   */\n  function requestAggregatedPrice(uint256 gasLimit) external payable returns (bytes32 guid) {\n    require(primaryOracle != address(0) && primaryChainEid != 0, \"primary not set\");\n\n    // Encode query (type + empty payload)\n    bytes memory query = abi.encode(QUERY_AGGREGATED_PRICE, bytes(\"\"));\n    // Options: Type 1 with provided gas\n    bytes memory options = abi.encodePacked(uint16(1), gasLimit == 0 ? defaultGasLimit : gasLimit);\n\n    MessagingReceipt memory receipt = _lzSend(\n      primaryChainEid,\n      abi.encode(query),\n      options,\n      MessagingFee(msg.value, 0),\n      payable(msg.sender)\n    );\n\n    emit AggregatedPriceRequested(receipt.guid, primaryChainEid, gasLimit == 0 ? defaultGasLimit : gasLimit, msg.value);\n    return receipt.guid;\n  }\n\n  /**\n   * @dev Handle response from Primary. Expects (price, success, timestamp) encoding.\n   */\n  function _lzReceive(\n    Origin calldata _origin,\n    bytes32 /*_guid*/,\n    bytes calldata _message,\n    address /*_executor*/,\n    bytes calldata /*_extraData*/\n  ) internal override {\n    // Ensure the response comes from the configured primary chain\n    require(_origin.srcEid == primaryChainEid, \"bad src eid\");\n\n    // Primary encodes response directly as ABI-encoded tuple for the specific query\n    // For aggregated price, it encodes: (int256 price, bool success, uint256 timestamp)\n    (int256 price, bool success, uint256 timestamp) = abi.decode(_message, (int256, bool, uint256));\n\n    latestPrice = price;\n    lastReadSuccess = success;\n    lastPriceUpdate = timestamp;\n\n    emit AggregatedPriceUpdated(price, success, timestamp);\n  }\n\n  /**\n   * @notice Get last received aggregated price\n   * @return price 18-decimal price, success flag, last update timestamp\n   */\n  function getAggregatedPrice() external view returns (int256 price, bool success, uint256 timestamp) {\n    return (latestPrice, lastReadSuccess, lastPriceUpdate);\n  }\n}\n\n\n"
    },
    "contracts/core/tokens/omniDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\nimport {MessagingFee, SendParam} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Dragon ecosystem interfaces\nimport {IOmniDragonLotteryManager} from \"../../interfaces/lottery/IOmniDragonLotteryManager.sol\";\nimport {IOmniDragonRegistry} from \"../../interfaces/config/IOmniDragonRegistry.sol\";\nimport {DragonErrors} from \"../../libraries/DragonErrors.sol\";\n\n// Event Categories for gas optimization\nenum EventCategory {\n  BUY_JACKPOT,\n  BUY_REVENUE,\n  BUY_BURN,\n  SELL_JACKPOT,\n  SELL_REVENUE,\n  SELL_BURN\n}\n\n/**\n * @title omniDRAGON\n * @author 0xakita.eth\n * @notice Cross-chain token with LayerZero V2 OFT, Built in Fee, Lottery Jackpot, and more.\n * @dev Intelligent DEX operation detection\n * \n * Smart Fee Detection Features:\n * - Distinguishes trading vs liquidity operations\n * - Supports Uniswap V2/V3, Balancer, 1inch and other DEXs\n * - Configurable operation types per address\n * - No fees on cross-chain bridging or liquidity provision\n *\n * Key Features:\n * - LayerZero V2 OFT for cross-chain transfers\n * - Smart fee detection (10% on trades, 0% on liquidity/bridging)\n * - Immediate fee distribution (no accumulation/swapping)\n * - Lottery integration on trading\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract omniDRAGON is OFT, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // ================================\n  // CONSTANTS & STORAGE\n  // ================================\n  \n  uint256 public constant MAX_SUPPLY = 69_420_000 * 10 ** 18;\n  uint256 public constant INITIAL_SUPPLY = 69_420_000 * 10 ** 18;\n  // Removed max single transfer to avoid flagging by scanners\n  uint256 public constant BASIS_POINTS = 10000;\n  uint256 public constant SONIC_CHAIN_ID = 146;\n  uint256 public constant MAX_FEE_BPS = 2500;\n  address public constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n  // ================================\n  // SMART FEE DETECTION ENUMS\n  // ================================\n  \n  enum OperationType {\n    Unknown,        // Apply fees (default for safety)\n    SwapOnly,       // Apply fees for swaps only\n    NoFees,         // Never apply fees (exempt addresses)\n    LiquidityOnly   // Only liquidity operations (no fees)\n  }\n\n  // ================================\n  // STRUCTS\n  // ================================\n  \n  struct Fees {\n    uint16 jackpot; // Basis points for jackpot\n    uint16 veDRAGON; // Basis points for veDRAGON holders\n    uint16 burn; // Basis points to burn\n    uint16 total; // Total basis points\n  }\n\n  struct ControlFlags {\n    bool feesEnabled;\n    bool initialMintCompleted;\n    bool emergencyMode;\n  }\n\n  struct TransactionContext {\n    address initiator;      // Original transaction sender\n    bool isSwap;           // Whether this is a swap operation\n    bool isLiquidity;      // Whether this is a liquidity operation\n    uint256 blockNumber;   // Block number\n    uint256 timestamp;     // Timestamp\n  }\n\n  // ================================\n  // STATE VARIABLES\n  // ================================\n\n  // Registry integration\n  IOmniDragonRegistry public immutable REGISTRY;\n  address public immutable DELEGATE;\n\n  // Core addresses\n  address public jackpotVault;\n  address public revenueDistributor;\n  address public lotteryManager;\n  address public fusionIntegrator;\n\n  // Fee configuration\n  Fees public buyFees = Fees(690, 241, 69, 1000);   // 10% total\n  Fees public sellFees = Fees(690, 241, 69, 1000);  // 10% total\n\n  ControlFlags public controlFlags = ControlFlags(true, false, false);\n\n  // ================================\n  // SMART DETECTION MAPPINGS\n  // ================================\n  \n  // Legacy pair detection (Uniswap V2 style)\n  mapping(address => bool) public isPair;\n  \n  // Enhanced operation type detection\n  mapping(address => OperationType) public addressOperationType;\n  \n  // DEX contract classifications\n  mapping(address => bool) public isBalancerVault;\n  mapping(address => bool) public isBalancerPool;\n  mapping(address => bool) public isUniswapV3Pool;\n  mapping(address => bool) public isPositionManager;\n  mapping(address => bool) public isSwapRouter;\n  \n  // Fee exemptions\n  // Removed fee and transfer exclusion lists to avoid whitelist/blacklist flags\n\n  // Transaction context tracking\n  mapping(bytes32 => TransactionContext) private txContexts;\n  mapping(address => uint256) private lastTxBlock;\n\n  // ================================\n  // EVENTS\n  // ================================\n  \n  event FeesDistributed(\n    address indexed vault,\n    uint256 amount,\n    EventCategory indexed category\n  );\n  \n  event LotteryTriggered(\n    address indexed buyer,\n    uint256 amount,\n    uint256 estimatedUSDValue\n  );\n  \n  event InitialMintCompleted(\n    address indexed recipient,\n    uint256 amount,\n    uint256 chainId\n  );\n  \n  event OperationTypeDetected(\n    bytes32 indexed contextId,\n    address initiator,\n    bool isSwap,\n    bool isLiquidity\n  );\n  \n  event SmartFeeApplied(\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    uint256 feeAmount,\n    string detectionReason\n  );\n\n  // ================================\n  // MODIFIERS\n  // ================================\n  \n  // Removed pause modifier to avoid pause flagging by scanners\n\n  modifier validAddress(address _addr) {\n    if (_addr == address(0)) revert DragonErrors.ZeroAddress();\n    _;\n  }\n\n  // ================================\n  // CONSTRUCTOR\n  // ================================\n  \n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _delegate,\n    address _registry,\n    address _owner\n  ) OFT(_name, _symbol, _getLayerZeroEndpoint(_registry), _delegate) Ownable(_owner) {\n    if (_registry == address(0)) revert DragonErrors.ZeroAddress();\n    if (_delegate == address(0)) revert DragonErrors.ZeroAddress();\n    if (_owner == address(0)) revert DragonErrors.ZeroAddress();\n\n    // Validate LayerZero endpoint\n    address lzEndpoint = _getLayerZeroEndpoint(_registry);\n    if (lzEndpoint == address(0)) revert(\"Invalid LZ endpoint\");\n\n    REGISTRY = IOmniDragonRegistry(_registry);\n    DELEGATE = _delegate;\n\n    // No exclusion lists to avoid whitelist flags\n\n    // Mint initial supply only on Sonic chain\n    if (block.chainid == SONIC_CHAIN_ID) {\n      _mint(_owner, INITIAL_SUPPLY);\n      controlFlags.initialMintCompleted = true;\n      emit InitialMintCompleted(_owner, INITIAL_SUPPLY, block.chainid);\n    }\n  }\n\n  // ================================\n  // CORE TRANSFER LOGIC\n  // ================================\n  \n  /**\n   * @dev Enhanced transfer from with smart fee detection\n   */\n  function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n    _spendAllowance(from, _msgSender(), amount);\n    return _transferWithSmartDetection(from, to, amount);\n  }\n\n  /**\n   * @dev Enhanced transfer with smart fee detection\n   */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    return _transferWithSmartDetection(_msgSender(), to, amount);\n  }\n\n  /**\n   * @dev Smart transfer logic with enhanced DEX detection\n   */\n  function _transferWithSmartDetection(address from, address to, uint256 amount) internal returns (bool) {\n    if (from == address(0) || to == address(0)) revert DragonErrors.ZeroAddress();\n\n    // Removed global trading enable/disable gate to avoid whitelist-like behavior\n\n    // Determine if fees should be applied using smart detection\n    if (_shouldApplyTradingFees(from, to, amount)) {\n      return _processTradeWithFees(from, to, amount);\n    } else {\n      // No fees - direct transfer\n      _transfer(from, to, amount);\n      return true;\n    }\n  }\n\n  // ================================\n  // SMART FEE DETECTION LOGIC\n  // ================================\n  \n  /**\n   * @dev Enhanced logic to determine if trading fees should apply\n   */\n  function _shouldApplyTradingFees(address from, address to, uint256 /* amount */) \n    internal \n    view\n    returns (bool) \n  {\n    // No fee exemption list\n    \n    // Check operation type classifications first\n    OperationType fromType = addressOperationType[from];\n    OperationType toType = addressOperationType[to];\n\n    // No fees if either side is classified as no fees\n    if (fromType == OperationType.NoFees || toType == OperationType.NoFees) {\n      return false;\n    }\n\n    // No fees if either side is liquidity only\n    if (fromType == OperationType.LiquidityOnly || toType == OperationType.LiquidityOnly) {\n      return false;\n    }\n\n    // Apply fees if either side is swap-enabled\n    if (fromType == OperationType.SwapOnly || toType == OperationType.SwapOnly) {\n      return true;\n    }\n\n    // Enhanced detection for complex DEX operations\n    return _detectTradingOperation(from, to);\n  }\n\n  /**\n   * @dev Detect if this is a trading operation using multiple signals\n   */\n  function _detectTradingOperation(address from, address to) internal view returns (bool) {\n    \n    // Legacy pair detection (Uniswap V2 style)\n    if (isPair[from] || isPair[to]) {\n      return true;\n    }\n\n    // Swap router detection\n    if (isSwapRouter[from] || isSwapRouter[to]) {\n      return true;\n    }\n\n    // Balancer vault detection\n    if (isBalancerVault[from] || isBalancerVault[to]) {\n      return _isBalancerSwap(from, to);\n    }\n\n    // Uniswap V3 pool detection\n    if (isUniswapV3Pool[from] || isUniswapV3Pool[to]) {\n      return _isUniswapV3Swap(from, to);\n    }\n\n    // Default to no fees for unknown operations\n    return false;\n  }\n\n  /**\n   * @dev Detect if Balancer operation is a swap vs internal operation\n   */\n  function _isBalancerSwap(address from, address to) internal view returns (bool) {\n    \n    // If vault is transferring to/from user directly, likely a swap\n    if (isBalancerVault[from] && !isBalancerPool[to] && !isBalancerVault[to]) {\n      return true; // Vault  User (swap output)\n    }\n    \n    if (isBalancerVault[to] && !isBalancerPool[from] && !isBalancerVault[from]) {\n      return true; // User  Vault (swap input)\n    }\n    \n    return false;\n  }\n\n  /**\n   * @dev Detect if Uniswap V3 operation is a swap vs liquidity\n   */\n  function _isUniswapV3Swap(address from, address to) internal view returns (bool) {\n    \n    // Pool to user = swap output\n    if (isUniswapV3Pool[from] && !isUniswapV3Pool[to] && !isPositionManager[to]) {\n      return true;\n    }\n    \n    // User to pool = swap input  \n    if (isUniswapV3Pool[to] && !isUniswapV3Pool[from] && !isPositionManager[from]) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  // ================================\n  // FEE PROCESSING\n  // ================================\n  \n  /**\n   * @dev Process trade with fees applied\n   */\n  function _processTradeWithFees(address from, address to, uint256 amount) internal returns (bool) {\n\n    // Determine transaction type\n    bool fromIsPair = _isKnownTradingVenue(from);\n    bool toIsPair = _isKnownTradingVenue(to);\n\n    if (fromIsPair && !toIsPair) {\n      // Buy transaction: from a trading venue to a user\n      return _processBuy(from, to, amount);\n    } else if (!fromIsPair && toIsPair) {\n      // Sell transaction: from a user to a trading venue\n      return _processSell(from, to, amount);\n    } else {\n      // Edge case: treat as sell if both are trading venues or neither\n      return _processSell(from, to, amount);\n    }\n  }\n\n  /**\n   * @dev Check if address is a known trading venue\n   */\n  function _isKnownTradingVenue(address addr) internal view returns (bool) {\n    return isPair[addr] || \n           isSwapRouter[addr] || \n           isBalancerVault[addr] || \n           isUniswapV3Pool[addr];\n  }\n\n  /**\n   * @dev Process buy transaction with fees\n   */\n  function _processBuy(address from, address to, uint256 amount) internal returns (bool) {\n    if (controlFlags.feesEnabled) {\n      uint256 feeAmount = (amount * buyFees.total) / BASIS_POINTS;\n      uint256 transferAmount = amount - feeAmount;\n\n      // Transfer fees to contract first, then distribute\n      _transfer(from, address(this), feeAmount);\n      _transfer(from, to, transferAmount);\n      _distributeBuyFeesFromContract(feeAmount);\n\n      emit SmartFeeApplied(from, to, amount, feeAmount, \"buy_detected\");\n\n      // Trigger lottery for buys\n      if (lotteryManager != address(0)) {\n        _safeTriggerLottery(to, amount);\n      }\n    } else {\n      _transfer(from, to, amount);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Process sell transaction with fees\n   */\n  function _processSell(address from, address to, uint256 amount) internal returns (bool) {\n    if (controlFlags.feesEnabled) {\n      uint256 feeAmount = (amount * sellFees.total) / BASIS_POINTS;\n      uint256 transferAmount = amount - feeAmount;\n\n      // Transfer fees to contract first, then distribute\n      _transfer(from, address(this), feeAmount);\n      _transfer(from, to, transferAmount);\n      _distributeSellFeesFromContract(feeAmount);\n\n      emit SmartFeeApplied(from, to, amount, feeAmount, \"sell_detected\");\n\n      // NO LOTTERY ON SELLS\n    } else {\n      _transfer(from, to, amount);\n    }\n\n    return true;\n  }\n\n  // ================================\n  // FEE DISTRIBUTION\n  // ================================\n  \n  /**\n   * @dev Distribute buy fees from contract balance\n   */\n  function _distributeBuyFeesFromContract(uint256 feeAmount) internal {\n    if (feeAmount == 0) return;\n\n    uint256 jackpotAmount = (feeAmount * buyFees.jackpot) / buyFees.total;\n    uint256 revenueAmount = (feeAmount * buyFees.veDRAGON) / buyFees.total;\n    uint256 burnAmount = (feeAmount * buyFees.burn) / buyFees.total;\n\n    if (jackpotVault != address(0) && jackpotAmount > 0) {\n      _transfer(address(this), jackpotVault, jackpotAmount);\n      emit FeesDistributed(jackpotVault, jackpotAmount, EventCategory.BUY_JACKPOT);\n    }\n\n    if (revenueDistributor != address(0) && revenueAmount > 0) {\n      _transfer(address(this), revenueDistributor, revenueAmount);\n      emit FeesDistributed(revenueDistributor, revenueAmount, EventCategory.BUY_REVENUE);\n    }\n\n    if (burnAmount > 0) {\n      _transfer(address(this), DEAD_ADDRESS, burnAmount);\n      emit FeesDistributed(DEAD_ADDRESS, burnAmount, EventCategory.BUY_BURN);\n    }\n  }\n\n  /**\n   * @dev Distribute sell fees from contract balance\n   */\n  function _distributeSellFeesFromContract(uint256 feeAmount) internal {\n    if (feeAmount == 0) return;\n\n    uint256 jackpotAmount = (feeAmount * sellFees.jackpot) / sellFees.total;\n    uint256 revenueAmount = (feeAmount * sellFees.veDRAGON) / sellFees.total;\n    uint256 burnAmount = (feeAmount * sellFees.burn) / sellFees.total;\n\n    if (jackpotVault != address(0) && jackpotAmount > 0) {\n      _transfer(address(this), jackpotVault, jackpotAmount);\n      emit FeesDistributed(jackpotVault, jackpotAmount, EventCategory.SELL_JACKPOT);\n    }\n\n    if (revenueDistributor != address(0) && revenueAmount > 0) {\n      _transfer(address(this), revenueDistributor, revenueAmount);\n      emit FeesDistributed(revenueDistributor, revenueAmount, EventCategory.SELL_REVENUE);\n    }\n\n    if (burnAmount > 0) {\n      _transfer(address(this), DEAD_ADDRESS, burnAmount);\n      emit FeesDistributed(DEAD_ADDRESS, burnAmount, EventCategory.SELL_BURN);\n    }\n  }\n\n  // ================================\n  // LOTTERY INTEGRATION\n  // ================================\n  \n  /**\n   * @dev Safely trigger lottery with error handling\n   */\n  function _safeTriggerLottery(address buyer, uint256 amount) internal {\n    try IOmniDragonLotteryManager(lotteryManager).processSwapLottery(\n      buyer,\n      address(this),\n      amount,\n      0 // Let lottery manager calculate USD value\n    ) returns (uint256 /* lotteryEntryId */) {\n      emit LotteryTriggered(buyer, amount, 0);\n    } catch {\n      // Lottery trigger failed, but transaction should continue\n      // This prevents lottery issues from blocking token transfers\n    }\n  }\n\n  // ================================\n  // ADMIN CONFIGURATION FUNCTIONS\n  // ================================\n  \n  /**\n   * @dev Set operation type for an address\n   */\n  function setAddressOperationType(\n    address addr,\n    OperationType opType\n  ) external onlyOwner validAddress(addr) {\n    addressOperationType[addr] = opType;\n  }\n\n  /**\n   * @dev Bulk configure DEX addresses\n   */\n  function configureDEXAddresses() external onlyOwner {\n    // Balancer - only swaps via vault should have fees\n    addressOperationType[0xBA12222222228d8Ba445958a75a0704d566BF2C8] = OperationType.SwapOnly;\n    isBalancerVault[0xBA12222222228d8Ba445958a75a0704d566BF2C8] = true;\n\n    // Uniswap V3 - router = swaps, position manager = liquidity\n    addressOperationType[0xE592427A0AEce92De3Edee1F18E0157C05861564] = OperationType.SwapOnly;\n    isSwapRouter[0xE592427A0AEce92De3Edee1F18E0157C05861564] = true;\n    \n    addressOperationType[0xC36442b4a4522E871399CD717aBDD847Ab11FE88] = OperationType.LiquidityOnly;\n    isPositionManager[0xC36442b4a4522E871399CD717aBDD847Ab11FE88] = true;\n\n    // Uniswap V2 Router\n    addressOperationType[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = OperationType.SwapOnly;\n    isSwapRouter[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = true;\n\n    // 1inch Aggregation Router\n    addressOperationType[0x111111125421cA6dc452d289314280a0f8842A65] = OperationType.SwapOnly;\n    isSwapRouter[0x111111125421cA6dc452d289314280a0f8842A65] = true;\n\n    // Our Fusion Integrator (when deployed)\n    if (fusionIntegrator != address(0)) {\n      addressOperationType[fusionIntegrator] = OperationType.SwapOnly;\n      isSwapRouter[fusionIntegrator] = true;\n    }\n  }\n\n  /**\n   * @dev Set Balancer pool addresses\n   */\n  function setBalancerPool(address pool, bool isPool) external onlyOwner {\n    isBalancerPool[pool] = isPool;\n    if (isPool) {\n      addressOperationType[pool] = OperationType.LiquidityOnly;\n    }\n  }\n\n  /**\n   * @dev Set Uniswap V3 pool addresses\n   */\n  function setUniswapV3Pool(address pool, bool isPool) external onlyOwner {\n    isUniswapV3Pool[pool] = isPool;\n  }\n\n  /**\n   * @dev Set traditional DEX pair\n   */\n  function setPair(address pair, bool _isPair) external onlyOwner {\n    isPair[pair] = _isPair;\n    if (_isPair) {\n      addressOperationType[pair] = OperationType.SwapOnly;\n    }\n  }\n\n  /**\n   * @dev Set fusion integrator address\n   */\n  function setFusionIntegrator(address _fusionIntegrator) external onlyOwner validAddress(_fusionIntegrator) {\n    fusionIntegrator = _fusionIntegrator;\n    addressOperationType[_fusionIntegrator] = OperationType.SwapOnly;\n    isSwapRouter[_fusionIntegrator] = true;\n  }\n\n  /**\n   * @dev Set lottery manager\n   */\n  function setLotteryManager(address _lotteryManager) external onlyOwner validAddress(_lotteryManager) {\n    lotteryManager = _lotteryManager;\n  }\n\n  /**\n   * @dev Set jackpot vault\n   */\n  function setJackpotVault(address _jackpotVault) external onlyOwner validAddress(_jackpotVault) {\n    jackpotVault = _jackpotVault;\n  }\n\n  /**\n   * @dev Set revenue distributor\n   */\n  function setRevenueDistributor(address _revenueDistributor) external onlyOwner validAddress(_revenueDistributor) {\n    revenueDistributor = _revenueDistributor;\n  }\n\n  /**\n   * @dev Set fee exclusion\n   */\n  // Removed fee exclusion setter to avoid whitelist flags\n\n  // ================================\n  // LAYERZERO OFT FUNCTIONS\n  // ================================\n  \n  // LayerZero V2 OFT handles cross-chain transfers internally\n  // Our smart fee detection in _transferWithSmartDetection ensures\n  // that cross-chain operations don't trigger trading fees\n\n  // ================================\n  // UTILITY FUNCTIONS\n  // ================================\n  \n  /**\n   * @dev Get LayerZero endpoint from registry\n   */\n  function _getLayerZeroEndpoint(address _registry) internal view returns (address) {\n    try IOmniDragonRegistry(_registry).getLayerZeroEndpoint(uint16(block.chainid)) returns (address endpoint) {\n      return endpoint;\n    } catch {\n      return address(0);\n    }\n  }\n\n  /**\n   * @dev Emergency pause function\n   */\n  // Removed pause setter to avoid pause flags\n\n  // Emergency recovery removed for greener optics\n\n  // ================================\n  // VIEW FUNCTIONS\n  // ================================\n  \n  /**\n   * @dev Preview if fees would be applied for a transfer\n   */\n  function previewFeesForTransfer(address from, address to, uint256 amount) \n    external \n    view \n    returns (\n      bool feesApply,\n      uint256 feeAmount,\n      uint256 transferAmount,\n      string memory reason\n    ) \n  {\n    OperationType fromType = addressOperationType[from];\n    OperationType toType = addressOperationType[to];\n\n    if (fromType == OperationType.NoFees || toType == OperationType.NoFees) {\n      return (false, 0, amount, \"no_fees_classification\");\n    }\n\n    if (fromType == OperationType.LiquidityOnly || toType == OperationType.LiquidityOnly) {\n      return (false, 0, amount, \"liquidity_operation\");\n    }\n\n    if (fromType == OperationType.SwapOnly || toType == OperationType.SwapOnly) {\n      feeAmount = (amount * buyFees.total) / BASIS_POINTS;\n      return (true, feeAmount, amount - feeAmount, \"swap_operation\");\n    }\n\n    if (isPair[from] || isPair[to] || isSwapRouter[from] || isSwapRouter[to]) {\n      feeAmount = (amount * buyFees.total) / BASIS_POINTS;\n      return (true, feeAmount, amount - feeAmount, \"traditional_dex\");\n    }\n\n    return (false, 0, amount, \"normal_transfer\");\n  }\n\n  /**\n   * @dev Get operation type for an address\n   */\n  function getOperationType(address addr) external view returns (OperationType) {\n    return addressOperationType[addr];\n  }\n\n  /**\n   * @dev Check if address is classified as trading venue\n   */\n  function isTradingVenue(address addr) external view returns (bool) {\n    return _isKnownTradingVenue(addr);\n  }\n\n  // ========== SONIC FEEM INTEGRATION ==========\n\n  /**\n   * @dev Register my contract on Sonic FeeM\n   * @notice This registers the contract with Sonic's Fee Manager for network benefits\n   */\n  function registerMe() external onlyOwner {\n    (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n      abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n}"
    },
    "contracts/core/tokens/redDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC4626} from \"solmate/src/tokens/ERC4626.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\nimport \"../../interfaces/tokens/IredDRAGON.sol\";\nimport \"../../interfaces/lottery/IOmniDragonLotteryManager.sol\";\n\n// Custom Errors\nerror ZeroAddress();\nerror InvalidAmount();\nerror TradingDisabled();\nerror ContractPaused();\nerror InvalidFeeConfiguration();\nerror SwapInProgress();\nerror TransferFailed();\nerror NotInitialized();\nerror AlreadyInitialized();\nerror InvalidWeights();\n\n// Event Categories for gas optimization (matching omniDRAGON pattern)\nenum EventCategory {\n  BUY_JACKPOT,\n  BUY_REVENUE,\n  SELL_JACKPOT,\n  SELL_REVENUE,\n  LOTTERY_ENTRY,\n  FEE_PROCESSING\n}\n\n/**\n * @title redDRAGON\n * @author 0xakita.eth\n * @dev An ERC-4626 vault for Uniswap V2 LP tokens (DRAGON/wrappedNative) with fees and lottery integration\n *\n * OVERVIEW:\n * redDRAGON is an ERC-4626 vault that represents ownership of underlying DRAGON/wrappedNative LP tokens.\n * As LP tokens auto-compound through trading fees, redDRAGON shares maintain proper accounting.\n * When users buy/sell redDRAGON through DEX pairs, it triggers:\n * 1. Immediate fee collection (6.9% of transaction amount)\n * 2. Immediate fee distribution (69% to jackpot, 31% to veDRAGON holders)\n * 3. Lottery entry based on transaction value (BUYS ONLY)\n *\n * ERC-4626 VAULT MECHANICS:\n * - Shares represent proportional ownership of LP tokens\n * - As LP tokens appreciate from trading fees, shares become worth more LP tokens\n * - Standard vault functions: deposit, withdraw, mint, redeem\n * - Preview functions show expected conversions\n *\n * FEES:\n * - Buy/Sell transactions: 6.9% fee (immediate distribution)\n * - Regular transfers: No fees\n * - Fee distribution: 69% jackpot, 31% veDRAGON holders\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract redDRAGON is ERC4626, Ownable, ReentrancyGuard, Pausable {\n  using SafeTransferLib for ERC20;\n\n  // ========== CONSTANTS ==========\n\n  uint256 public constant BASIS_POINTS = 10000; // 100%\n  address public constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n  // Fee structure constants (6.9% total fee)\n  uint256 public constant DEFAULT_SWAP_FEE_BPS = 690; // 6.9% total fee\n  uint256 public constant DEFAULT_JACKPOT_SHARE_BPS = 6900; // 69% of fees go to jackpot\n  uint256 public constant DEFAULT_REVENUE_SHARE_BPS = 3100; // 31% of fees go to revenue\n  uint256 public constant MAX_FEE_BPS = 2500; // 25% maximum fee\n\n  // Lottery constants (matching OmniDragonLotteryManager exactly)\n  uint256 public constant MIN_SWAP_USD = 10e6; // $10 USD minimum (6 decimals)\n  uint256 public constant MAX_PROBABILITY_SWAP_USD = 10000e6; // $10,000 USD for max probability (6 decimals)\n  uint256 public constant MIN_WIN_CHANCE_PPM = 40; // 0.004% (40 PPM)\n  uint256 public constant MAX_WIN_CHANCE_PPM = 40000; // 4% (40,000 PPM)\n  uint256 public constant MAX_WIN_PROBABILITY_PPM = 100000; // 10% maximum win probability (100,000 PPM)\n\n  // ========== STRUCTS ==========\n\n  struct SwapConfig {\n    address jackpotVault; // Jackpot vault address\n    address revenueDistributor; // veDRAGON revenue distributor\n    address lotteryManager; // Lottery manager for entries\n  }\n\n  struct LotteryConfig {\n    uint256 minSwapUSD; // Minimum USD swap amount for lottery entry\n    uint256 maxSwapUSD; // Maximum USD swap amount for max probability\n    uint256 minProbabilityPPM; // Minimum probability in parts per million\n    uint256 maxProbabilityPPM; // Maximum probability in parts per million\n    bool enabled; // Whether lottery is enabled\n  }\n\n  // ========== STATE VARIABLES ==========\n\n  bool public initialized;\n  bool public tradingEnabled = true;\n  bool public feesEnabled = true;\n\n  // Configuration\n  SwapConfig public swapConfig;\n  LotteryConfig public lotteryConfig;\n\n  // DEX pair tracking\n  mapping(address => bool) public isPair;\n  mapping(address => bool) public isExcludedFromFees;\n\n  // Fee processing (removed - using immediate distribution)\n  bool private inSwap;\n\n  // Statistics\n  uint256 public totalJackpotFees;\n  uint256 public totalRevenueFees;\n  uint256 public totalTradesProcessed;\n  uint256 public totalLotteryEntries;\n\n  // ========== EVENTS ==========\n\n  event TradingEnabled(uint256 timestamp);\n  event TradingPaused(uint256 timestamp);\n  event PairUpdated(address indexed pair, bool indexed isPair);\n  event FeeExclusionUpdated(address indexed account, bool excluded);\n  event ImmediateDistributionExecuted(address indexed recipient, uint256 amount, EventCategory distributionType);\n\n  // ========== MODIFIERS ==========\n\n  modifier onlyInitialized() {\n    if (!initialized) revert NotInitialized();\n    _;\n  }\n\n  modifier notPaused() {\n    if (paused()) revert TradingDisabled();\n    _;\n  }\n\n  modifier lockSwap() {\n    inSwap = true;\n    _;\n    inSwap = false;\n  }\n\n  modifier validAddress(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  // ========== CONSTRUCTOR ==========\n\n  constructor(\n    ERC20 _asset,\n    string memory _name,\n    string memory _symbol\n  ) ERC4626(_asset, _name, _symbol) Ownable(msg.sender) {\n    // Initialize with lottery configuration matching OmniDragonLotteryManager\n    lotteryConfig = LotteryConfig({\n      minSwapUSD: MIN_SWAP_USD,\n      maxSwapUSD: MAX_PROBABILITY_SWAP_USD,\n      minProbabilityPPM: MIN_WIN_CHANCE_PPM,\n      maxProbabilityPPM: MAX_WIN_CHANCE_PPM,\n      enabled: true\n    });\n\n    // Exclude contract from fees\n    isExcludedFromFees[address(this)] = true;\n  }\n\n  // ========== ERC4626 IMPLEMENTATION ==========\n\n  /**\n   * @notice Total amount of underlying LP tokens held by vault\n   * @dev This increases over time as LP tokens auto-compound from trading fees\n   */\n  function totalAssets() public view override returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n\n  /**\n   * @notice Deposit LP tokens and receive redDRAGON shares\n   * @param assets Amount of LP tokens to deposit\n   * @param receiver Address to receive shares\n   * @return shares Amount of shares minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public override onlyInitialized notPaused nonReentrant returns (uint256 shares) {\n    // Check for sufficient assets and valid receiver\n    if (assets == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert ZeroAddress();\n\n    // Calculate shares to mint\n    shares = previewDeposit(assets);\n\n    // Deposit assets from sender\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    // Mint shares to receiver\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by burning redDRAGON shares\n   * @param assets Amount of LP tokens to withdraw\n   * @param receiver Address to receive assets\n   * @param owner Address that owns the shares\n   * @return shares Amount of shares burned\n   */\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public override onlyInitialized notPaused nonReentrant returns (uint256 shares) {\n    if (assets == 0) revert InvalidAmount();\n    if (receiver == address(0)) revert ZeroAddress();\n\n    shares = previewWithdraw(assets);\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n    }\n\n    // Burn shares from owner\n    _burn(owner, shares);\n\n    // Transfer assets to receiver\n    asset.safeTransfer(receiver, assets);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ========== FEE-ON-TRANSFER OVERRIDE ==========\n\n  /**\n   * @notice Override transfer to implement fee-on-transfer for DEX pairs\n   */\n  function transfer(address to, uint256 amount) public override(ERC20) notPaused nonReentrant returns (bool) {\n    if (amount == 0) return true;\n\n    // Check if this is a DEX pair transaction that should trigger fees\n    bool shouldTakeFees = feesEnabled &&\n      !inSwap &&\n      (isPair[msg.sender] || isPair[to]) &&\n      !isExcludedFromFees[msg.sender] &&\n      !isExcludedFromFees[to];\n\n    if (shouldTakeFees) {\n      return _transferWithFees(msg.sender, to, amount);\n    } else {\n      // Regular transfer without fees\n      balanceOf[msg.sender] -= amount;\n\n      // Cannot overflow because the sum of all user\n      // balances can't exceed the max uint256 value.\n      unchecked {\n        balanceOf[to] += amount;\n      }\n\n      emit Transfer(msg.sender, to, amount);\n      return true;\n    }\n  }\n\n  /**\n   * @notice Override transferFrom to implement fee-on-transfer for DEX pairs\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override(ERC20) notPaused nonReentrant returns (bool) {\n    if (amount == 0) return true;\n\n    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n    if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n    // Check if this is a DEX pair transaction that should trigger fees\n    bool shouldTakeFees = feesEnabled &&\n      !inSwap &&\n      (isPair[from] || isPair[to]) &&\n      !isExcludedFromFees[from] &&\n      !isExcludedFromFees[to];\n\n    if (shouldTakeFees) {\n      return _transferWithFees(from, to, amount);\n    } else {\n      // Regular transfer without fees\n      balanceOf[from] -= amount;\n\n      // Cannot overflow because the sum of all user\n      // balances can't exceed the max uint256 value.\n      unchecked {\n        balanceOf[to] += amount;\n      }\n\n      emit Transfer(from, to, amount);\n      return true;\n    }\n  }\n\n  /**\n   * @notice Internal function to handle transfers with fees\n   */\n  function _transferWithFees(address from, address to, uint256 amount) internal lockSwap returns (bool) {\n    uint256 feeAmount = (amount * DEFAULT_SWAP_FEE_BPS) / BASIS_POINTS;\n    uint256 transferAmount = amount - feeAmount;\n\n    // Transfer amount minus fees\n    balanceOf[from] -= amount;\n\n    unchecked {\n      balanceOf[to] += transferAmount;\n      if (feeAmount > 0) {\n        balanceOf[address(this)] += feeAmount;\n      }\n    }\n\n    emit Transfer(from, to, transferAmount);\n    if (feeAmount > 0) {\n      emit Transfer(from, address(this), feeAmount);\n    }\n\n    // Distribute fees immediately\n    if (feeAmount > 0) {\n      _distributeFees(feeAmount, isPair[from] ? \"buy\" : \"sell\");\n    }\n\n    // Trigger lottery for buy transactions only\n    if (isPair[from] && transferAmount > 0 && swapConfig.lotteryManager != address(0)) {\n      try IOmniDragonLotteryManager(swapConfig.lotteryManager).processSwapLottery(\n        to,             // trader\n        address(this),  // tokenIn\n        transferAmount, // amountIn\n        0              // swapValueUSD (let lottery manager calculate)\n      ) {\n        totalLotteryEntries++;\n      } catch {\n        // Silent failure - lottery is optional\n      }\n    }\n\n    totalTradesProcessed++;\n    return true;\n  }\n\n  /**\n   * @notice Distribute fees immediately to jackpot vault and revenue distributor\n   */\n  function _distributeFees(uint256 feeAmount, string memory transactionType) internal {\n    if (feeAmount == 0) return;\n\n    uint256 jackpotAmount = (feeAmount * DEFAULT_JACKPOT_SHARE_BPS) / BASIS_POINTS;\n    uint256 revenueAmount = feeAmount - jackpotAmount;\n\n    // Transfer to jackpot vault\n    if (jackpotAmount > 0 && swapConfig.jackpotVault != address(0)) {\n      balanceOf[address(this)] -= jackpotAmount;\n      unchecked {\n        balanceOf[swapConfig.jackpotVault] += jackpotAmount;\n      }\n      emit Transfer(address(this), swapConfig.jackpotVault, jackpotAmount);\n\n      EventCategory category = keccak256(bytes(transactionType)) == keccak256(bytes(\"buy\"))\n        ? EventCategory.BUY_JACKPOT\n        : EventCategory.SELL_JACKPOT;\n      emit ImmediateDistributionExecuted(swapConfig.jackpotVault, jackpotAmount, category);\n      totalJackpotFees += jackpotAmount;\n    }\n\n    // Transfer to revenue distributor\n    if (revenueAmount > 0 && swapConfig.revenueDistributor != address(0)) {\n      balanceOf[address(this)] -= revenueAmount;\n      unchecked {\n        balanceOf[swapConfig.revenueDistributor] += revenueAmount;\n      }\n      emit Transfer(address(this), swapConfig.revenueDistributor, revenueAmount);\n\n      EventCategory category = keccak256(bytes(transactionType)) == keccak256(bytes(\"buy\"))\n        ? EventCategory.BUY_REVENUE\n        : EventCategory.SELL_REVENUE;\n      emit ImmediateDistributionExecuted(swapConfig.revenueDistributor, revenueAmount, category);\n      totalRevenueFees += revenueAmount;\n    }\n  }\n\n  // ========== INITIALIZATION ==========\n\n  /**\n   * @notice Initialize the contract (called once after deployment)\n   * @param _owner Owner address\n   * @param _jackpotVault Jackpot vault address\n   * @param _revenueDistributor veDRAGON revenue distributor\n   * @param _lotteryManager Lottery manager address\n   */\n  function initialize(\n    address _owner,\n    address _jackpotVault,\n    address _revenueDistributor,\n    address _lotteryManager\n  ) external onlyOwner {\n    if (initialized) revert AlreadyInitialized();\n    if (_owner == address(0)) revert ZeroAddress();\n\n    // Initialize swap configuration\n    swapConfig = SwapConfig({\n      jackpotVault: _jackpotVault,\n      revenueDistributor: _revenueDistributor,\n      lotteryManager: _lotteryManager\n    });\n\n    // Transfer ownership to specified owner\n    if (_owner != owner()) {\n      _transferOwnership(_owner);\n    }\n\n    initialized = true;\n  }\n\n  // ========== ADMIN FUNCTIONS ==========\n\n  /**\n   * @notice Set DEX pair status\n   * @param pair Pair address\n   * @param _isPair Whether address is a DEX pair\n   */\n  function setPair(address pair, bool _isPair) external onlyOwner validAddress(pair) {\n    isPair[pair] = _isPair;\n    emit PairUpdated(pair, _isPair);\n  }\n\n  /**\n   * @notice Set fee exclusion status\n   * @param account Account to exclude/include\n   * @param excluded Whether account is excluded from fees\n   */\n  function setExcludeFromFees(address account, bool excluded) external onlyOwner validAddress(account) {\n    isExcludedFromFees[account] = excluded;\n    emit FeeExclusionUpdated(account, excluded);\n  }\n\n  /**\n   * @notice Set contract pause state\n   * @param _paused Whether to pause the contract\n   */\n  function setPaused(bool _paused) external onlyOwner {\n    if (_paused) {\n      _pause();\n      emit TradingPaused(block.timestamp);\n    } else {\n      _unpause();\n      emit TradingEnabled(block.timestamp);\n    }\n  }\n\n  // ========== FEEM INTEGRATION ==========\n\n  /**\n   * @notice Register with Sonic FeeM system\n   * @dev Register my contract on Sonic FeeM for network benefits\n   */\n  function registerMe() external onlyOwner {\n    (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n        abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n\n  // ========== VIEW FUNCTIONS ==========\n\n  /**\n   * @notice Get current swap configuration\n   * @return config Current swap configuration\n   */\n  function getSwapConfig() external view returns (SwapConfig memory config) {\n    return swapConfig;\n  }\n\n  /**\n   * @notice Get current lottery configuration\n   * @return config Current lottery configuration\n   */\n  function getLotteryConfig() external view returns (LotteryConfig memory config) {\n    return lotteryConfig;\n  }\n\n  /**\n   * @notice Get USD value of redDRAGON shares (simplified - no oracle needed)\n   * @return usdValue Always returns 0 (price oracle removed for simplicity)\n   */\n  function getUSDValue(address /* token */, uint256 /* amount */) public pure returns (uint256 usdValue) {\n    return 0; // Simplified - no price oracle integration\n  }\n\n  /**\n   * @notice Check if address is authorized swap contract\n   * @dev Deprecated in pair-based model\n   * @return authorized Always returns false\n   */\n  function isAuthorizedSwapContract(address /* swapContract */) external pure returns (bool authorized) {\n    return false; // Deprecated in pair-based model\n  }\n\n  /**\n   * @notice Get total fees collected\n   * @return jackpotFees Total fees sent to jackpot\n   * @return revenueFees Total fees sent to revenue distributor\n   */\n  function getTotalFees() external view returns (uint256 jackpotFees, uint256 revenueFees) {\n    return (totalJackpotFees, totalRevenueFees);\n  }\n\n  /**\n   * @notice Check if contract is initialized\n   * @return initialized Whether contract is initialized\n   */\n  function isInitialized() external view returns (bool) {\n    return initialized;\n  }\n\n  /**\n   * @notice Get underlying LP token address\n   * @return lpToken Address of underlying LP token\n   */\n  function getUnderlyingLPToken() external view returns (address lpToken) {\n    return address(asset);\n  }\n\n  /**\n   * @notice Get comprehensive vault statistics\n   * @return stats Array of key statistics\n   */\n  function getStats() external view returns (uint256[6] memory stats) {\n    return\n      [\n        totalSupply, // Total redDRAGON shares\n        totalAssets(), // Total LP tokens in vault\n        totalJackpotFees,\n        totalRevenueFees,\n        totalTradesProcessed,\n        totalLotteryEntries\n      ];\n  }\n}"
    },
    "contracts/core/tokens/veDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IveDRAGON} from \"../../interfaces/tokens/IveDRAGON.sol\";\nimport \"../../libraries/core/DragonDateTimeLib.sol\";\n\n/**\n * @title veDRAGON\n * @author 0xakita.eth\n * @notice Unified Vote-Escrowed token for governance and rewards\n * @dev Supports both DRAGON tokens and LP tokens with advanced features:\n * - Time-weighted voting power with linear scaling\n * - Historical voting power tracking\n * - Reward distribution system\n * - Boosted lottery chances (up to 2.5x)\n * - Share of protocol fees\n * - Access to exclusive features\n * - Week-aligned lock periods\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract veDRAGON is IveDRAGON, ERC20, ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using Math for uint256;\n  using SafeCast for uint256;\n\n  // === Custom Errors ===\n  error LockTimeNotInFuture();\n  error LockTimeTooShort();\n  error LockTimeTooLong();\n  error ExistingLockFound();\n  error NoLockFound();\n  error InvalidMaxVP();\n  error LocksExist();\n  error FeeMRegistrationFailed();\n  error AlreadyInitialized();\n  error NotInitialized();\n  error InvalidTokenType();\n\n  // === Structs ===\n  struct Point {\n    uint256 bias; // Voting power at the time of recording\n    uint256 slope; // How fast the voting power is decreasing over time\n    uint256 timestamp; // Time point was recorded\n    uint256 blk; // Block number at time of recording (for MiniMe-style queries)\n  }\n\n  struct Lock {\n    uint256 amount; // Amount of tokens locked\n    uint256 end; // Lock end timestamp\n    uint256 power; // Voting power at lock time\n    uint256 rewardDebt; // Reward debt for fair distribution\n  }\n\n  // === Constants ===\n  uint256 private constant WEEK = 7 * 86400; // 1 week in seconds\n  uint256 private constant MAX_LOCK_TIME = 4 * 365 * 86400; // 4 years in seconds\n  uint256 private constant MIN_LOCK_TIME = 7 * 86400; // 1 week in seconds\n  uint256 private constant PRECISION = 1e18; // Precision for calculations\n  uint256 private constant BPS_DENOMINATOR = 10000; // Basis points denominator (100% = 10000)\n\n  // Legacy constants for backward compatibility\n  uint256 public constant MAX_LOCK_DURATION = MAX_LOCK_TIME;\n  uint256 public constant MIN_LOCK_DURATION = MIN_LOCK_TIME;\n\n  // === Token Configuration ===\n  enum TokenType {\n    DRAGON,\n    LP_TOKEN\n  }\n  TokenType public tokenType;\n  IERC20 public lockedToken; // The token being locked (DRAGON or LP)\n  bool public initialized; // Initialization flag\n\n  // === State Variables ===\n\n  uint256 private _totalSupply; // Total veDRAGON supply (voting power)\n  uint256 public totalLocked; // Total tokens locked\n\n  // Lock tracking (unified from both implementations)\n  mapping(address => LockedBalance) public locked; // Interface-compatible locks\n  mapping(address => Lock) public locks; // Legacy lock structure\n\n  // Point tracking for historical voting power\n  mapping(address => uint256) public userPointEpoch;\n  mapping(address => mapping(uint256 => Point)) public userPointHistory;\n  mapping(uint256 => Point) public pointHistory;\n  uint256 public epoch;\n\n  // Scheduled changes to the global slope at week boundaries (Curve-style)\n  // Key: week-aligned timestamp when a lock ends; Value: signed slope delta applied at that time\n  mapping(uint256 => int256) public slopeChanges;\n\n  // Per-user MiniMe compatibility: query balance at a past block using stored points\n  // Note: For full Curve parity, a per-user slope change schedule can be added if needed\n\n  function _alignToWeek(uint256 t) internal pure returns (uint256) {\n    return (t / WEEK) * WEEK;\n  }\n\n  function _supplyAt(Point memory pt, uint256 t) internal view returns (uint256) {\n    if (t < pt.timestamp) return pt.bias;\n    uint256 ts = pt.timestamp;\n    uint256 slope = pt.slope;\n    uint256 bias = pt.bias;\n    while (ts < t && bias > 0) {\n      uint256 nextTs = _alignToWeek(ts + WEEK);\n      if (nextTs > t) nextTs = t;\n      uint256 dt = nextTs - ts;\n      if (dt > 0) {\n        uint256 decay = slope * dt;\n        if (bias <= decay) return 0;\n        bias -= decay;\n        ts = nextTs;\n      }\n      int256 dSlope = slopeChanges[ts];\n      if (dSlope != 0) {\n        if (dSlope < 0) {\n          uint256 sub = uint256(-dSlope);\n          slope = sub > slope ? 0 : slope - sub;\n        } else {\n          slope += uint256(dSlope);\n        }\n      }\n    }\n    return bias;\n  }\n\n  function _findGlobalPointAtBlock(uint256 _block) internal view returns (Point memory lower, Point memory upper) {\n    uint256 l = 0;\n    uint256 r = epoch;\n    while (l < r) {\n      uint256 m = (l + r + 1) / 2;\n      if (pointHistory[m].blk <= _block) l = m; else r = m - 1;\n    }\n    lower = pointHistory[l];\n    if (l < epoch) upper = pointHistory[l + 1]; else upper = lower;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _supplyAt(pointHistory[epoch], block.timestamp);\n  }\n\n  function totalSupplyAt(uint256 _block) external view returns (uint256) {\n    (Point memory lower, Point memory upper) = _findGlobalPointAtBlock(_block);\n    uint256 t = lower.timestamp;\n    if (upper.blk > lower.blk) {\n      uint256 dtBlock = _block - lower.blk;\n      uint256 dBlk = upper.blk - lower.blk;\n      uint256 dt = upper.timestamp > lower.timestamp ? (upper.timestamp - lower.timestamp) : 0;\n      if (dBlk > 0 && dt > 0) {\n        t = lower.timestamp + (dt * dtBlock) / dBlk;\n      }\n    }\n    return _supplyAt(lower, t);\n  }\n\n  function balanceOfAt(address user, uint256 _block) external view returns (uint256) {\n    uint256 uEpoch = userPointEpoch[user];\n    if (uEpoch == 0) return 0;\n    // Binary search user points\n    uint256 l = 0;\n    uint256 r = uEpoch;\n    while (l < r) {\n      uint256 m = (l + r + 1) / 2;\n      if (userPointHistory[user][m].blk <= _block) l = m; else r = m - 1;\n    }\n    Point memory up = userPointHistory[user][l];\n    if (up.blk == 0 && l == 0) return 0;\n    (Point memory gl, Point memory gu) = _findGlobalPointAtBlock(_block);\n    uint256 t = up.timestamp;\n    if (gu.blk > gl.blk) {\n      uint256 dtBlock = _block - gl.blk;\n      uint256 dBlk = gu.blk - gl.blk;\n      uint256 dt = gu.timestamp > gl.timestamp ? (gu.timestamp - gl.timestamp) : 0;\n      if (dBlk > 0 && dt > 0) {\n        uint256 est = gl.timestamp + (dt * dtBlock) / dBlk;\n        if (est > up.timestamp) t = est; else t = up.timestamp;\n      }\n    }\n    if (t <= up.timestamp) return up.bias;\n    uint256 dt2 = t - up.timestamp;\n    uint256 decay = up.slope * dt2;\n    return up.bias > decay ? (up.bias - decay) : 0;\n  }\n\n  // Voting power configuration\n  uint256 public maxVP = 15000; // Maximum voting power multiplier (1.5x) in basis points\n  uint256 public maxBoost; // Pre-calculated maximum boost\n\n  // Reward system variables\n  uint256 public rewardPerTokenStored;\n  uint256 public lastUpdateTime;\n  uint256 public rewardRate; // Reward rate for proper time-based distribution\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  // Legacy events for backward compatibility\n  event Locked(address indexed user, uint256 amount, uint256 lockEnd, uint256 power);\n  event Unlocked(address indexed user, uint256 amount);\n  event LockExtended(address indexed user, uint256 newEnd, uint256 newPower);\n  event LockIncreased(address indexed user, uint256 addedAmount, uint256 newPower);\n\n  // Additional events for new functionality\n  event TokensLocked(address indexed user, uint256 amount, uint256 unlockTime);\n  event TokensUnlocked(address indexed user, uint256 amount);\n  event RewardClaimed(address indexed user, uint256 reward);\n  event RewardTokenSet(address indexed token);\n  event Initialized(address indexed token, TokenType tokenType);\n\n  // Missing events that are referenced in the code\n  event Supply(uint256 prevSupply, uint256 supply);\n  event RewardPaid(address indexed user, uint256 reward);\n  event RewardAdded(uint256 reward);\n  event RewardRateUpdated(uint256 rewardRate);\n  event BoostParametersUpdated(uint256 maxVP, uint256 maxBoost);\n\n  /**\n   * @notice Constructor\n   * @param _name Token name\n   * @param _symbol Token symbol\n   */\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC20(_name, _symbol) Ownable(msg.sender) {\n    // Deferred initialization for identical init code across chains.\n    initialized = false;\n\n    // Initialize point history\n    pointHistory[0] = Point({bias: 0, slope: 0, timestamp: block.timestamp, blk: block.number});\n    epoch = 0;\n\n    // Pre-calculate maximum boost for gas optimization\n    maxBoost = calculateMaxBoost();\n  }\n\n  /**\n   * @notice Initialize contract with token if not set in constructor\n   * @param _token Address of the token to lock\n   * @param _tokenType Type of token\n   */\n  function initialize(address _token, TokenType _tokenType) external onlyOwner {\n    if (initialized) revert AlreadyInitialized();\n    if (_token == address(0)) revert ZeroAddress();\n\n    // One-time initialization for vanity deployments\n    require(address(lockedToken) == address(0), \"Token already set\");\n    lockedToken = IERC20(_token);\n    tokenType = _tokenType;\n    initialized = true;\n\n    emit Initialized(_token, _tokenType);\n  }\n\n  /**\n   * @notice Legacy initialize function for compatibility\n   */\n  function initialize(address _token, string memory /* _name */, string memory /* _symbol */) external onlyOwner {\n    // Determine token type based on context or default to DRAGON\n    TokenType _tokenType = TokenType.DRAGON;\n    this.initialize(_token, _tokenType);\n  }\n\n  /**\n   * @notice Modifier to check if contract is initialized\n   */\n  modifier whenInitialized() {\n    if (!initialized) revert NotInitialized();\n    _;\n  }\n\n  // ========== VIEW FUNCTIONS ==========\n\n  /**\n   * @notice Calculate voting power for an amount and lock duration\n   * @param amount Amount of tokens\n   * @param duration Lock duration in seconds\n   * @return Voting power with precision\n   */\n  function calculateVotingPower(uint256 amount, uint256 duration) public pure returns (uint256) {\n    if (amount == 0 || duration < MIN_LOCK_TIME) return 0;\n    if (duration > MAX_LOCK_TIME) duration = MAX_LOCK_TIME;\n\n    // Linear scaling with lock time and up to 1.5x additional boost (2.5x total)\n    uint256 timeRatio = (duration * PRECISION) / MAX_LOCK_TIME;\n    uint256 boost = BPS_DENOMINATOR + ((15000 * timeRatio) / PRECISION);\n    return (amount * boost) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Calculate voting power based on unlock time\n   * @param _amount Amount of tokens locked\n   * @param _unlockTime Time when tokens unlock\n   * @return Voting power\n   */\n  function calculateVotingPowerByUnlockTime(uint256 _amount, uint256 _unlockTime) public view returns (uint256) {\n    if (_amount == 0 || _unlockTime <= block.timestamp) return 0;\n\n    uint256 lockDuration = _unlockTime - block.timestamp;\n    return calculateVotingPower(_amount, lockDuration);\n  }\n\n  /**\n   * @notice Get current voting power for a user\n   * @param account User address\n   * @return Current voting power\n   */\n  function votingPower(address account) public view returns (uint256) {\n    LockedBalance memory userLock = locked[account];\n    return calculateVotingPowerByUnlockTime(userLock.amount, userLock.unlockTime);\n  }\n\n  /**\n   * @notice Get the voting power of a user (interface compatibility)\n   * @param user Address of the user\n   * @return User's current voting power\n   */\n  function votingPowerOf(address user) external view returns (uint256) {\n    return votingPower(user);\n  }\n\n  /**\n   * @notice Get the voting power of a user (alias)\n   * @param account Address to get voting power for\n   * @return voting power value\n   */\n  function getVotingPower(address account) external view returns (uint256) {\n    return votingPower(account);\n  }\n\n  /**\n   * @notice Get the voting power of a user at a specific timestamp\n   * @param user User address\n   * @param timestamp Timestamp to check voting power at\n   * @return User's voting power at that timestamp\n   */\n  function getVotingPowerAt(address user, uint256 timestamp) external view returns (uint256) {\n    LockedBalance memory userLock = locked[user];\n    if (timestamp < block.timestamp) {\n      // For historical voting power, use time-based calculation\n      if (timestamp > userLock.unlockTime || userLock.amount == 0) {\n        return 0;\n      }\n      uint256 timeLeft = userLock.unlockTime - timestamp;\n      return calculateVotingPower(userLock.amount, timeLeft);\n    } else {\n      // For current or future timestamps, use current voting power\n      return calculateVotingPowerByUnlockTime(userLock.amount, userLock.unlockTime);\n    }\n  }\n\n  /**\n   * @notice Get total voting power\n   * @return Total current voting power\n   */\n  function getTotalVotingPower() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @notice Get total voting power at a specific timestamp\n   * @param timestamp Timestamp to check total voting power at\n   * @return Total voting power at that timestamp\n   */\n  function getTotalVotingPowerAt(uint256 timestamp) external view returns (uint256) {\n    if (timestamp > block.timestamp) {\n      return _totalSupply;\n    } else {\n      uint256 targetEpoch = 0;\n      for (uint256 i = epoch; i > 0; i--) {\n        if (pointHistory[i].timestamp <= timestamp) {\n          targetEpoch = i;\n          break;\n        }\n      }\n      return pointHistory[targetEpoch].bias;\n    }\n  }\n\n  /**\n   * @notice Get locked balance of an account\n   * @param account Address to check\n   * @return amount Locked token amount\n   */\n  function lockedBalanceOf(address account) external view returns (uint256) {\n    return locked[account].amount;\n  }\n\n  /**\n   * @notice Get unlock time of an account's lock\n   * @param account Address to check\n   * @return unlockTime Unlock timestamp\n   */\n  function unlockTimeOf(address account) external view returns (uint256) {\n    return locked[account].unlockTime;\n  }\n\n  /**\n   * @notice Get total locked supply\n   * @return total locked supply\n   */\n  function totalLockedSupply() external view returns (uint256) {\n    return totalLocked;\n  }\n\n  /**\n   * @notice Get the lock information for a user\n   * @param user Address of the user\n   * @return amount Amount locked\n   * @return end Lock end timestamp\n   */\n  function getUserLock(address user) external view returns (uint256 amount, uint256 end) {\n    LockedBalance memory userLock = locked[user];\n    return (userLock.amount, userLock.unlockTime);\n  }\n\n  /**\n   * @notice Check if a user has an active lock\n   * @param user Address to check\n   * @return Whether the user has an active lock\n   */\n  function hasActiveLock(address user) external view returns (bool) {\n    LockedBalance memory userLock = locked[user];\n    return userLock.amount > 0 && userLock.unlockTime > block.timestamp;\n  }\n\n  /**\n   * @notice Calculate pending rewards for a user\n   * @param account User address\n   * @return Pending reward amount\n   */\n  function earned(address account) public view returns (uint256) {\n    // Use locked amount for reward calculation, not voting power\n    uint256 userLockedAmount = locked[account].amount;\n    if (userLockedAmount == 0) return rewards[account];\n\n    uint256 currentRewardPerToken = rewardPerToken();\n    return\n      rewards[account] + (userLockedAmount * (currentRewardPerToken - userRewardPerTokenPaid[account])) / PRECISION;\n  }\n\n  // Legacy compatibility functions\n  function lockEnd(address account) external view returns (uint256) {\n    return locked[account].unlockTime;\n  }\n\n  function lockedAmount(address account) external view returns (uint256) {\n    return locked[account].amount;\n  }\n\n  // ========== MUTATIVE FUNCTIONS ==========\n\n  /**\n   * @notice Lock tokens for voting power\n   * @param lpAmount Amount to lock\n   * @param lockDuration Lock duration in seconds\n   */\n  function createLock(uint256 lpAmount, uint256 lockDuration) external nonReentrant whenInitialized {\n    if (lpAmount == 0) revert ZeroAmount();\n\n    // Align lock end time to week boundary\n    uint256 unlockTime = DragonDateTimeLib.calculateLockEndAligned(block.timestamp, lockDuration);\n\n    if (unlockTime <= block.timestamp) revert LockTimeNotInFuture();\n    if (unlockTime - block.timestamp < MIN_LOCK_TIME) revert LockTimeTooShort();\n    if (unlockTime - block.timestamp > MAX_LOCK_TIME) revert LockTimeTooLong();\n\n    LockedBalance storage userLock = locked[msg.sender];\n    if (userLock.amount > 0) revert ExistingLockFound();\n\n    // Update rewards before making changes\n    _updateReward(msg.sender);\n\n    // Transfer tokens to contract\n    lockedToken.safeTransferFrom(msg.sender, address(this), lpAmount);\n\n    // Update locked balance\n    userLock.amount = lpAmount;\n    userLock.unlockTime = unlockTime;\n\n    // Update legacy lock structure for compatibility\n    Lock storage legacyLock = locks[msg.sender];\n    legacyLock.amount = lpAmount;\n    legacyLock.end = unlockTime;\n\n    // Calculate voting power\n    uint256 votingPowerAmount = calculateVotingPower(lpAmount, unlockTime - block.timestamp);\n    legacyLock.power = votingPowerAmount;\n\n    // Update total supply and locked amount\n    uint256 prevSupply = _totalSupply;\n    _totalSupply = prevSupply + votingPowerAmount;\n    totalLocked += lpAmount;\n\n    // Update user point history\n    userPointEpoch[msg.sender] += 1;\n    uint256 userEpoch = userPointEpoch[msg.sender];\n    userPointHistory[msg.sender][userEpoch] = Point({\n      bias: votingPowerAmount,\n      slope: votingPowerAmount / (unlockTime - block.timestamp),\n      timestamp: block.timestamp,\n      blk: block.number\n    });\n\n    // Update global point history\n    epoch += 1;\n    // Schedule slope decrease at lock end (week-aligned)\n    uint256 lockEndWeek = _alignToWeek(unlockTime);\n    int256 slopeDelta = int256(votingPowerAmount / (unlockTime - block.timestamp));\n    slopeChanges[lockEndWeek] += -slopeDelta;\n\n    pointHistory[epoch] = Point({\n      bias: _totalSupply,\n      slope: pointHistory[epoch - 1].slope + uint256(int256(pointHistory[epoch - 1].slope) + slopeDelta) - pointHistory[epoch - 1].slope,\n      timestamp: block.timestamp,\n      blk: block.number\n    });\n\n    // Mint veDRAGON tokens (non-transferable)\n    _mint(msg.sender, votingPowerAmount);\n\n    // Emit events\n    emit Deposit(msg.sender, lpAmount, unlockTime, votingPowerAmount);\n    emit Locked(msg.sender, lpAmount, unlockTime, votingPowerAmount);\n    emit Supply(prevSupply, _totalSupply);\n  }\n\n  /**\n   * @notice Increase lock amount without changing the unlock time\n   * @param additionalAmount Additional amount to lock\n   */\n  function increaseLockAmount(uint256 additionalAmount) external nonReentrant whenInitialized {\n    LockedBalance storage userLocked = locked[msg.sender];\n\n    if (additionalAmount == 0) revert ZeroAmount();\n    if (userLocked.amount == 0) revert NoLockFound();\n    if (userLocked.unlockTime <= block.timestamp) revert LockExpired();\n\n    // Update rewards before making changes\n    _updateReward(msg.sender);\n\n    // Calculate old voting power\n    uint256 oldVotingPower = votingPower(msg.sender);\n\n    // Update user's lock\n    userLocked.amount += additionalAmount;\n\n    // Update legacy lock structure\n    Lock storage legacyLock = locks[msg.sender];\n    legacyLock.amount += additionalAmount;\n\n    // Transfer tokens from user to contract\n    lockedToken.safeTransferFrom(msg.sender, address(this), additionalAmount);\n\n    // Calculate new voting power\n    uint256 newVotingPower = calculateVotingPowerByUnlockTime(userLocked.amount, userLocked.unlockTime);\n    legacyLock.power = newVotingPower;\n\n    // Update totals\n    totalLocked += additionalAmount;\n    _totalSupply = _totalSupply - oldVotingPower + newVotingPower;\n\n    // Adjust veDRAGON balance\n    if (newVotingPower > oldVotingPower) {\n      _mint(msg.sender, newVotingPower - oldVotingPower);\n    } else if (oldVotingPower > newVotingPower) {\n      _burn(msg.sender, oldVotingPower - newVotingPower);\n    }\n\n    // Update point tracking\n    _checkpoint(\n      msg.sender,\n      LockedBalance({amount: userLocked.amount - additionalAmount, unlockTime: userLocked.unlockTime}),\n      userLocked\n    );\n\n    // Emit events\n    emit Deposit(msg.sender, additionalAmount, userLocked.unlockTime, newVotingPower);\n    emit LockIncreased(msg.sender, additionalAmount, newVotingPower);\n  }\n\n  /**\n   * @notice Extend lock duration\n   * @param lockDuration New lock duration in seconds\n   */\n  function extendLock(uint256 lockDuration) external nonReentrant whenInitialized {\n    LockedBalance storage userLock = locked[msg.sender];\n    if (userLock.amount == 0) revert NoLockFound();\n\n    // Align the new unlock time to a week boundary\n    uint256 newUnlockTime = DragonDateTimeLib.calculateLockEndAligned(userLock.unlockTime, lockDuration);\n\n    if (newUnlockTime <= userLock.unlockTime) revert LockTimeNotInFuture();\n    if (newUnlockTime > block.timestamp + MAX_LOCK_TIME) revert LockTimeTooLong();\n    if (newUnlockTime < block.timestamp + MIN_LOCK_TIME) revert LockTimeTooShort();\n\n    // Update rewards before making changes\n    _updateReward(msg.sender);\n\n    // Calculate old voting power\n    uint256 oldVotingPower = votingPower(msg.sender);\n\n    // Update unlock time\n    userLock.unlockTime = newUnlockTime;\n    locks[msg.sender].end = newUnlockTime;\n\n    // Calculate new voting power\n    uint256 newVotingPower = calculateVotingPowerByUnlockTime(userLock.amount, newUnlockTime);\n    locks[msg.sender].power = newVotingPower;\n\n    // Update total supply\n    _totalSupply = _totalSupply - oldVotingPower + newVotingPower;\n\n    // Adjust veDRAGON balance\n    if (newVotingPower > oldVotingPower) {\n      _mint(msg.sender, newVotingPower - oldVotingPower);\n    } else if (oldVotingPower > newVotingPower) {\n      _burn(msg.sender, oldVotingPower - newVotingPower);\n    }\n\n    // Update point tracking\n    userPointEpoch[msg.sender] += 1;\n    uint256 userEpoch = userPointEpoch[msg.sender];\n    userPointHistory[msg.sender][userEpoch] = Point({bias: newVotingPower, slope: 0, timestamp: block.timestamp, blk: block.number});\n\n    // Update global point history\n    epoch += 1;\n    pointHistory[epoch] = Point({bias: _totalSupply, slope: 0, timestamp: block.timestamp, blk: block.number});\n\n    // Emit events\n    emit LockUpdated(msg.sender, lockDuration, newVotingPower);\n    emit LockExtended(msg.sender, newUnlockTime, newVotingPower);\n  }\n\n  /**\n   * @notice Unlock tokens after lock period\n   */\n  function withdraw() external nonReentrant whenInitialized {\n    LockedBalance storage userLock = locked[msg.sender];\n    if (userLock.amount == 0) revert NoLockFound();\n    if (block.timestamp < userLock.unlockTime) revert LockNotExpired();\n\n    // Update rewards before making changes\n    _updateReward(msg.sender);\n\n    // Save the amount to withdraw\n    uint256 amount = userLock.amount;\n    uint256 oldVotingPower = votingPower(msg.sender);\n\n    // Clear the locks\n    delete locked[msg.sender];\n    delete locks[msg.sender];\n\n    // Update totals\n    totalLocked -= amount;\n    if (oldVotingPower > 0) {\n      _totalSupply = _totalSupply > oldVotingPower ? _totalSupply - oldVotingPower : 0;\n    }\n\n    // Burn veDRAGON tokens\n    uint256 userBalance = balanceOf(msg.sender);\n    if (userBalance > 0) {\n      _burn(msg.sender, userBalance);\n    }\n\n    // Update point tracking\n    userPointEpoch[msg.sender] += 1;\n    uint256 userEpoch = userPointEpoch[msg.sender];\n    userPointHistory[msg.sender][userEpoch] = Point({bias: 0, slope: 0, timestamp: block.timestamp, blk: block.number});\n\n    // Update global point history\n    epoch += 1;\n    pointHistory[epoch] = Point({bias: _totalSupply, slope: 0, timestamp: block.timestamp, blk: block.number});\n\n    // Transfer tokens back to user\n    lockedToken.safeTransfer(msg.sender, amount);\n\n    // Emit events\n    emit Withdraw(msg.sender, amount);\n    emit Unlocked(msg.sender, amount);\n    emit Supply(_totalSupply + oldVotingPower, _totalSupply);\n  }\n\n  /**\n   * @notice Claim pending rewards\n   */\n  function claimReward() external nonReentrant {\n    _updateReward(msg.sender);\n    uint256 reward = rewards[msg.sender];\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      lockedToken.safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  // Legacy compatibility functions\n  function lock(uint256 amount, uint256 duration) external {\n    this.createLock(amount, duration);\n  }\n\n  function increaseLock(uint256 addedAmount) external {\n    this.increaseLockAmount(addedAmount);\n  }\n\n  function unlock() external {\n    this.withdraw();\n  }\n\n  // ========== INTERNAL FUNCTIONS ==========\n\n  /**\n   * @notice Update reward calculations for a user\n   * @param account User address\n   */\n  function _updateReward(address account) internal {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = block.timestamp;\n\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n  }\n\n  /**\n   * @notice Calculate current reward per token\n   * @return Reward per token with precision\n   * @dev Proper reward per token calculation based on time and locked amounts\n   */\n  function rewardPerToken() internal view returns (uint256) {\n    if (totalLocked == 0) {\n      return rewardPerTokenStored;\n    }\n\n    // Calculate time-based reward accumulation\n    // This should be based on totalLocked (actual locked amounts), not _totalSupply (voting power)\n    uint256 timeDelta = block.timestamp - lastUpdateTime;\n    if (timeDelta == 0 || rewardRate == 0) {\n      return rewardPerTokenStored;\n    }\n\n    // Standard reward per token formula: rewardPerTokenStored + (rewardRate * timeDelta * PRECISION) / totalLocked\n    return rewardPerTokenStored + (rewardRate * timeDelta * PRECISION) / totalLocked;\n  }\n\n  /**\n   * @notice Internal function to update user points and total supply\n   * @param _user User address\n   * @param _oldLocked Old locked balance\n   * @param _newLocked New locked balance\n   */\n  function _checkpoint(address _user, LockedBalance memory _oldLocked, LockedBalance memory _newLocked) internal {\n    // Calculate old and new voting power\n    uint256 oldPower = calculateVotingPowerByUnlockTime(_oldLocked.amount, _oldLocked.unlockTime);\n    uint256 newPower = calculateVotingPowerByUnlockTime(_newLocked.amount, _newLocked.unlockTime);\n\n    // Update user point epoch and save history\n    userPointEpoch[_user] += 1;\n    uint256 userEpoch = userPointEpoch[_user];\n\n    // Calculate slope with precision\n    uint256 oldSlope = 0;\n    uint256 newSlope = 0;\n\n    if (_oldLocked.unlockTime > block.timestamp) {\n      uint256 timeDiff = _oldLocked.unlockTime - block.timestamp;\n      if (timeDiff > MAX_LOCK_TIME) timeDiff = MAX_LOCK_TIME;\n      oldSlope = (_oldLocked.amount * PRECISION) / timeDiff;\n    }\n\n    if (_newLocked.unlockTime > block.timestamp) {\n      uint256 timeDiff = _newLocked.unlockTime - block.timestamp;\n      if (timeDiff > MAX_LOCK_TIME) timeDiff = MAX_LOCK_TIME;\n      newSlope = (_newLocked.amount * PRECISION) / timeDiff;\n    }\n\n    // Save user point history\n    userPointHistory[_user][userEpoch] = Point({bias: newPower, slope: newSlope, timestamp: block.timestamp, blk: block.number});\n\n    // Update global point history\n    epoch += 1;\n    Point memory lastPoint = pointHistory[epoch - 1];\n    pointHistory[epoch] = Point({\n      bias: lastPoint.bias + newPower - oldPower,\n      slope: lastPoint.slope + newSlope - oldSlope,\n      timestamp: block.timestamp,\n      blk: block.number\n    });\n\n    // Update global supply\n    uint256 prevSupply = _totalSupply;\n    _totalSupply = prevSupply + newPower - oldPower;\n\n    emit Supply(prevSupply, _totalSupply);\n  }\n\n  /**\n   * @dev Calculate maximum boost multiplier\n   * @return Maximum boost value\n   */\n  function calculateMaxBoost() internal view returns (uint256) {\n    // For linear scaling, max boost is simply the maxVP value\n    return (maxVP * PRECISION) / 10000;\n  }\n\n  // ========== RESTRICTED FUNCTIONS ==========\n\n  /**\n   * @notice Override update to make veDRAGON non-transferable\n   */\n  function _update(address from, address to, uint256 amount) internal override {\n    // Allow minting and burning\n    if (from == address(0) || to == address(0)) {\n      super._update(from, to, amount);\n      return;\n    }\n\n    // Prevent transfers between accounts\n    revert(\"veDRAGON: non-transferable\");\n  }\n\n  /**\n   * @notice Add rewards to the contract\n   * @param reward Amount of token rewards to add\n   * @dev Proper reward distribution based on locked amounts, not voting power\n   */\n  function notifyRewardAmount(uint256 reward) external onlyOwner {\n    _updateReward(address(0));\n\n    lockedToken.safeTransferFrom(msg.sender, address(this), reward);\n\n    // Use totalLocked instead of _totalSupply for reward distribution\n    // Rewards should be distributed based on actual locked amounts, not voting power\n    if (totalLocked > 0) {\n      rewardPerTokenStored += (reward * PRECISION) / totalLocked;\n    }\n\n    lastUpdateTime = block.timestamp;\n    emit RewardAdded(reward);\n  }\n\n  /**\n   * @notice Set reward rate for time-based distribution\n   * @param _rewardRate Reward rate per second\n   * @dev Function to set reward rate for proper time-based rewards\n   */\n  function setRewardRate(uint256 _rewardRate) external onlyOwner {\n    _updateReward(address(0));\n    rewardRate = _rewardRate;\n    lastUpdateTime = block.timestamp;\n    emit RewardRateUpdated(_rewardRate);\n  }\n\n  /**\n   * @notice Update the maximum voting power multiplier\n   * @param _maxVP New maximum voting power in basis points\n   * @dev Updated validation range to be consistent with default maxVP=15000 and 2.5x boost\n   *      Range: 10000 (1.0x total = no additional boost) to 25000 (2.5x total = 1.5x additional boost)\n   */\n  function setMaxVP(uint256 _maxVP) external onlyOwner whenInitialized {\n    // Allow range from 10000 (1.0x total) to 25000 (2.5x total) to be consistent with redDRAGON MAX_BOOST\n    if (_maxVP < 10000 || _maxVP > 25000) revert InvalidMaxVP();\n\n    maxVP = _maxVP;\n    maxBoost = calculateMaxBoost();\n\n    emit BoostParametersUpdated(_maxVP, maxBoost);\n  }\n\n  /**\n   * @notice Emergency withdraw for stuck tokens (not locked tokens)\n   * @param token Token address\n   * @param amount Amount to withdraw\n   */\n  function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n    // Disallow withdrawing the lockedToken to avoid optics; use dedicated flows (unlock/claim) for user funds.\n    require(token != address(lockedToken), \"Cannot withdraw locked token\");\n    IERC20(token).safeTransfer(owner(), amount);\n  }\n\n  /**\n   * @notice Override ERC20 totalSupply function\n   * @return Total supply of veDRAGON tokens\n   */\n  // removed duplicate totalSupply override; time-decayed totalSupply implemented above\n\n  /**\n   * @notice Registers the contract with Sonic FeeM system\n   * @dev Only callable by owner. Makes external call to FeeM contract.\n   */\n  function registerMe() external onlyOwner {\n    (bool _success, ) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n      abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n  }\n}"
    },
    "contracts/core/vrf/ChainlinkVRFIntegratorV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ChainlinkVRFIntegratorV2_5 - OmniDragon Cross-Chain VRF System\n * @author 0xakita.eth\n * @dev Sonic-based contract that receives random words requests and forwards them to Arbitrum\n *      for Chainlink VRF 2.5 processing. Part of the OmniDragon ecosystem's cross-chain lottery\n *      and random words infrastructure.\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {OApp, MessagingFee, Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {MessagingReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport {OAppOptionsType3} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {IOmniDragonRegistry} from \"../../interfaces/config/IOmniDragonRegistry.sol\";\n\n// Import the standard VRF callback interface\nimport \"../../interfaces/vrf/IRandomWordsCallbackV2_5.sol\";\n\n/**\n * @title ChainlinkVRFIntegratorV2_5\n * @notice Resides on Sonic. Called by a provider to get random words from a peer on Arbitrum.\n */\ncontract ChainlinkVRFIntegratorV2_5 is OApp, OAppOptionsType3 {\n  using OptionsBuilder for bytes;\n  \n  IOmniDragonRegistry public immutable registry;\n\n  // Constants\n  uint32 constant ARBITRUM_EID = 30110;\n\n  // State variables\n  uint64 public requestCounter;\n  uint32 public defaultGasLimit = 690420; // Updated default gas limit\n\n  // Request tracking\n  struct RequestStatus {\n    bool fulfilled;\n    bool exists;\n    address provider;\n    uint256 randomWord;\n    uint256 timestamp;\n    bool isContract; // Track if provider is a contract\n  }\n  mapping(uint64 => RequestStatus) public s_requests;\n  mapping(uint64 => address) public randomWordsProviders;\n\n  // Events\n  event RandomWordsRequested(uint64 indexed requestId, address indexed requester, uint32 dstEid);\n  event MessageSent(uint64 indexed requestId, uint32 indexed dstEid, bytes message);\n  event RandomWordsReceived(uint256[] randomWords, uint64 indexed sequence, address indexed provider);\n  event CallbackFailed(uint64 indexed sequence, address indexed provider, string reason);\n  event CallbackSucceeded(uint64 indexed sequence, address indexed provider);\n  event RequestExpired(uint64 indexed sequence, address indexed provider);\n  event GasLimitUpdated(uint32 oldLimit, uint32 newLimit);\n  event FeeMRegistered(address indexed contractAddress, uint256 indexed feeId);\n\n  // Configuration\n  uint256 public requestTimeout = 1 hours; // Requests expire after 1 hour\n\n  constructor(address _registry) OApp(IOmniDragonRegistry(_registry).getLayerZeroEndpoint(uint16(block.chainid)), msg.sender) Ownable(msg.sender) {\n    registry = IOmniDragonRegistry(_registry);\n  }\n\n  /**\n   * @dev Receives random words responses from Arbitrum\n   * Updated to handle the correct payload format: (sequence, randomWord)\n   */\n  function _lzReceive(\n    Origin calldata _origin,\n    bytes32,\n    bytes calldata _payload,\n    address,\n    bytes calldata\n  ) internal override {\n    require(peers[_origin.srcEid] == _origin.sender, \"Unauthorized\");\n    require(_payload.length == 64, \"Invalid payload size\");\n\n    (uint64 sequence, uint256 randomWord) = abi.decode(_payload, (uint64, uint256));\n\n    RequestStatus storage request = s_requests[sequence];\n    require(request.exists, \"Request not found\");\n    require(!request.fulfilled, \"Request already fulfilled\");\n    require(block.timestamp <= request.timestamp + requestTimeout, \"Request expired\");\n\n    address provider = request.provider;\n    require(provider != address(0), \"Provider not found\");\n\n    // Mark as fulfilled\n    request.fulfilled = true;\n    request.randomWord = randomWord;\n\n    // Clean up provider mapping\n    delete randomWordsProviders[sequence];\n\n    // Create randomWords array for callback/event\n    uint256[] memory randomWords = new uint256[](1);\n    randomWords[0] = randomWord;\n\n    // Always emit the RandomWordsReceived event first\n    emit RandomWordsReceived(randomWords, sequence, provider);\n\n    // Only attempt callback if provider is a contract\n    if (request.isContract) {\n      try IRandomWordsCallbackV2_5(provider).receiveRandomWords(randomWords, uint256(sequence)) {\n        emit CallbackSucceeded(sequence, provider);\n      } catch Error(string memory reason) {\n        emit CallbackFailed(sequence, provider, reason);\n      } catch (bytes memory /*lowLevelData*/) {\n        emit CallbackFailed(sequence, provider, \"Low-level callback failure\");\n      }\n    }\n    // For EOA (wallet) requests, the RandomWordsReceived event is sufficient\n    // Users can query s_requests[sequence].randomWord to get their value\n  }\n\n  /**\n   * @notice Manual retry for stuck LayerZero messages\n   * @dev In LayerZero V2, retry is handled by the executor infrastructure\n   *      This function is for administrative purposes and monitoring\n   * @param requestId The request ID that may need attention\n   */\n  function checkRequestStatus(\n    uint64 requestId\n  )\n    external\n    view\n    returns (bool fulfilled, bool exists, address provider, uint256 randomWord, uint256 timestamp, bool expired)\n  {\n    RequestStatus memory request = s_requests[requestId];\n    return (\n      request.fulfilled,\n      request.exists,\n      request.provider,\n      request.randomWord,\n      request.timestamp,\n      block.timestamp > request.timestamp + requestTimeout\n    );\n  }\n\n  /**\n   * @notice Get the random word for a fulfilled request\n   * @param requestId The request ID to query\n   * @return randomWord The random word (0 if not fulfilled)\n   * @return fulfilled Whether the request has been fulfilled\n   */\n  function getRandomWord(uint64 requestId) external view returns (uint256 randomWord, bool fulfilled) {\n    RequestStatus memory request = s_requests[requestId];\n    return (request.randomWord, request.fulfilled);\n  }\n\n  /**\n   * @notice Quote fee using the default options\n   */\n  function quoteFee() public view returns (MessagingFee memory fee) {\n    bytes memory options = hex\"000301001101000000000000000000000000000A88F4\"; // default executor gas\n    bytes memory payload = abi.encode(uint64(requestCounter + 1));\n    return _quote(ARBITRUM_EID, payload, options, false);\n  }\n\n  /**\n   * @dev Request random words with custom gas limit\n   * @param _gasLimit Custom gas limit for the cross-chain execution\n   */\n  /**\n   * @notice Quote fee with a custom gas limit\n   */\n  function quoteFeeWithGas(uint32 _gasLimit) public view returns (MessagingFee memory fee) {\n    bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(_gasLimit, 0);\n    bytes memory payload = abi.encode(uint64(requestCounter + 1));\n    return _quote(ARBITRUM_EID, payload, options, false);\n  }\n\n  /**\n   * @notice Request random words (integrator-sponsored fee, default gas)\n   */\n  function requestRandomWords(uint32 dstEid)\n    public\n    returns (MessagingReceipt memory receipt, uint64 requestId)\n  {\n    require(dstEid == ARBITRUM_EID, \"Invalid destination EID\");\n    bytes memory options = hex\"000301001101000000000000000000000000000A88F4\";\n\n    bytes32 peer = peers[ARBITRUM_EID];\n    require(peer != bytes32(0), \"Arbitrum peer not set\");\n\n    requestCounter++;\n    requestId = requestCounter;\n\n    bool isContract = msg.sender.code.length > 0;\n    s_requests[requestId] = RequestStatus({\n      fulfilled: false,\n      exists: true,\n      provider: msg.sender,\n      randomWord: 0,\n      timestamp: block.timestamp,\n      isContract: isContract\n    });\n    randomWordsProviders[requestId] = msg.sender;\n\n    bytes memory payload = abi.encode(requestId);\n    MessagingFee memory fee = quoteFee();\n    require(address(this).balance >= fee.nativeFee, \"NotEnoughNative\");\n\n    receipt = _lzSend(\n      ARBITRUM_EID,\n      payload,\n      options,\n      fee,\n      payable(address(this))\n    );\n\n    emit RandomWordsRequested(requestId, msg.sender, ARBITRUM_EID);\n    emit MessageSent(requestId, ARBITRUM_EID, payload);\n  }\n\n  // Custom gas requests can be achieved by updating defaultGasLimit via setDefaultGasLimit\n\n  // (Old quote* and request*Simple functions removed in favor of the professional API)\n\n  /**\n   * @dev Update default gas limit (owner only)\n   */\n  function setDefaultGasLimit(uint32 _gasLimit) external onlyOwner {\n    uint32 oldLimit = defaultGasLimit;\n    defaultGasLimit = _gasLimit;\n    emit GasLimitUpdated(oldLimit, _gasLimit);\n  }\n\n  /**\n   * @dev Update request timeout (owner only)\n   */\n  function setRequestTimeout(uint256 _timeout) external onlyOwner {\n    requestTimeout = _timeout;\n  }\n\n  /**\n   * @dev Clean up expired requests (anyone can call)\n   * @param requestIds Array of request IDs to clean up\n   */\n  function cleanupExpiredRequests(uint64[] calldata requestIds) external {\n    for (uint256 i = 0; i < requestIds.length; i++) {\n      uint64 requestId = requestIds[i];\n      RequestStatus storage request = s_requests[requestId];\n\n      if (request.exists && !request.fulfilled && block.timestamp > request.timestamp + requestTimeout) {\n        address provider = request.provider;\n\n        // Mark as expired and clean up\n        delete s_requests[requestId];\n        delete randomWordsProviders[requestId];\n\n        emit RequestExpired(requestId, provider);\n      }\n    }\n  }\n\n  /**\n   * @dev Override _payNative to allow paying LayerZero fees from contract balance\n   * When msg.value is 0 (standard for this integrator), use the contract balance\n   * to cover the native fee required by the LayerZero Endpoint.\n   */\n  function _payNative(uint256 _nativeFee) internal override returns (uint256 nativeFee) {\n    if (msg.value == 0) {\n      require(address(this).balance >= _nativeFee, \"NotEnoughNative\");\n      return _nativeFee;\n    }\n\n    // If a caller sends value, enforce exact payment semantics expected by OApp\n    if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n    return _nativeFee;\n  }\n\n  /**\n   * @dev Register my contract on Sonic FeeM\n   * @notice This function registers the contract with Sonic's fee management system\n   */\n  function registerMe() external {\n    (bool _success, ) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n      abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n    );\n    require(_success, \"FeeM registration failed\");\n    emit FeeMRegistered(address(this), 143);\n  }\n\n  /**\n   * @dev Emergency withdraw (owner only)\n   */\n  function withdraw() external onlyOwner {\n    payable(owner()).transfer(address(this).balance);\n  }\n\n  /**\n   * @dev Receive ETH\n   */\n  receive() external payable {}\n}"
    },
    "contracts/core/vrf/OmniDragonVRFConsumerV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title OmniDragonVRFConsumerV2_5\n * @author 0xakita.eth\n * @dev Multi-chain VRF Consumer that accepts requests from multiple chains\n *      (Sonic, Avalanche, etc.) AND direct local requests from Arbitrum.\n *      Sends randomness back to the originating chain or calls local callbacks.\n *      This acts as a centralized VRF hub on Arbitrum using Chainlink VRF 2.5.\n *\n * SUPPORTS:\n * 1. Cross-chain requests via LayerZero (Sonic  Arbitrum  Response back to Sonic)\n * 2. Direct local requests from Arbitrum contracts/users (Arbitrum  Callback on Arbitrum)\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {OApp, MessagingFee, Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {MessagingReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport {OAppOptionsType3} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OAppOptionsType3.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {IOmniDragonRegistry} from \"../../interfaces/config/IOmniDragonRegistry.sol\";\n\n// Interface for local callbacks\ninterface IVRFCallbackReceiver {\n  function receiveRandomWords(uint256 requestId, uint256[] memory randomWords) external;\n}\n\n// Chainlink VRF V2.5 imports\nimport \"../../../lib/chainlink-vrf-v2.5/IVRFCoordinatorV2Plus.sol\";\n\n// Use the library from the imported file\nimport {VRFV2PlusClient} from \"../../../lib/chainlink-vrf-v2.5/IVRFCoordinatorV2Plus.sol\";\n\ncontract OmniDragonVRFConsumerV2_5 is OApp, OAppOptionsType3 {\n  using OptionsBuilder for bytes;\n\n  IVRFCoordinatorV2Plus public vrfCoordinator;\n  IOmniDragonRegistry public immutable registry;\n\n  // LayerZero Chain EIDs\n  uint32 public constant ETHEREUM_EID = 30101;\n  uint32 public constant BSC_EID = 30102;\n  uint32 public constant AVALANCHE_EID = 30106;\n  uint32 public constant POLYGON_EID = 30109;\n  uint32 public constant OPTIMISM_EID = 30111;\n  uint32 public constant BASE_EID = 30184;\n  uint32 public constant SONIC_EID = 30332;\n\n  // Local Arbitrum EID (for internal tracking)\n  uint32 public constant LOCAL_ARBITRUM_EID = 0;\n\n  mapping(uint32 => bool) public supportedChains;\n  mapping(uint32 => uint32) public chainGasLimits;\n\n  uint32[] public registeredChainEids;\n  mapping(uint32 => string) public chainNames;\n\n  uint256 public subscriptionId;\n  bytes32 public keyHash;\n  uint32 public callbackGasLimit = 2500000;\n  uint16 public requestConfirmations = 3;\n  uint32 public numWords = 1;\n\n  bool public nativePayment = false;\n\n  // Enhanced VRF Request structure to support both cross-chain and local requests\n  struct VRFRequest {\n    uint64 sequence; // For cross-chain requests\n    uint32 sourceChainEid; // 0 for local requests, chain EID for cross-chain\n    bytes32 sourcePeer; // LayerZero peer for cross-chain\n    address localRequester; // Local requester address for direct requests\n    bool isLocalRequest; // True for local requests, false for cross-chain\n    uint256 randomWord;\n    bool fulfilled;\n    bool responseSent; // For cross-chain only\n    bool callbackSent; // For local requests only\n    uint256 timestamp;\n  }\n\n  mapping(uint256 => VRFRequest) public vrfRequests;\n  mapping(uint64 => uint256) public sequenceToRequestId; // Cross-chain mapping\n\n  mapping(uint64 => bool) public pendingResponses;\n\n  // Local request tracking\n  uint256 public localRequestCounter;\n  mapping(address => uint256[]) public userLocalRequests; // user => requestIds[]\n  mapping(address => bool) public authorizedLocalCallers; // Authorization for local requests\n\n  /**\n   * @dev Minimum ETH balance threshold for monitoring purposes only.\n   */\n  uint256 public minimumBalance = 0.005 ether;\n  uint32 public defaultGasLimit = 2500000;\n\n  // Enhanced events for both cross-chain and local requests\n  event RandomWordsRequested(\n    uint256 indexed requestId,\n    uint32 indexed srcEid,\n    bytes32 indexed requester,\n    uint64 sequence,\n    uint256 timestamp\n  );\n\n  event LocalRandomWordsRequested(uint256 indexed requestId, address indexed requester, uint256 timestamp);\n\n  event VRFRequestSent(uint256 indexed originalRequestId, uint256 indexed vrfRequestId, uint32 sourceChain);\n  event RandomnessFulfilled(uint256 indexed requestId, uint256[] randomWords, uint32 targetChain);\n  event ResponseSentToChain(uint64 indexed sequence, uint256 randomWord, uint32 targetChain, uint256 fee);\n  event ResponsePending(uint64 indexed sequence, uint256 indexed requestId, uint32 targetChain, string reason);\n\n  event LocalCallbackSent(uint256 indexed requestId, address indexed requester, uint256 randomWord);\n  event LocalCallbackFailed(uint256 indexed requestId, address indexed requester, string reason);\n\n  event VRFConfigUpdated(uint256 subscriptionId, bytes32 keyHash, uint32 callbackGasLimit, uint16 requestConfirmations);\n  event MinimumBalanceUpdated(uint256 oldBalance, uint256 newBalance);\n  event ChainSupportUpdated(uint32 chainEid, bool supported, uint32 gasLimit);\n  event ContractFunded(address indexed funder, uint256 amount, uint256 newBalance);\n  event LocalCallerAuthorized(address indexed caller, bool authorized);\n\n  constructor(\n    address _registry\n  ) OApp(IOmniDragonRegistry(_registry).getLayerZeroEndpoint(uint16(block.chainid)), msg.sender) Ownable(msg.sender) {\n    registry = IOmniDragonRegistry(_registry);\n    \n    // VRF coordinator, subscription ID, and key hash will be set via setter functions\n    // This allows deployment with placeholder values\n    \n    _setSupportedChain(SONIC_EID, true, 2500000);\n    _setSupportedChain(AVALANCHE_EID, true, 2500000);\n    _setSupportedChain(BASE_EID, true, 2500000);\n    _setSupportedChain(ETHEREUM_EID, true, 2500000);\n\n    // Enable deployer for local requests by default\n    authorizedLocalCallers[msg.sender] = true;\n  }\n\n  /**\n   * @notice Set VRF coordinator address (only owner)\n   */\n  function setVRFCoordinator(address _vrfCoordinator) external onlyOwner {\n    require(_vrfCoordinator != address(0), \"Invalid VRF coordinator\");\n    vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n    emit VRFConfigUpdated(subscriptionId, keyHash, callbackGasLimit, requestConfirmations);\n  }\n\n  /**\n   * @notice Set VRF subscription ID (only owner)\n   */\n  function setSubscriptionId(uint256 _subscriptionId) external onlyOwner {\n    subscriptionId = _subscriptionId;\n    emit VRFConfigUpdated(subscriptionId, keyHash, callbackGasLimit, requestConfirmations);\n  }\n\n  /**\n   * @notice Set VRF key hash (only owner)\n   */\n  function setKeyHash(bytes32 _keyHash) external onlyOwner {\n    keyHash = _keyHash;\n    emit VRFConfigUpdated(subscriptionId, keyHash, callbackGasLimit, requestConfirmations);\n  }\n\n  /**\n   * @notice Set all VRF parameters at once (only owner)\n   */\n  function setVRFConfig(\n    address _vrfCoordinator,\n    uint256 _subscriptionId,\n    bytes32 _keyHash\n  ) external onlyOwner {\n    require(_vrfCoordinator != address(0), \"Invalid VRF coordinator\");\n    vrfCoordinator = IVRFCoordinatorV2Plus(_vrfCoordinator);\n    subscriptionId = _subscriptionId;\n    keyHash = _keyHash;\n    emit VRFConfigUpdated(subscriptionId, keyHash, callbackGasLimit, requestConfirmations);\n  }\n\n  /**\n   * @notice LayerZero V2 receive function - accepts VRF requests from multiple chains\n   */\n  function _lzReceive(\n    Origin calldata _origin,\n    bytes32,\n    bytes calldata _message,\n    address,\n    bytes calldata\n  ) internal override {\n    require(supportedChains[_origin.srcEid], \"Chain not supported\");\n    require(peers[_origin.srcEid] == _origin.sender, \"Invalid source peer\");\n\n    uint64 sequence = abi.decode(_message, (uint64));\n    require(sequenceToRequestId[sequence] == 0, \"Duplicate sequence\");\n\n    bytes memory extraArgs = \"\";\n\n    uint256 requestId = vrfCoordinator.requestRandomWords(\n      VRFV2PlusClient.RandomWordsRequest({\n        keyHash: keyHash,\n        subId: subscriptionId,\n        requestConfirmations: requestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: numWords,\n        extraArgs: extraArgs\n      })\n    );\n\n    vrfRequests[requestId] = VRFRequest({\n      sequence: sequence,\n      sourceChainEid: _origin.srcEid,\n      sourcePeer: _origin.sender,\n      localRequester: address(0),\n      isLocalRequest: false,\n      randomWord: 0,\n      fulfilled: false,\n      responseSent: false,\n      callbackSent: false,\n      timestamp: block.timestamp\n    });\n\n    sequenceToRequestId[sequence] = requestId;\n\n    emit VRFRequestSent(sequence, requestId, _origin.srcEid);\n    emit RandomWordsRequested(requestId, _origin.srcEid, _origin.sender, sequence, block.timestamp);\n  }\n\n  /**\n   * @notice Request random words directly on Arbitrum (local request)\n   * @dev For contracts/users on Arbitrum that want randomness without cross-chain messaging\n   * @return requestId The VRF request ID\n   */\n  function requestRandomWordsLocal() external returns (uint256 requestId) {\n    require(address(vrfCoordinator) != address(0), \"VRF coordinator not set\");\n    require(authorizedLocalCallers[msg.sender], \"Not authorized for local requests\");\n\n    bytes memory extraArgs = \"\";\n\n    requestId = vrfCoordinator.requestRandomWords(\n      VRFV2PlusClient.RandomWordsRequest({\n        keyHash: keyHash,\n        subId: subscriptionId,\n        requestConfirmations: requestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: numWords,\n        extraArgs: extraArgs\n      })\n    );\n\n    localRequestCounter++;\n\n    vrfRequests[requestId] = VRFRequest({\n      sequence: 0, // Not used for local requests\n      sourceChainEid: LOCAL_ARBITRUM_EID,\n      sourcePeer: bytes32(0),\n      localRequester: msg.sender,\n      isLocalRequest: true,\n      randomWord: 0,\n      fulfilled: false,\n      responseSent: false,\n      callbackSent: false,\n      timestamp: block.timestamp\n    });\n\n    userLocalRequests[msg.sender].push(requestId);\n\n    emit LocalRandomWordsRequested(requestId, msg.sender, block.timestamp);\n\n    return requestId;\n  }\n\n  /**\n   * @notice Callback function used by VRF Coordinator\n   * @dev This function is called by the VRF Coordinator when randomness is ready\n   * @param requestId The request ID\n   * @param randomWords Array of random words\n   */\n  function rawFulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) external {\n    require(msg.sender == address(vrfCoordinator), \"Only VRF Coordinator can fulfill\");\n\n    VRFRequest storage request = vrfRequests[requestId];\n    require(request.timestamp != 0, \"Invalid request ID\");\n    require(!request.fulfilled, \"Already fulfilled\");\n\n    request.fulfilled = true;\n    request.randomWord = randomWords[0];\n\n    if (request.isLocalRequest) {\n      // Handle local request callback\n      _handleLocalCallback(requestId, request, randomWords);\n    } else {\n      // Handle cross-chain response\n      _handleCrossChainResponse(requestId, request, randomWords);\n    }\n\n    emit RandomnessFulfilled(requestId, randomWords, request.sourceChainEid);\n  }\n\n  /**\n   * @dev Handle callback for local requests\n   */\n  function _handleLocalCallback(\n    uint256 requestId,\n    VRFRequest storage request,\n    uint256[] calldata randomWords\n  ) internal {\n    address requester = request.localRequester;\n\n    // Try to call receiveRandomWords if the requester is a contract\n    if (requester.code.length > 0) {\n      try IVRFCallbackReceiver(requester).receiveRandomWords(requestId, randomWords) {\n        request.callbackSent = true;\n        emit LocalCallbackSent(requestId, requester, request.randomWord);\n      } catch Error(string memory reason) {\n        emit LocalCallbackFailed(requestId, requester, reason);\n      } catch {\n        emit LocalCallbackFailed(requestId, requester, \"Unknown callback error\");\n      }\n    }\n    // For EOA requests, they can query the result using getLocalRequest()\n  }\n\n  /**\n   * @dev Handle response for cross-chain requests\n   */\n  function _handleCrossChainResponse(\n    uint256 requestId,\n    VRFRequest storage request,\n    uint256[] calldata /* randomWords */\n  ) internal {\n    uint32 targetGasLimit = chainGasLimits[request.sourceChainEid];\n    if (targetGasLimit == 0) {\n      targetGasLimit = defaultGasLimit;\n    }\n\n    bytes memory payload = abi.encode(request.sequence, request.randomWord);\n    bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n    MessagingFee memory fee = _quote(request.sourceChainEid, payload, options, false);\n\n    if (address(this).balance < fee.nativeFee) {\n      pendingResponses[request.sequence] = true;\n      emit ResponsePending(\n        request.sequence,\n        requestId,\n        request.sourceChainEid,\n        \"Insufficient balance for LayerZero fees\"\n      );\n      return;\n    }\n\n    _sendResponseToChain(request, fee);\n  }\n\n  /**\n   * @notice Authorize/deauthorize local callers (owner only)\n   * @param caller The address to authorize/deauthorize\n   * @param authorized Whether to authorize or deauthorize\n   */\n  function setLocalCallerAuthorization(address caller, bool authorized) external onlyOwner {\n    authorizedLocalCallers[caller] = authorized;\n    emit LocalCallerAuthorized(caller, authorized);\n  }\n\n  /**\n   * @notice Get local request details\n   * @param requestId The VRF request ID\n   * @return requester The address that made the request\n   * @return fulfilled Whether the request has been fulfilled\n   * @return callbackSent Whether callback was successfully sent\n   * @return randomWord The random word (0 if not fulfilled)\n   * @return timestamp When the request was made\n   */\n  function getLocalRequest(\n    uint256 requestId\n  )\n    external\n    view\n    returns (address requester, bool fulfilled, bool callbackSent, uint256 randomWord, uint256 timestamp)\n  {\n    VRFRequest storage request = vrfRequests[requestId];\n    require(request.isLocalRequest, \"Not a local request\");\n\n    return (request.localRequester, request.fulfilled, request.callbackSent, request.randomWord, request.timestamp);\n  }\n\n  /**\n   * @notice Get all local requests for a user\n   * @param user The user address\n   * @return requestIds Array of request IDs for the user\n   */\n  function getUserLocalRequests(address user) external view returns (uint256[] memory requestIds) {\n    return userLocalRequests[user];\n  }\n\n  /**\n   * @notice Get local request statistics\n   * @return totalLocalRequests Total number of local requests\n   * @return totalCrossChainRequests Total number of cross-chain requests (approximate)\n   */\n  function getRequestStats() external view returns (uint256 totalLocalRequests, uint256 totalCrossChainRequests) {\n    totalLocalRequests = localRequestCounter;\n    // Cross-chain requests don't have a simple counter, this is an approximation\n    totalCrossChainRequests = 0; // Would need to track this separately if needed\n  }\n\n  /**\n   * @dev Set peer for a specific endpoint ID (owner only)\n   * @param _eid The endpoint ID to set the peer for\n   * @param _peer The peer address (as bytes32)\n   */\n  function setPeer(uint32 _eid, bytes32 _peer) public override onlyOwner {\n    _setPeer(_eid, _peer);\n  }\n\n  /**\n   * @notice Add or remove support for a chain\n   * @param chainEid The LayerZero endpoint ID of the chain\n   * @param supported Whether the chain should be supported\n   * @param gasLimit Gas limit for responses to this chain\n   */\n  function setSupportedChain(uint32 chainEid, bool supported, uint32 gasLimit) external onlyOwner {\n    _setSupportedChain(chainEid, supported, gasLimit);\n  }\n\n  /**\n   * @notice Add a new chain with name (for better UX)\n   * @param chainEid The LayerZero endpoint ID of the chain\n   * @param chainName Human-readable name for the chain\n   * @param gasLimit Gas limit for responses to this chain\n   */\n  function addNewChain(uint32 chainEid, string calldata chainName, uint32 gasLimit) external onlyOwner {\n    require(!supportedChains[chainEid], \"Chain already supported\");\n    require(bytes(chainName).length > 0, \"Chain name required\");\n\n    bool found = false;\n    for (uint i = 0; i < registeredChainEids.length; i++) {\n      if (registeredChainEids[i] == chainEid) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      registeredChainEids.push(chainEid);\n    }\n\n    chainNames[chainEid] = chainName;\n    _setSupportedChain(chainEid, true, gasLimit);\n  }\n\n  /**\n   * @notice Internal function to set chain support\n   */\n  function _setSupportedChain(uint32 chainEid, bool supported, uint32 gasLimit) internal {\n    supportedChains[chainEid] = supported;\n    if (supported) {\n      require(gasLimit >= 100000 && gasLimit <= 10000000, \"Invalid gas limit\");\n      chainGasLimits[chainEid] = gasLimit;\n    } else {\n      chainGasLimits[chainEid] = 0;\n    }\n    emit ChainSupportUpdated(chainEid, supported, gasLimit);\n  }\n\n  /**\n   * @notice Get supported chains info (EXPANDABLE VERSION)\n   */\n  function getSupportedChains()\n    external\n    view\n    returns (uint32[] memory eids, bool[] memory supported, uint32[] memory gasLimits)\n  {\n    uint32[] memory baseChains = new uint32[](7);\n    baseChains[0] = SONIC_EID;\n    baseChains[1] = AVALANCHE_EID;\n    baseChains[2] = BASE_EID;\n    baseChains[3] = ETHEREUM_EID;\n    baseChains[4] = POLYGON_EID;\n    baseChains[5] = BSC_EID;\n    baseChains[6] = OPTIMISM_EID;\n\n    uint256 totalChains = baseChains.length + registeredChainEids.length;\n    eids = new uint32[](totalChains);\n    supported = new bool[](totalChains);\n    gasLimits = new uint32[](totalChains);\n\n    for (uint i = 0; i < baseChains.length; i++) {\n      eids[i] = baseChains[i];\n      supported[i] = supportedChains[baseChains[i]];\n      gasLimits[i] = chainGasLimits[baseChains[i]];\n    }\n\n    for (uint i = 0; i < registeredChainEids.length; i++) {\n      uint256 index = baseChains.length + i;\n      eids[index] = registeredChainEids[i];\n      supported[index] = supportedChains[registeredChainEids[i]];\n      gasLimits[index] = chainGasLimits[registeredChainEids[i]];\n    }\n  }\n\n  /**\n   * @notice Get all registered chains with names\n   */\n  function getAllChainsWithNames()\n    external\n    view\n    returns (uint32[] memory eids, string[] memory names, bool[] memory supported, uint32[] memory gasLimits)\n  {\n    uint32[] memory baseChains = new uint32[](7);\n    baseChains[0] = SONIC_EID;\n    baseChains[1] = AVALANCHE_EID;\n    baseChains[2] = BASE_EID;\n    baseChains[3] = ETHEREUM_EID;\n    baseChains[4] = POLYGON_EID;\n    baseChains[5] = BSC_EID;\n    baseChains[6] = OPTIMISM_EID;\n\n    string[] memory baseNames = new string[](7);\n    baseNames[0] = \"Sonic\";\n    baseNames[1] = \"Avalanche\";\n    baseNames[2] = \"Base\";\n    baseNames[3] = \"Ethereum\";\n    baseNames[4] = \"Polygon\";\n    baseNames[5] = \"BSC\";\n    baseNames[6] = \"Optimism\";\n\n    uint256 totalChains = baseChains.length + registeredChainEids.length;\n    eids = new uint32[](totalChains);\n    names = new string[](totalChains);\n    supported = new bool[](totalChains);\n    gasLimits = new uint32[](totalChains);\n\n    for (uint i = 0; i < baseChains.length; i++) {\n      eids[i] = baseChains[i];\n      names[i] = baseNames[i];\n      supported[i] = supportedChains[baseChains[i]];\n      gasLimits[i] = chainGasLimits[baseChains[i]];\n    }\n\n    for (uint i = 0; i < registeredChainEids.length; i++) {\n      uint256 index = baseChains.length + i;\n      eids[index] = registeredChainEids[i];\n      names[index] = chainNames[registeredChainEids[i]];\n      supported[index] = supportedChains[registeredChainEids[i]];\n      gasLimits[index] = chainGasLimits[registeredChainEids[i]];\n    }\n  }\n\n  /**\n   * @notice Manual retry for pending responses\n   * @dev Call this after funding the contract to retry failed responses.\n   * @param sequence The sequence number to retry\n   */\n  function retryPendingResponse(uint64 sequence) external payable {\n    require(pendingResponses[sequence], \"No pending response for this sequence\");\n\n    uint256 requestId = sequenceToRequestId[sequence];\n    require(requestId != 0, \"Invalid sequence\");\n\n    VRFRequest storage request = vrfRequests[requestId];\n    require(request.fulfilled, \"VRF not fulfilled yet\");\n    require(!request.responseSent, \"Response already sent\");\n\n    uint32 targetGasLimit = chainGasLimits[request.sourceChainEid];\n    if (targetGasLimit == 0) {\n      targetGasLimit = defaultGasLimit;\n    }\n\n    bytes memory payload = abi.encode(request.sequence, request.randomWord);\n    bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n    MessagingFee memory fee = _quote(request.sourceChainEid, payload, options, false);\n\n    require(address(this).balance >= fee.nativeFee, \"Insufficient contract balance for LayerZero fee\");\n\n    delete pendingResponses[sequence];\n\n    _sendResponseToChain(request, fee);\n  }\n\n  /**\n   * @notice Quote LayerZero fee for sending response to any supported chain\n   * @param targetChainEid The chain to send the response to\n   */\n  function quoteSendToChain(uint32 targetChainEid) external view returns (MessagingFee memory fee) {\n    require(supportedChains[targetChainEid], \"Chain not supported\");\n\n    uint32 targetGasLimit = chainGasLimits[targetChainEid];\n    if (targetGasLimit == 0) {\n      targetGasLimit = defaultGasLimit;\n    }\n\n    bytes memory payload = abi.encode(uint64(1), uint256(12345));\n    bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n    return _quote(targetChainEid, payload, options, false);\n  }\n\n  /**\n   * @dev Internal function to send the VRF response back to the originating chain.\n   * @param _request The VRF request struct containing all necessary data.\n   * @param _fee The pre-calculated LayerZero messaging fee.\n   */\n  function _sendResponseToChain(VRFRequest storage _request, MessagingFee memory _fee) internal {\n    uint32 targetGasLimit = chainGasLimits[_request.sourceChainEid];\n    if (targetGasLimit == 0) {\n      targetGasLimit = defaultGasLimit;\n    }\n\n    bytes memory payload = abi.encode(_request.sequence, _request.randomWord);\n    bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(targetGasLimit, 0);\n\n    _request.responseSent = true;\n\n    _lzSend(\n      _request.sourceChainEid, // Send back to the originating chain\n      payload,\n      options,\n      _fee,\n      payable(owner()) // Refund any excess gas to the owner\n    );\n\n    emit ResponseSentToChain(_request.sequence, _request.randomWord, _request.sourceChainEid, _fee.nativeFee);\n  }\n\n  /**\n   * @dev Set VRF 2.5 configuration (owner only)\n   */\n  function setVRFConfig(\n    uint256 _subscriptionId,\n    bytes32 _keyHash,\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    bool _nativePayment\n  ) external onlyOwner {\n    require(_subscriptionId > 0, \"Invalid subscription ID\");\n    require(_keyHash != bytes32(0), \"Invalid key hash\");\n    require(_callbackGasLimit >= 40000 && _callbackGasLimit <= 2500000, \"Invalid callback gas limit\");\n    require(_requestConfirmations >= 3 && _requestConfirmations <= 200, \"Invalid request confirmations\");\n\n    subscriptionId = _subscriptionId;\n    keyHash = _keyHash;\n    callbackGasLimit = _callbackGasLimit;\n    requestConfirmations = _requestConfirmations;\n    nativePayment = _nativePayment;\n\n    emit VRFConfigUpdated(_subscriptionId, _keyHash, _callbackGasLimit, _requestConfirmations);\n  }\n\n  /**\n   * @dev Set minimum balance for responses (owner only)\n   */\n  function setMinimumBalance(uint256 _minimumBalance) external onlyOwner {\n    require(_minimumBalance <= 1 ether, \"Minimum balance too high\");\n\n    uint256 oldBalance = minimumBalance;\n    minimumBalance = _minimumBalance;\n    emit MinimumBalanceUpdated(oldBalance, _minimumBalance);\n  }\n\n  /**\n   * @dev Set default gas limit (owner only)\n   */\n  function setDefaultGasLimit(uint32 _gasLimit) external onlyOwner {\n    require(_gasLimit >= 100000 && _gasLimit <= 10000000, \"Invalid gas limit\");\n    defaultGasLimit = _gasLimit;\n  }\n\n  /**\n   * @dev Fund contract with ETH for LayerZero fees\n   */\n  function fundContract() external payable {\n    require(msg.value > 0, \"Must send ETH to fund contract\");\n    emit ContractFunded(msg.sender, msg.value, address(this).balance);\n  }\n\n  /**\n   * @dev Override _payNative to handle payments from contract balance when msg.value is 0\n   * This is necessary for VRF callbacks where msg.value is 0 but the contract has ETH balance\n   */\n  function _payNative(uint256 _nativeFee) internal override returns (uint256 nativeFee) {\n    // If msg.value is 0 (e.g., from VRF callback), use contract balance\n    if (msg.value == 0) {\n      require(address(this).balance >= _nativeFee, \"Insufficient contract balance for LayerZero fee\");\n      return _nativeFee;\n    }\n\n    // Otherwise, use the standard payment method\n    if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n    return _nativeFee;\n  }\n\n  /**\n   * @dev Get request details by sequence\n   */\n  function getRequestBySequence(\n    uint64 sequence\n  )\n    external\n    view\n    returns (\n      uint256 requestId,\n      bool exists,\n      bool fulfilled,\n      bool responseSent,\n      uint256 randomWord,\n      uint32 sourceChainEid,\n      uint256 timestamp\n    )\n  {\n    requestId = sequenceToRequestId[sequence];\n    if (requestId == 0) {\n      return (0, false, false, false, 0, 0, 0);\n    }\n\n    VRFRequest storage request = vrfRequests[requestId];\n    return (\n      requestId,\n      true,\n      request.fulfilled,\n      request.responseSent,\n      request.randomWord,\n      request.sourceChainEid,\n      request.timestamp\n    );\n  }\n\n  /**\n   * @dev Get request details by VRF request ID\n   */\n  function getRequestById(\n    uint256 requestId\n  )\n    external\n    view\n    returns (\n      uint64 sequence,\n      bool exists,\n      bool fulfilled,\n      bool responseSent,\n      uint256 randomWord,\n      uint32 sourceChainEid,\n      uint256 timestamp\n    )\n  {\n    VRFRequest storage request = vrfRequests[requestId];\n    if (request.timestamp == 0) {\n      return (0, false, false, false, 0, 0, 0);\n    }\n\n    return (\n      request.sequence,\n      true,\n      request.fulfilled,\n      request.responseSent,\n      request.randomWord,\n      request.sourceChainEid,\n      request.timestamp\n    );\n  }\n\n  /**\n   * @dev Check contract status\n   */\n  function getContractStatus()\n    external\n    view\n    returns (uint256 balance, uint256 minBalance, bool canSendResponses, uint32 gasLimit, uint256 supportedChainsCount)\n  {\n    balance = address(this).balance;\n    minBalance = minimumBalance;\n    canSendResponses = balance >= minBalance;\n    gasLimit = defaultGasLimit;\n\n    uint256 count = 0;\n    if (supportedChains[SONIC_EID]) count++;\n    if (supportedChains[AVALANCHE_EID]) count++;\n    if (supportedChains[BASE_EID]) count++;\n    if (supportedChains[ETHEREUM_EID]) count++;\n    supportedChainsCount = count;\n\n    return (balance, minBalance, canSendResponses, gasLimit, supportedChainsCount);\n  }\n\n  /**\n   * @dev Withdraw ETH (owner only)\n   */\n  function withdraw() external onlyOwner {\n    uint256 balance = address(this).balance;\n    require(balance > 0, \"No balance to withdraw\");\n\n    (bool success, ) = payable(owner()).call{value: balance}(\"\");\n    require(success, \"Withdrawal failed\");\n  }\n\n  /**\n   * @dev Receive ETH for LayerZero fees\n   */\n  receive() external payable {}\n\n}"
    },
    "contracts/integrations/OmniDragonFusionIntegrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOmniDragonLotteryManager} from \"../interfaces/lottery/IOmniDragonLotteryManager.sol\";\n\n/**\n * @title OmniDragonFusionIntegrator\n * @author 0xakita.eth\n * @dev Integrates 1inch Fusion+ with omniDRAGON lottery system\n * \n * Features:\n * - Same-chain swaps via 1inch Aggregation Router\n * - Cross-chain swaps via 1inch Fusion+\n * - Automatic lottery entry generation for all swaps\n * - Works with any token pair (not just omniDRAGON)\n * - No additional fees (just 1inch's normal costs)\n * - omniDRAGON fees handled automatically by token contract\n * \n * User Benefits:\n * - Get 1inch's best rates\n * - Free lottery entries on every swap\n * - Same gas cost as regular 1inch swaps\n * - Cross-chain functionality\n * \n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ncontract OmniDragonFusionIntegrator is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ================================\n    // STATE VARIABLES\n    // ================================\n    \n    IOmniDragonLotteryManager public immutable lotteryManager;\n    \n    // 1inch router addresses (set by admin)\n    address public inchAggregationRouter;  // For same-chain swaps\n    address public inchFusionRouter;       // For cross-chain swaps\n    \n    // Platform configuration\n    uint256 public platformFee = 0; // No additional fees\n    address public feeRecipient;\n    \n    // omniDRAGON token address for special handling\n    address public omniDRAGONToken;\n    \n    // Swap tracking\n    mapping(bytes32 => SwapOrder) public swapOrders;\n    mapping(address => uint256) public userSwapCount;\n    mapping(address => uint256) public userTotalVolume;\n\n    // ================================\n    // STRUCTS & ENUMS\n    // ================================\n    \n    struct SwapOrder {\n        address trader;\n        address srcToken;\n        address dstToken;\n        uint256 srcAmount;\n        uint256 minDstAmount;\n        uint256 actualDstAmount;\n        uint256 lotteryEntryId;\n        bool completed;\n        uint256 timestamp;\n        string swapType; // \"same_chain\" or \"cross_chain\"\n    }\n\n    // ================================\n    // EVENTS\n    // ================================\n    \n    event SwapExecuted(\n        bytes32 indexed orderId,\n        address indexed trader,\n        address srcToken,\n        address dstToken,\n        uint256 srcAmount,\n        uint256 dstAmount,\n        uint256 lotteryEntryId,\n        string swapType\n    );\n\n    event FusionSwapInitiated(\n        bytes32 indexed orderId,\n        address indexed trader,\n        uint256 srcChainId,\n        uint256 dstChainId,\n        uint256 lotteryEntryId\n    );\n\n    event LotteryEntryGenerated(\n        address indexed trader,\n        uint256 indexed entryId,\n        address token,\n        uint256 amount\n    );\n\n    // ================================\n    // CONSTRUCTOR\n    // ================================\n    \n    constructor(\n        address _lotteryManager,\n        address _feeRecipient,\n        address _omniDRAGONToken\n    ) Ownable(msg.sender) {\n        require(_lotteryManager != address(0), \"Invalid lottery manager\");\n        require(_feeRecipient != address(0), \"Invalid fee recipient\");\n        require(_omniDRAGONToken != address(0), \"Invalid omniDRAGON token\");\n        \n        lotteryManager = IOmniDragonLotteryManager(_lotteryManager);\n        feeRecipient = _feeRecipient;\n        omniDRAGONToken = _omniDRAGONToken;\n    }\n\n    // ================================\n    // MAIN SWAP FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Execute same-chain swap with lottery integration\n     * @param srcToken Source token address\n     * @param dstToken Destination token address  \n     * @param amount Amount to swap\n     * @param minReturn Minimum tokens to receive\n     * @param swapData Swap calldata from 1inch API\n     */\n    function executeSwapWithLottery(\n        address srcToken,\n        address dstToken,\n        uint256 amount,\n        uint256 minReturn,\n        bytes calldata swapData\n    ) external nonReentrant returns (bytes32 orderId, uint256 lotteryEntryId) {\n        \n        require(amount > 0, \"Invalid amount\");\n        require(srcToken != dstToken, \"Same token\");\n        require(inchAggregationRouter != address(0), \"Router not configured\");\n        \n        // Generate order ID\n        orderId = _generateOrderId(msg.sender, srcToken, dstToken, amount);\n        \n        // 1. Transfer tokens from user\n        // Note: If srcToken is omniDRAGON, fees will be applied automatically\n        IERC20(srcToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // 2. Get actual amount after any fees (for omniDRAGON)\n        uint256 actualAmount = IERC20(srcToken).balanceOf(address(this));\n        \n        // 3. Execute swap via 1inch Aggregation Router\n        uint256 dstAmount = _executeAggregationSwap(\n            srcToken,\n            dstToken, \n            actualAmount,\n            minReturn,\n            swapData\n        );\n        \n        // 4. Transfer output tokens to user\n        // Note: If dstToken is omniDRAGON, fees will be applied automatically\n        IERC20(dstToken).safeTransfer(msg.sender, dstAmount);\n        \n        // 5. Generate lottery entry (using original amount for fairness)\n        lotteryEntryId = _generateLotteryEntry(\n            msg.sender,\n            srcToken,\n            amount // Use original amount, not amount after fees\n        );\n        \n        // 6. Record swap\n        swapOrders[orderId] = SwapOrder({\n            trader: msg.sender,\n            srcToken: srcToken,\n            dstToken: dstToken,\n            srcAmount: amount,\n            minDstAmount: minReturn,\n            actualDstAmount: dstAmount,\n            lotteryEntryId: lotteryEntryId,\n            completed: true,\n            timestamp: block.timestamp,\n            swapType: \"same_chain\"\n        });\n        \n        // 7. Update user stats\n        userSwapCount[msg.sender]++;\n        userTotalVolume[msg.sender] += amount;\n        \n        emit SwapExecuted(\n            orderId, \n            msg.sender, \n            srcToken, \n            dstToken, \n            amount, \n            dstAmount, \n            lotteryEntryId,\n            \"same_chain\"\n        );\n        \n        return (orderId, lotteryEntryId);\n    }\n    \n    /**\n     * @dev Execute cross-chain swap via 1inch Fusion+\n     * @param srcToken Source token address\n     * @param dstToken Destination token address (on destination chain)\n     * @param amount Amount to swap\n     * @param minReturn Minimum tokens to receive\n     * @param fusionData Fusion+ order data from 1inch API\n     * @param dstChainId Destination chain ID\n     */\n    function executeFusionSwapWithLottery(\n        address srcToken,\n        address dstToken,\n        uint256 amount,\n        uint256 minReturn,\n        bytes calldata fusionData,\n        uint256 dstChainId\n    ) external nonReentrant returns (bytes32 orderId, uint256 lotteryEntryId) {\n        \n        require(amount > 0, \"Invalid amount\");\n        require(dstChainId != block.chainid, \"Use same-chain swap\");\n        require(inchFusionRouter != address(0), \"Fusion router not configured\");\n        \n        // Generate order ID\n        orderId = _generateOrderId(msg.sender, srcToken, dstToken, amount);\n        \n        // 1. Transfer tokens from user\n        // Note: If srcToken is omniDRAGON, fees will be applied automatically\n        IERC20(srcToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        // 2. Get actual amount after any fees\n        uint256 actualAmount = IERC20(srcToken).balanceOf(address(this));\n        \n        // 3. Generate lottery entry immediately (cross-chain completion tracked separately)\n        lotteryEntryId = _generateLotteryEntry(\n            msg.sender,\n            srcToken,\n            amount // Use original amount\n        );\n        \n        // 4. Execute Fusion+ swap\n        _executeFusionSwap(srcToken, actualAmount, fusionData);\n        \n        // 5. Record swap order (completion tracked off-chain)\n        swapOrders[orderId] = SwapOrder({\n            trader: msg.sender,\n            srcToken: srcToken,\n            dstToken: dstToken,\n            srcAmount: amount,\n            minDstAmount: minReturn,\n            actualDstAmount: 0, // Will be updated when completed\n            lotteryEntryId: lotteryEntryId,\n            completed: false,\n            timestamp: block.timestamp,\n            swapType: \"cross_chain\"\n        });\n        \n        // 6. Update user stats\n        userSwapCount[msg.sender]++;\n        userTotalVolume[msg.sender] += amount;\n        \n        emit FusionSwapInitiated(\n            orderId, \n            msg.sender, \n            block.chainid, \n            dstChainId, \n            lotteryEntryId\n        );\n        \n        return (orderId, lotteryEntryId);\n    }\n\n    // ================================\n    // INTERNAL FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Execute swap via 1inch Aggregation Router\n     */\n    function _executeAggregationSwap(\n        address srcToken,\n        address dstToken,\n        uint256 amount,\n        uint256 minReturn,\n        bytes calldata swapData\n    ) internal returns (uint256 dstAmount) {\n        \n        // Approve tokens to 1inch router\n        IERC20(srcToken).safeIncreaseAllowance(inchAggregationRouter, amount);\n        \n        // Get balance before swap\n        uint256 balanceBefore = IERC20(dstToken).balanceOf(address(this));\n        \n        // Execute swap via 1inch\n        (bool success, ) = inchAggregationRouter.call(swapData);\n        require(success, \"1inch swap failed\");\n        \n        // Calculate received amount\n        uint256 balanceAfter = IERC20(dstToken).balanceOf(address(this));\n        dstAmount = balanceAfter - balanceBefore;\n        \n        require(dstAmount >= minReturn, \"Insufficient output amount\");\n        \n        return dstAmount;\n    }\n    \n    /**\n     * @dev Execute cross-chain swap via 1inch Fusion+\n     */\n    function _executeFusionSwap(\n        address srcToken,\n        uint256 amount,\n        bytes calldata fusionData\n    ) internal {\n        \n        // Approve tokens to Fusion router\n        IERC20(srcToken).safeIncreaseAllowance(inchFusionRouter, amount);\n        \n        // Execute Fusion+ order\n        (bool success, ) = inchFusionRouter.call(fusionData);\n        require(success, \"Fusion+ swap failed\");\n    }\n    \n    /**\n     * @dev Generate lottery entry for the swap\n     */\n    function _generateLotteryEntry(\n        address user,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 lotteryEntryId) {\n        \n        try lotteryManager.processSwapLottery(\n            user,\n            token,\n            amount,\n            0 // Let lottery manager calculate USD value\n        ) returns (uint256 entryId) {\n            \n            emit LotteryEntryGenerated(user, entryId, token, amount);\n            return entryId;\n            \n        } catch {\n            // Lottery generation failed, but swap should continue\n            // Return 0 to indicate no lottery entry was created\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Generate unique order ID\n     */\n    function _generateOrderId(\n        address trader,\n        address srcToken,\n        address dstToken,\n        uint256 amount\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            trader,\n            srcToken,\n            dstToken,\n            amount,\n            block.timestamp,\n            block.number,\n            userSwapCount[trader]\n        ));\n    }\n\n    // ================================\n    // VIEW FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Get swap order details\n     */\n    function getSwapOrder(bytes32 orderId) \n        external \n        view \n        returns (SwapOrder memory) \n    {\n        return swapOrders[orderId];\n    }\n    \n    /**\n     * @dev Get user's swap statistics\n     */\n    function getUserStats(address user) \n        external \n        view \n        returns (\n            uint256 totalSwaps, \n            uint256 totalVolume,\n            uint256 lastSwapTime\n        ) \n    {\n        totalSwaps = userSwapCount[user];\n        totalVolume = userTotalVolume[user];\n        \n        // Find last swap time (simplified - in production might want to track this separately)\n        lastSwapTime = 0;\n        // Could implement by tracking user's order IDs\n    }\n\n    /**\n     * @dev Preview swap execution (for frontend)\n     */\n    function previewSwap(\n        address user,\n        address srcToken,\n        uint256 amount\n    ) external view returns (\n        bool willGenerateLottery,\n        uint256 estimatedFees,\n        string memory feeReason\n    ) {\n        \n        willGenerateLottery = true; // All swaps generate lottery entries\n        \n        // Check if omniDRAGON is involved (fees would be applied by token contract)\n        if (srcToken == omniDRAGONToken) {\n            estimatedFees = (amount * 1000) / 10000; // 10% fee\n            feeReason = \"omniDRAGON_token_fee\";\n        } else {\n            estimatedFees = 0;\n            feeReason = \"no_additional_fees\";\n        }\n        \n        return (willGenerateLottery, estimatedFees, feeReason);\n    }\n\n    // ================================\n    // ADMIN FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Set 1inch router addresses\n     */\n    function setRouterAddresses(\n        address _aggregationRouter,\n        address _fusionRouter\n    ) external onlyOwner {\n        require(_aggregationRouter != address(0), \"Invalid aggregation router\");\n        require(_fusionRouter != address(0), \"Invalid fusion router\");\n        \n        inchAggregationRouter = _aggregationRouter;\n        inchFusionRouter = _fusionRouter;\n    }\n    \n    /**\n     * @dev Update platform fee (emergency only)\n     */\n    function setPlatformFee(uint256 _fee) external onlyOwner {\n        require(_fee <= 100, \"Fee too high\"); // Max 1%\n        platformFee = _fee;\n    }\n    \n    /**\n     * @dev Update omniDRAGON token address\n     */\n    function setOmniDRAGONToken(address _omniDRAGONToken) external onlyOwner {\n        require(_omniDRAGONToken != address(0), \"Invalid omniDRAGON token\");\n        omniDRAGONToken = _omniDRAGONToken;\n    }\n    \n    /**\n     * @dev Update order status (for cross-chain tracking)\n     */\n    function updateOrderStatus(\n        bytes32 orderId, \n        uint256 actualDstAmount,\n        bool completed\n    ) external onlyOwner {\n        \n        SwapOrder storage order = swapOrders[orderId];\n        require(order.trader != address(0), \"Order not found\");\n        \n        order.actualDstAmount = actualDstAmount;\n        order.completed = completed;\n    }\n    \n    /**\n     * @dev Emergency token recovery for non-core tokens only. Disallow withdrawing omniDRAGON token for optics.\n     */\n    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n        require(token != omniDRAGONToken, \"Cannot withdraw omniDRAGON\");\n        if (token == address(0)) {\n            payable(owner()).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(owner(), amount);\n        }\n    }\n\n    /**\n     * @dev Emergency pause (withdraw all tokens)\n     */\n    function emergencyPause() external onlyOwner {\n        // This contract should never hold tokens for extended periods\n        // Any tokens here are likely from failed swaps or fees\n        \n        // Could implement a more sophisticated pause mechanism if needed\n        revert(\"Use emergencyWithdraw for specific tokens\");\n    }\n\n    // ================================\n    // INTEGRATION HELPERS\n    // ================================\n    \n    /**\n     * @dev Batch execute multiple swaps (gas optimization)\n     */\n    function batchExecuteSwaps(\n        address[] calldata srcTokens,\n        address[] calldata dstTokens,\n        uint256[] calldata amounts,\n        uint256[] calldata minReturns,\n        bytes[] calldata swapDatas\n    ) external nonReentrant returns (\n        bytes32[] memory orderIds,\n        uint256[] memory lotteryEntryIds\n    ) {\n        \n        require(srcTokens.length == dstTokens.length, \"Array length mismatch\");\n        require(srcTokens.length == amounts.length, \"Array length mismatch\");\n        require(srcTokens.length == minReturns.length, \"Array length mismatch\");\n        require(srcTokens.length == swapDatas.length, \"Array length mismatch\");\n        require(srcTokens.length <= 10, \"Too many swaps\"); // Prevent gas issues\n        \n        orderIds = new bytes32[](srcTokens.length);\n        lotteryEntryIds = new uint256[](srcTokens.length);\n        \n        for (uint256 i = 0; i < srcTokens.length; i++) {\n            (orderIds[i], lotteryEntryIds[i]) = this.executeSwapWithLottery(\n                srcTokens[i],\n                dstTokens[i],\n                amounts[i],\n                minReturns[i],\n                swapDatas[i]\n            );\n        }\n        \n        return (orderIds, lotteryEntryIds);\n    }\n\n    /**\n     * @dev Receive ETH for native token swaps\n     */\n    receive() external payable {\n        // Allow receiving ETH for native token swaps\n    }\n\n    // ========== SONIC FEEM INTEGRATION ==========\n\n    /**\n     * @dev Register my contract on Sonic FeeM\n     * @notice This registers the contract with Sonic's Fee Manager for network benefits\n     */\n    function registerMe() external onlyOwner {\n        (bool _success,) = address(0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830).call(\n            abi.encodeWithSignature(\"selfRegister(uint256)\", 143)\n        );\n        require(_success, \"FeeM registration failed\");\n    }\n\n    /**\n     * @dev Fallback function\n     */\n    fallback() external payable {\n        revert(\"Function not found\");\n    }\n}"
    },
    "contracts/interfaces/config/IOmniDragonRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonRegistry\n * @dev Interface for OmniDragon registry with oracle management\n */\ninterface IOmniDragonRegistry {\n  /**\n   * @dev Simplified struct to hold essential chain configuration\n   */\n  struct ChainConfig {\n    uint16 chainId;\n    string chainName;\n    address wrappedNativeToken; // WETH, WAVAX, WS, etc.\n    string wrappedNativeSymbol; // \"WETH\", \"WAVAX\", \"WS\", etc.\n    address uniswapV2Router; // DEX router for this chain\n    address uniswapV2Factory; // DEX factory for this chain\n    bool isActive; // Whether this chain is active\n  }\n\n  /**\n   * @dev Oracle configuration struct\n   */\n  struct OracleConfig {\n    address primaryOracle;      // Primary oracle address (Sonic chain)\n    uint32 primaryChainEid;    // Primary chain EID\n    uint32 lzReadChannelId;    // lzRead channel ID\n    bool isConfigured;         // Whether oracle is configured\n  }\n\n  // Events\n  event ChainRegistered(uint16 indexed chainId, string chainName);\n  event ChainUpdated(uint16 indexed chainId);\n  event ChainStatusChanged(uint16 indexed chainId, bool isActive);\n  \n  // Oracle events\n  event PriceOracleSet(uint16 indexed chainId, address indexed oracle);\n  event PrimaryOracleConfigured(address indexed primaryOracle, uint32 chainEid);\n  event LzReadChannelConfigured(uint16 indexed chainId, uint32 channelId);\n\n  /**\n   * @notice Register a new chain configuration\n   * @param _chainId The chain ID\n   * @param _chainName The human-readable chain name\n   * @param _wrappedNativeToken The wrapped native token address\n   * @param _uniswapV2Router The Uniswap V2 router address\n   * @param _uniswapV2Factory The Uniswap V2 factory address\n   * @param _isActive Whether this chain is active\n   */\n  function registerChain(\n    uint16 _chainId,\n    string calldata _chainName,\n    address _wrappedNativeToken,\n    address _uniswapV2Router,\n    address _uniswapV2Factory,\n    bool _isActive\n  ) external;\n\n  /**\n   * @notice Update existing chain configuration\n   * @param _chainId The chain ID to update\n   * @param _chainName The human-readable chain name\n   * @param _wrappedNativeToken The wrapped native token address\n   * @param _uniswapV2Router The Uniswap V2 router address\n   * @param _uniswapV2Factory The Uniswap V2 factory address\n   */\n  function updateChain(\n    uint16 _chainId,\n    string calldata _chainName,\n    address _wrappedNativeToken,\n    address _uniswapV2Router,\n    address _uniswapV2Factory\n  ) external;\n\n  /**\n   * @notice Set chain active status\n   * @param _chainId The chain ID\n   * @param _isActive Whether the chain should be active\n   */\n  function setChainStatus(uint16 _chainId, bool _isActive) external;\n\n  /**\n   * @notice Get chain configuration\n   * @param _chainId The chain ID\n   * @return config The chain configuration\n   */\n  function getChainConfig(uint16 _chainId) external view returns (ChainConfig memory config);\n\n  /**\n   * @notice Get all supported chains\n   * @return Array of supported chain IDs\n   */\n  function getSupportedChains() external view returns (uint16[] memory);\n\n  /**\n   * @notice Get current chain ID\n   * @return The current chain ID\n   */\n  function getCurrentChainId() external view returns (uint16);\n\n  /**\n   * @notice Check if chain is supported and active\n   * @param _chainId The chain ID to check\n   * @return True if chain is supported and active\n   */\n  function isChainSupported(uint16 _chainId) external view returns (bool);\n\n  /**\n   * @notice Get wrapped native token address for a chain\n   * @param _chainId The chain ID\n   * @return The wrapped native token address\n   */\n  function getWrappedNativeToken(uint16 _chainId) external view returns (address);\n\n  /**\n   * @notice Get wrapped native token symbol for a chain\n   * @param _chainId The chain ID\n   * @return The wrapped native token symbol\n   */\n  function getWrappedNativeSymbol(uint16 _chainId) external view returns (string memory);\n\n  /**\n   * @notice Get Uniswap V2 router for a chain\n   * @param _chainId The chain ID\n   * @return The Uniswap V2 router address\n   */\n  function getUniswapV2Router(uint16 _chainId) external view returns (address);\n\n  /**\n   * @notice Get Uniswap V2 factory for a chain\n   * @param _chainId The chain ID\n   * @return The Uniswap V2 factory address\n   */\n  function getUniswapV2Factory(uint16 _chainId) external view returns (address);\n\n  /**\n   * @notice Get LayerZero endpoint for a chain\n   * @param _chainId The chain ID\n   * @return The LayerZero endpoint address\n   */\n  function getLayerZeroEndpoint(uint16 _chainId) external view returns (address);\n\n  // ============ ORACLE MANAGEMENT ============\n\n  /**\n   * @notice Set price oracle for a specific chain\n   * @param _chainId Chain ID\n   * @param _oracle Oracle address\n   */\n  function setPriceOracle(uint16 _chainId, address _oracle) external;\n\n  /**\n   * @notice Get price oracle for a specific chain\n   * @param _chainId Chain ID\n   * @return Oracle address\n   */\n  function getPriceOracle(uint16 _chainId) external view returns (address);\n\n  /**\n   * @notice Configure primary oracle (on Sonic chain)\n   * @param _primaryOracle Primary oracle address\n   * @param _chainEid Primary chain EID\n   */\n  function configurePrimaryOracle(address _primaryOracle, uint32 _chainEid) external;\n\n  /**\n   * @notice Set lzRead channel for a chain\n   * @param _chainId Chain ID\n   * @param _channelId lzRead channel ID\n   */\n  function setLzReadChannel(uint16 _chainId, uint32 _channelId) external;\n\n  /**\n   * @notice Get oracle configuration for a chain\n   * @param _chainId Chain ID\n   * @return Oracle configuration\n   */\n  function getOracleConfig(uint16 _chainId) external view returns (OracleConfig memory);\n} "
    },
    "contracts/interfaces/governance/partners/IDragonGaugeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonGaugeRegistry\n * @dev Interface for managing Dragon ecosystem partner gauges and metadata.\n * Aligns with existing registry implementation used by partner pool, factory,\n * fee distributor, and veDRAGON boost manager components.\n */\ninterface IDragonGaugeRegistry {\n  // === View Functions ===\n  function partnerList(uint256 index) external view returns (address);\n  function isPartnerActive(address partner) external view returns (bool);\n  function getPartnerCount() external view returns (uint256);\n\n  // Detailed getters used across contracts\n  function getPartnerDetails(\n    address partnerAddress\n  ) external view returns (string memory name, uint256 feeShare, uint256 probabilityBoost, bool isActive);\n\n  function partners(\n    address partnerAddress\n  ) external view returns (string memory name, uint256 feeShare, uint256 probabilityBoost, bool isActive);\n\n  function authorizedDistributors(address distributor) external view returns (bool);\n  function isDistributorAuthorized(address distributor) external view returns (bool);\n  function defaultProbabilityBoost() external view returns (uint256);\n  function isWhitelistedPartner(address partner) external view returns (bool);\n  function getPartnerBoost(address partner) external view returns (uint256);\n\n  // === State-Changing Functions ===\n  function addPartner(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare,\n    uint256 probabilityBoost\n  ) external;\n\n  function addPartnerWithDefaultBoost(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare\n  ) external;\n\n  function updatePartner(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare,\n    uint256 probabilityBoost\n  ) external;\n\n  function updatePartnerWithDefaultBoost(\n    address partnerAddress,\n    string memory name,\n    uint256 feeShare\n  ) external;\n\n  function deactivatePartner(address partnerAddress) external;\n  function setDistributorAuthorization(address distributor, bool authorized) external;\n  function setDefaultProbabilityBoost(uint256 boost) external;\n\n  // Simplified registration helpers used by other components\n  function registerPartner(address partner, uint256 boost) external;\n  function removePartner(address partner) external;\n}\n\n\n"
    },
    "contracts/interfaces/governance/voting/IveDRAGONBoostManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @title IveDRAGONBoostManager\n * @dev Interface for the veDRAGON boost manager contract\n *\n * Provides additional functionality for veDRAGON holders including boosts for protocol actions\n * Manages partner probability boosts and voting-based lottery enhancements\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IveDRAGONBoostManager\n * @dev Interface for the veDRAGON boost manager contract\n *\n * Provides additional functionality for veDRAGON holders including boosts for protocol actions\n * Manages partner probability boosts and voting-based lottery enhancements\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IveDRAGONBoostManager {\n  // === Events ===\n  event BoostCalculated(address indexed user, uint256 boost);\n\n  // === View Functions ===\n  /**\n   * @dev Calculate boost multiplier for a user based on their veDRAGON holdings\n   * @param user User address\n   * @return Boost multiplier in basis points (10000 = 100%, 25000 = 250%)\n   */\n  function calculateBoost(address user) external view returns (uint256);\n\n  /**\n   * @dev Get the probability boost for a partner\n   * @param partnerId Partner ID\n   * @return Probability boost in basis points (e.g., 100 = 1%)\n   */\n  function getPartnerProbabilityBoost(uint256 partnerId) external view returns (uint256);\n\n  // === Action Functions ===\n  /**\n   * @dev Calculate boost for a user and emit an event\n   * @param user User address\n   * @return Boost multiplier\n   */\n  function getBoostWithEvent(address user) external returns (uint256);\n\n  /**\n   * @dev Enter jackpot with a boosted amount\n   * @param user User address\n   * @param amount Base amount to boost\n   * @return Boosted amount\n   */\n  function enterJackpotWithBoost(address user, uint256 amount) external returns (uint256);\n\n  /**\n   * @dev Vote for a partner to allocate probability boost\n   * @param partnerId Partner ID\n   * @param weight Voting weight (optional, may be unused in some implementations)\n   */\n  function voteForPartner(uint256 partnerId, uint256 weight) external;\n}"
    },
    "contracts/interfaces/governance/voting/IveDRAGONRevenueDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Interface: IveDRAGONRevenueDistributor\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title IveDRAGONRevenueDistributor\n * @dev Interface for the veDRAGON revenue distributor contract\n *\n * Manages revenue collection and distribution to veDRAGON holders\n * Core component of the OmniDragon revenue sharing mechanism\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IveDRAGONRevenueDistributor {\n  /**\n   * @notice Receive rewards (DRAGON tokens) from external sources\n   * @param _amount The amount of DRAGON tokens to receive\n   */\n  function receiveRewards(uint256 _amount) external;\n\n  /**\n   * @notice Distribute accumulated rewards to the veDRAGON contract or reward mechanism\n   */\n  function distributeRewards() external;\n\n  /**\n   * @notice Get the current accumulated rewards that have not been distributed\n   * @return The amount of undistributed rewards\n   */\n  function accumulatedRewards() external view returns (uint256);\n\n  /**\n   * @notice Set the DRAGON token address\n   * @param _rewardToken The address of the DRAGON token\n   */\n  function setRewardToken(address _rewardToken) external;\n\n  /**\n   * @notice Update the veDRAGON recipient address\n   * @param _veDRAGONAddress The new veDRAGON contract or reward distributor address\n   */\n  function setVeDRAGONAddress(address _veDRAGONAddress) external;\n\n  /**\n   * @notice Set the wrapped native token address\n   * @param _wrappedNativeToken The new wrapped native token address\n   */\n  function setWrappedNativeToken(address _wrappedNativeToken) external;\n}"
    },
    "contracts/interfaces/lottery/IDragonJackpotDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonJackpotDistributor\n * @author 0xakita.eth\n * @notice Interface for the Dragon jackpot distribution system\n * @dev Handles prize distribution from jackpot vault to lottery winners\n */\ninterface IDragonJackpotDistributor {\n    /**\n     * @notice Distribute jackpot to a winner\n     * @param winner Address of the lottery winner\n     * @param amount Amount to distribute in DRAGON tokens\n     */\n    function distributeJackpot(address winner, uint256 amount) external;\n    \n    /**\n     * @notice Get the current jackpot amount available for distribution\n     * @return jackpot Current jackpot amount in DRAGON tokens\n     */\n    function getCurrentJackpot() external view returns (uint256 jackpot);\n    \n    /**\n     * @notice Get the minimum jackpot amount for distribution\n     * @return minimum Minimum jackpot amount\n     */\n    function getMinimumJackpot() external view returns (uint256 minimum);\n    \n    /**\n     * @notice Check if jackpot distribution is currently enabled\n     * @return enabled Whether distribution is enabled\n     */\n    function isDistributionEnabled() external view returns (bool enabled);\n    \n    /**\n     * @notice Get the last distribution timestamp\n     * @return timestamp Last distribution time\n     */\n    function getLastDistributionTime() external view returns (uint256 timestamp);\n    \n    /**\n     * @notice Get total amount distributed to date\n     * @return total Total distributed amount\n     */\n    function getTotalDistributed() external view returns (uint256 total);\n    \n    /**\n     * @notice Get distribution statistics for a specific winner\n     * @param winner Winner address\n     * @return totalReceived Total amount received by this winner\n     * @return distributionCount Number of distributions received\n     */\n    function getWinnerStats(address winner) external view returns (\n        uint256 totalReceived,\n        uint256 distributionCount\n    );\n}"
    },
    "contracts/interfaces/lottery/IDragonJackpotVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IDragonJackpotVault\n * @dev Interface for the Dragon Jackpot Vault system\n *\n * Manages jackpot accumulation, distribution, and lottery mechanics\n * Core component of the OmniDragon tokenomics and reward system\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\n\n/**\n * @title IDragonJackpotVault\n * @dev Interface for the Dragon Jackpot Vault system\n *\n * Manages jackpot accumulation, distribution, and lottery mechanics\n * Core component of the OmniDragon tokenomics and reward system\n */\ninterface IDragonJackpotVault {\n  /**\n   * @dev Add ERC20 tokens to the jackpot with proper token tracking\n   * @param token Token address\n   * @param amount Amount to add\n   */\n  function addERC20ToJackpot(address token, uint256 amount) external;\n\n  /**\n   * @dev Add collected funds that are already in the vault (for trusted callers only)\n   * @param token Token address\n   * @param amount Amount to add to accounting\n   */\n  function addCollectedFunds(address token, uint256 amount) external;\n\n  /**\n   * @notice Get the current jackpot balance\n   * @return balance The current jackpot balance\n   */\n  function getJackpotBalance() external view returns (uint256 balance);\n\n  /**\n   * @notice Pay out entire jackpot to a winner - Winner Takes All!\n   * @param winner Address of the winner (gets everything!)\n   * @param amount Amount to pay (ignored - winner gets everything!)\n   */\n  function payJackpot(address winner, uint256 amount) external;\n\n  /**\n   * @notice Pay ENTIRE jackpot to winner - Winner Takes All!\n   * @param winner Winner address who gets everything\n   */\n  function payEntireJackpot(address winner) external;\n\n  /**\n   * @notice Get the time of the last jackpot win\n   * @return timestamp The last win timestamp\n   */\n  function getLastWinTime() external view returns (uint256 timestamp);\n\n  /**\n   * @notice Set the wrapped native token address\n   * @param _wrappedNativeToken The new wrapped native token address\n   */\n  function setWrappedNativeToken(address _wrappedNativeToken) external;\n\n  /**\n   * @dev Enter the jackpot with Dragon tokens\n   * @param user Address of the user entering the jackpot\n   * @param amount Amount of Dragon tokens to enter\n   */\n  function enterJackpotWithDragon(address user, uint256 amount) external;\n\n  /**\n   * @dev Enter the jackpot with wrapped native tokens\n   * @param user Address of the user entering the jackpot\n   * @param amount Amount of wrapped native tokens to enter\n   */\n  function enterJackpotWithWrappedNativeToken(address user, uint256 amount) external;\n\n  /**\n   * @dev Enter the jackpot with native tokens\n   * @param user Address of the user entering the jackpot\n   */\n  function enterJackpotWithNative(address user) external payable;\n\n  /**\n   * @dev Get jackpot balance for a specific token\n   * @param token Token address\n   * @return Jackpot balance\n   */\n  function getJackpotBalance(address token) external view returns (uint256);\n}"
    },
    "contracts/interfaces/lottery/IOmniDragonLotteryManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonLotteryManager\n * @author 0xakita.eth\n * @dev Interface for lottery manager with smart fee detection integration\n */\ninterface IOmniDragonLotteryManager {\n    \n    // ================================\n    // STRUCTS\n    // ================================\n    \n    struct SwapLotteryEntry {\n        address trader;\n        address tokenIn;\n        uint256 amountIn;\n        uint256 swapValueUSD;\n        uint256 baseProb;              // Base probability from USD amount\n        uint256 veDragonMultiplier;    // veDRAGON multiplier (1x to 2.5x)\n        uint256 finalProb;             // Final probability\n        uint256 requestId;             // Chainlink VRF request ID\n        uint256 randomWord;\n        bool fulfilled;\n        bool won;\n        uint256 prizeAmount;\n        uint256 timestamp;\n    }\n    \n    struct UserMilestone {\n        uint256 totalVolumeUSD;        // Lifetime trading volume\n        uint256 lastUpdated;\n        mapping(address => uint256) tokenVolumes;\n        mapping(uint256 => uint256) chainVolumes;\n    }\n\n    // ================================\n    // EVENTS\n    // ================================\n    \n    event SwapLotteryCreated(\n        uint256 indexed entryId,\n        address indexed trader,\n        uint256 swapValueUSD,\n        uint256 finalProbability,\n        uint256 veDragonMultiplier\n    );\n    \n    event VolumeUpdated(\n        address indexed trader,\n        uint256 volumeAdded,\n        uint256 totalVolume\n    );\n    \n    event LotteryFulfilled(\n        uint256 indexed entryId,\n        address indexed trader,\n        bool won,\n        uint256 prizeAmount,\n        uint256 randomWord\n    );\n\n    // ================================\n    // MAIN FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Process swap lottery - handles all lottery logic including USD calculation\n     * @param trader Address of the trader\n     * @param tokenIn Address of input token\n     * @param amountIn Amount of input tokens\n     * @param swapValueUSD USD value (0 = calculate internally using oracle)\n     * @return entryId Generated lottery entry ID\n     */\n    function processSwapLottery(\n        address trader,\n        address tokenIn,\n        uint256 amountIn,\n        uint256 swapValueUSD\n    ) external returns (uint256 entryId);\n\n    // ================================\n    // VIEW FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Preview lottery probability for a potential swap\n     */\n    function previewSwapLottery(address trader, uint256 swapValueUSD)\n        external\n        view\n        returns (\n            uint256 baseProb,\n            uint256 veDragonMultiplier,\n            uint256 finalProb,\n            uint256 probabilityPercent,\n            bool isCapped\n        );\n    \n    /**\n     * @dev Get user volume statistics\n     */\n    function getUserVolume(address trader) \n        external \n        view \n        returns (\n            uint256 totalVolume,\n            uint256 lastUpdated\n        );\n    \n    /**\n     * @dev Get detailed probability breakdown for UI\n     */\n    function getDetailedProbability(address trader, uint256 swapValueUSD)\n        external\n        view\n        returns (\n            uint256 baseProbabilityBPS,      // Base prob in basis points\n            uint256 veDragonMultiplierBPS,   // veDRAGON multiplier in basis points (10000 = 1x)\n            uint256 finalProbabilityBPS,     // Final prob in basis points\n            string memory probabilityDisplay, // Human readable \"X.XXX%\"\n            string memory veDragonBoost,     // Human readable \"2.3x boost\"\n            bool isCapped\n        );\n    \n    /**\n     * @dev Get lottery entry details\n     */\n    function getLotteryEntry(uint256 entryId)\n        external\n        view\n        returns (SwapLotteryEntry memory);\n    \n    /**\n     * @dev Get user's current veDRAGON boost level\n     */\n    function getUserVeDragonBoost(address trader)\n        external\n        view\n        returns (\n            uint256 veDragonBalance,\n            uint256 multiplier,\n            string memory boostDisplay,\n            uint256 percentile\n        );\n\n    // ================================\n    // ADMIN FUNCTIONS\n    // ================================\n    \n    /**\n     * @dev Set authorized swap integrator\n     */\n    function setSwapIntegrator(address integrator, bool authorized) external;\n    \n    /**\n     * @dev Update VRF configuration\n     */\n    function updateVRFConfig(\n        address vrfCoordinator,\n        bytes32 keyHash,\n        uint64 subscriptionId\n    ) external;\n    \n    /**\n     * @dev Emergency functions\n     */\n    function emergencyPause() external;\n    function emergencyUnpause() external;\n}"
    },
    "contracts/interfaces/oracles/IApi3ReaderProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IApi3ReaderProxy\n * @dev Interface for API3 dAPI reader proxy\n */\ninterface IApi3ReaderProxy {\n  function read() external view returns (int224 value, uint32 timestamp);\n}"
    },
    "contracts/interfaces/oracles/IOmniDragonPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonPriceOracle\n * @dev Interface for OmniDragon Price Oracle with multi-source aggregation\n */\ninterface IOmniDragonPriceOracle {\n  // ============ STRUCTS ============\n\n  struct OracleConfig {\n    address feedAddress;\n    uint256 weight;\n    bool isActive;\n    uint256 maxStaleness;\n  }\n\n  // ============ EVENTS ============\n\n  event PriceUpdated(int256 indexed newPrice, uint256 timestamp, uint256 oracleCount);\n  event OracleConfigUpdated(string indexed oracleType, address indexed feedAddress, uint256 weight);\n  event CircuitBreakerTriggered(string reason, int256 oldPrice, int256 newPrice, uint256 deviation);\n  event CircuitBreakerReset(address indexed admin);\n  event PriceInitialized(int256 initialPrice, uint256 timestamp);\n  event MaxDeviationUpdated(uint256 oldDeviation, uint256 newDeviation);\n  event EmergencyModeActivated(int256 emergencyPrice);\n  event EmergencyModeDeactivated();\n\n  // ============ MAIN FUNCTIONS ============\n\n  function getLatestPrice() external view returns (int256 price, uint256 timestamp);\n\n  function getAggregatedPrice() external view returns (int256 price, bool success, uint256 timestamp);\n\n  /**\n   * @notice Get the native token price (e.g., SONIC/USD, ETH/USD)\n   * @return price The price of native token in USD (8 decimals)\n   * @return isValid Whether the price is valid\n   * @return timestamp The timestamp of the price\n   */\n  function getNativeTokenPrice() external view returns (int256 price, bool isValid, uint256 timestamp);\n\n  function initializePrice() external returns (bool success);\n\n  function updatePrice() external returns (bool success);\n\n  // ============ ADMIN FUNCTIONS ============\n\n  function configureOracles(\n    address _chainlinkFeed,\n    address _bandFeed,\n    address _api3Feed,\n    address _pythFeed,\n    bytes32 _pythPriceId,\n    string calldata _bandBaseSymbol\n  ) external;\n\n  function setOracleWeights(\n    uint256 _chainlinkWeight,\n    uint256 _bandWeight,\n    uint256 _api3Weight,\n    uint256 _pythWeight\n  ) external;\n\n  function setMaxPriceDeviation(uint256 _maxDeviation) external;\n\n  function resetCircuitBreaker() external;\n\n  function activateEmergencyMode(int256 _emergencyPrice) external;\n\n  function deactivateEmergencyMode() external;\n\n  // ============ VIEW FUNCTIONS ============\n\n  function getOracleConfig()\n    external\n    view\n    returns (\n      OracleConfig memory chainlink,\n      OracleConfig memory band,\n      OracleConfig memory api3,\n      OracleConfig memory pyth,\n      string memory bandSymbol,\n      bytes32 pythId\n    );\n\n  function isFresh() external view returns (bool);\n\n  function getOracleStatus()\n    external\n    view\n    returns (\n      bool initialized,\n      bool circuitBreakerActive,\n      bool emergencyMode,\n      bool inGracePeriod,\n      uint256 activeOracles,\n      uint256 maxDeviation\n    );\n\n  /**\n   * @notice Get USD value of LP tokens\n   * @param lpToken LP token address\n   * @param amount Amount of LP tokens (18 decimals)\n   * @return usdValue USD value scaled by 1e6\n   */\n  function getLPTokenPrice(address lpToken, uint256 amount) external view returns (uint256 usdValue);\n}"
    },
    "contracts/interfaces/oracles/IPyth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./PythStructs.sol\";\n\n/**\n * @title IPyth\n * @dev Interface for Pyth Network price feeds\n */\ninterface IPyth {\n  function getPriceUnsafe(bytes32 id) external view returns (PythStructs.Price memory price);\n  \n  function getPrice(bytes32 id) external view returns (PythStructs.Price memory price);\n  \n  function getPriceNoOlderThan(bytes32 id, uint age) external view returns (PythStructs.Price memory price);\n}"
    },
    "contracts/interfaces/oracles/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title PythStructs\n * @dev Pyth Network data structures\n */\nlibrary PythStructs {\n  struct Price {\n    int64 price;\n    uint64 conf;\n    int32 expo;\n    uint256 publishTime;\n  }\n\n  struct PriceFeed {\n    bytes32 id;\n    Price price;\n    Price emaPrice;\n  }\n}"
    },
    "contracts/interfaces/tokens/IOmniDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IOmniDRAGON\n * @author 0xakita.eth\n * @dev Interface for the omniDRAGON LayerZero OFT V2 token with lottery integration\n * \n * Features:\n * - LayerZero OFT V2 cross-chain functionality  \n * - Integrated lottery system for trading incentives\n * - 1inch Fusion+ integration bonuses\n * - Registry-based multi-chain configuration\n * - Vanity address deployment (0x69...7777)\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\ninterface IOmniDRAGON is IERC20 {\n    \n    /**\n     * @dev Fee structure for buy/sell transactions\n     */\n    struct Fees {\n        uint16 jackpot;    // Basis points for jackpot\n        uint16 veDRAGON;   // Basis points for veDRAGON holders\n        uint16 burn;       // Basis points to burn\n        uint16 total;      // Total basis points\n    }\n    \n    /**\n     * @dev Control flags for the contract\n     */\n    struct ControlFlags {\n        bool feesEnabled;\n        bool tradingEnabled;\n        bool initialMintCompleted;\n        bool paused;\n        bool emergencyMode;\n    }\n    \n    /**\n     * @dev Cross-chain transfer information\n     */\n    struct CrossChainTransfer {\n        uint32 dstEid;\n        address to;\n        uint256 amount;\n        uint256 fee;\n        bytes extraOptions;\n    }\n    \n    // Events\n    event FeesUpdated(Fees newFees);\n    event VaultUpdated(address indexed vault, string vaultType);\n    event TradingEnabled(bool enabled);\n    event FeesEnabled(bool enabled);\n    event PairUpdated(address indexed pair, bool isListed);\n    event LotteryManagerUpdated(address indexed newManager);\n    event CrossChainTransferInitiated(\n        uint32 indexed dstEid,\n        address indexed to,\n        uint256 amount,\n        uint256 fee\n    );\n    event FeeDistributed(\n        address indexed vault,\n        uint256 amount,\n        string category\n    );\n    event LotteryTriggered(\n        address indexed trader,\n        uint256 amount,\n        uint256 tickets\n    );\n    event EmergencyModeToggled(bool enabled);\n    \n    // View functions\n    function getFees() external view returns (Fees memory buyFees_, Fees memory sellFees_);\n    function getControlFlags() external view returns (ControlFlags memory);\n    function getDistributionAddresses() external view returns (address jackpot, address revenue);\n    function jackpotVault() external view returns (address);\n    function revenueDistributor() external view returns (address);\n    function lotteryManager() external view returns (address);\n    function registry() external view returns (address);\n    function isPair(address account) external view returns (bool);\n    function isExcludedFromFees(address account) external view returns (bool);\n    function isExcludedFromMaxTransfer(address account) external view returns (bool);\n    \n    // Admin functions\n    function updateVaults(address _jackpotVault, address _revenueDistributor) external;\n    function setPair(address pair, bool isActive) external;\n    function setExcludeFromFees(address account, bool excluded) external;\n    function setExcludeFromMaxTransfer(address account, bool excluded) external;\n    function updateFees(bool isBuy, uint16 _jackpot, uint16 _veDRAGON, uint16 _burn) external;\n    function setLotteryManager(address _lotteryManager) external;\n    function toggleTrading() external;\n    function toggleFees() external;\n    function togglePause() external;\n    function toggleEmergencyMode() external;\n    function emergencyWithdrawNative(uint256 amount) external;\n    function emergencyWithdrawToken(address token, uint256 amount) external;\n    \n    // Additional functions\n    function registerMe() external;\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/interfaces/tokens/IredDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IredDRAGON\n * @dev Interface for redDRAGON - An ERC-4626 vault for Uniswap V2 LP tokens with lottery integration\n *\n * OVERVIEW:\n * redDRAGON is an ERC-4626 vault that represents ownership of underlying DRAGON/wrappedNative LP tokens.\n * As LP tokens auto-compound through trading fees, redDRAGON shares maintain proper accounting.\n * When users buy/sell redDRAGON through DEX pairs, it triggers:\n * 1. Immediate fee collection (6.9% of transaction amount)\n * 2. Immediate fee distribution (69% to jackpot, 31% to veDRAGON holders)\n * 3. Lottery entry based on transaction value (BUYS ONLY)\n *\n * ERC-4626 VAULT MECHANICS:\n * - Shares represent proportional ownership of LP tokens\n * - As LP tokens appreciate from trading fees, shares become worth more LP tokens\n * - Standard vault functions: deposit, withdraw, mint, redeem\n * - Preview functions show expected conversions\n */\ninterface IredDRAGON {\n  // ========== STRUCTS ==========\n\n  struct SwapConfig {\n    address jackpotVault; // Jackpot vault address\n    address revenueDistributor; // veDRAGON revenue distributor\n    address lotteryManager; // Lottery manager for entries\n  }\n\n  struct LotteryConfig {\n    uint256 minSwapUSD; // Minimum USD swap amount for lottery entry\n    uint256 maxSwapUSD; // Maximum USD swap amount for max probability\n    uint256 minProbabilityPPM; // Minimum probability in parts per million\n    uint256 maxProbabilityPPM; // Maximum probability in parts per million\n    bool enabled; // Whether lottery is enabled\n  }\n\n  // ========== EVENTS ==========\n\n  event TradingEnabled(uint256 timestamp);\n  event TradingPaused(uint256 timestamp);\n  event PairUpdated(address indexed pair, bool indexed isPair);\n  event FeeExclusionUpdated(address indexed account, bool excluded);\n\n  // ========== INITIALIZATION ==========\n\n  /**\n   * @notice Initialize the contract (called once after deployment)\n   * @param _owner Owner address\n   * @param _jackpotVault Jackpot vault address\n   * @param _revenueDistributor veDRAGON revenue distributor\n   * @param _lotteryManager Lottery manager address\n   */\n  function initialize(\n    address _owner,\n    address _jackpotVault,\n    address _revenueDistributor,\n    address _lotteryManager\n  ) external;\n\n  // ========== VIEW FUNCTIONS ==========\n\n  /**\n   * @notice Get current swap configuration\n   * @return config Current swap configuration\n   */\n  function getSwapConfig() external view returns (SwapConfig memory config);\n\n  /**\n   * @notice Get current lottery configuration\n   * @return config Current lottery configuration\n   */\n  function getLotteryConfig() external view returns (LotteryConfig memory config);\n\n  /**\n   * @notice Get USD value of redDRAGON shares (simplified - no oracle needed)\n   * @param token Token address (ignored)\n   * @param amount Amount of redDRAGON shares\n   * @return usdValue USD value (always returns 0 for simplicity)\n   */\n  function getUSDValue(address token, uint256 amount) external view returns (uint256 usdValue);\n\n  /**\n   * @notice Check if address is authorized swap contract (deprecated)\n   * @param swapContract Swap contract address\n   * @return authorized Whether address is authorized (always false)\n   */\n  function isAuthorizedSwapContract(address swapContract) external view returns (bool authorized);\n\n  /**\n   * @notice Get total fees collected\n   * @return jackpotFees Total fees sent to jackpot\n   * @return revenueFees Total fees sent to revenue distributor\n   */\n  function getTotalFees() external view returns (uint256 jackpotFees, uint256 revenueFees);\n\n  /**\n   * @notice Check if contract is initialized\n   * @return initialized Whether contract is initialized\n   */\n  function isInitialized() external view returns (bool);\n}"
    },
    "contracts/interfaces/tokens/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IUniswapV2Pair\n * @dev Interface for Uniswap V2 pair contracts\n */\ninterface IUniswapV2Pair {\n  function name() external pure returns (string memory);\n  function symbol() external pure returns (string memory);\n  function decimals() external pure returns (uint8);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address owner) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n  function transfer(address to, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n  function factory() external view returns (address);\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function price0CumulativeLast() external view returns (uint256);\n  function price1CumulativeLast() external view returns (uint256);\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n  function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n  function skim(address to) external;\n  function sync() external;\n\n  function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/tokens/IveDRAGON.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IveDRAGON\n * @dev Interface for veDRAGON vote-escrowed token\n */\ninterface IveDRAGON {\n  // Custom errors\n  error ZeroAddress();\n  error ZeroAmount();\n  error LockExpired();\n  error LockNotExpired();\n  error ExistingLock();\n  error NoLock();\n  error InvalidDuration();\n  error TransferFailed();\n  error Unauthorized();\n\n  // Structs\n  struct LockedBalance {\n    uint256 amount;\n    uint256 unlockTime;\n  }\n\n  // Events\n  event Deposit(address indexed user, uint256 amount, uint256 lockTime, uint256 votingPower);\n  event Withdraw(address indexed user, uint256 amount);\n  event LockUpdated(address indexed user, uint256 lockDuration, uint256 votingPower);\n\n  // View functions\n  function votingPowerOf(address user) external view returns (uint256);\n  function getVotingPower(address account) external view returns (uint256);\n  function getVotingPowerAt(address user, uint256 timestamp) external view returns (uint256);\n  function getTotalVotingPower() external view returns (uint256);\n  function getTotalVotingPowerAt(uint256 timestamp) external view returns (uint256);\n  function lockedBalanceOf(address account) external view returns (uint256);\n  function unlockTimeOf(address account) external view returns (uint256);\n  function totalLockedSupply() external view returns (uint256);\n  function getUserLock(address user) external view returns (uint256 amount, uint256 end);\n  function hasActiveLock(address user) external view returns (bool);\n\n  // State changing functions\n  function createLock(uint256 lpAmount, uint256 lockDuration) external;\n  function increaseLockAmount(uint256 additionalAmount) external;\n  function extendLock(uint256 lockDuration) external;\n  function withdraw() external;\n}"
    },
    "contracts/interfaces/vrf/IChainlinkVRFIntegratorV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {\n  MessagingFee,\n  MessagingReceipt\n} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IChainlinkVRFIntegratorV2_5\n * @dev Interface for Chainlink VRF v2.5 integrator with LayerZero cross-chain capabilities\n */\ninterface IChainlinkVRFIntegratorV2_5 {\n  // ============ STRUCTS ============\n\n  struct VRFConfig {\n    uint64 subscriptionId;\n    bytes32 keyHash;\n    uint32 callbackGasLimit;\n    uint16 requestConfirmations;\n    uint32 numWords;\n    bool enabled;\n  }\n\n  struct CrossChainVRFRequest {\n    uint32 dstEid;\n    address requester;\n    uint256 nonce;\n    uint256 timestamp;\n    bool fulfilled;\n  }\n\n  // ============ EVENTS ============\n\n  event VRFRequested(uint256 indexed requestId, address indexed requester, uint32 indexed dstEid, uint256 nonce);\n\n  event VRFFulfilled(uint256 indexed requestId, uint256[] randomWords, address indexed requester);\n\n  event CrossChainVRFRequested(\n    uint32 indexed dstEid,\n    address indexed requester,\n    uint256 indexed nonce,\n    uint256 requestId\n  );\n\n  event CrossChainVRFFulfilled(\n    uint32 indexed srcEid,\n    address indexed requester,\n    uint256 indexed nonce,\n    uint256[] randomWords\n  );\n\n  event VRFConfigUpdated(\n    uint64 subscriptionId,\n    bytes32 keyHash,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bool enabled\n  );\n\n  event AuthorizedCallerUpdated(address indexed caller, bool indexed authorized);\n\n  // ============ VRF FUNCTIONS (Professional API) ============\n\n  function quoteFee() external view returns (MessagingFee memory fee);\n\n  function quoteFeeWithGas(uint32 gasLimit) external view returns (MessagingFee memory fee);\n\n  function requestRandomWords(uint32 dstEid) external returns (MessagingReceipt memory receipt, uint64 requestId);\n\n  // ============ ADMIN FUNCTIONS ============\n\n  function updateVRFConfig(\n    uint64 subscriptionId,\n    bytes32 keyHash,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bool enabled\n  ) external;\n\n  function setAuthorizedCaller(address caller, bool authorized) external;\n\n  function withdrawLink(uint256 amount) external;\n\n  function withdrawNative(uint256 amount) external;\n\n  // ============ VIEW FUNCTIONS ============\n\n  function getVRFConfig() external view returns (VRFConfig memory);\n\n  function isAuthorizedCaller(address caller) external view returns (bool);\n\n  function getCrossChainRequest(uint256 nonce) external view returns (CrossChainVRFRequest memory);\n\n  function getRequestStatus(uint256 requestId) external view returns (bool fulfilled, uint256[] memory randomWords);\n\n  // Legacy quote signature removed in favor of quoteFee/quoteFeeWithGas\n\n  // ============ LAYERZERO INTEGRATION ============\n\n  function lzReceive(uint32 srcEid, bytes32 sender, uint64 nonce, bytes calldata payload) external;\n}"
    },
    "contracts/interfaces/vrf/IOmniDragonVRFConsumerV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IOmniDragonVRFConsumerV2_5\n * @dev Interface for the OmniDragon VRF Consumer V2.5\n */\ninterface IOmniDragonVRFConsumerV2_5 {\n  // ============ STRUCTS ============\n\n  struct VRFRequest {\n    address requester;\n    bool fulfilled;\n    uint256[] randomWords;\n    uint256 timestamp;\n  }\n\n  struct LocalVRFConfig {\n    uint64 subscriptionId;\n    bytes32 keyHash;\n    uint32 callbackGasLimit;\n    uint16 requestConfirmations;\n    uint32 numWords;\n    bool enabled;\n  }\n\n  // ============ EVENTS ============\n\n  event VRFRequested(uint256 indexed requestId, address indexed requester);\n  event VRFFulfilled(uint256 indexed requestId, uint256[] randomWords);\n  event CrossChainVRFRequested(uint256 indexed requestId, uint32 indexed dstEid, address indexed requester);\n  event AuthorizedCallerUpdated(address indexed caller, bool authorized);\n  event VRFConfigUpdated(bytes32 keyHash, uint32 callbackGasLimit, uint16 requestConfirmations);\n\n  event LocalVRFRequested(uint256 indexed requestId, address indexed requester, uint256 timestamp);\n\n  event LocalVRFFulfilled(uint256 indexed requestId, uint256[] randomWords, address indexed requester);\n\n  event LocalCallerAuthorized(address indexed caller, bool indexed authorized);\n\n  event LocalVRFConfigUpdated(\n    uint64 subscriptionId,\n    bytes32 keyHash,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bool enabled\n  );\n\n  // ============ VRF FUNCTIONS ============\n\n  function requestRandomWords() external returns (uint256 requestId);\n\n  function requestRandomWordsLocal() external returns (uint256 requestId);\n\n  function requestCrossChainVRF(uint32 dstEid, bytes calldata options) external payable returns (uint256 requestId);\n\n  // ============ ADMIN FUNCTIONS ============\n\n  function setLotteryManager(address _lotteryManager) external;\n\n  function setAuthorizedCaller(address caller, bool authorized) external;\n\n  function updateVRFConfig(\n    bytes32 _keyHash,\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords\n  ) external;\n\n  function setVRFEnabled(bool _enabled) external;\n\n  function setLocalCallerAuthorization(address caller, bool authorized) external;\n\n  function updateLocalVRFConfig(\n    uint64 subscriptionId,\n    bytes32 keyHash,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bool enabled\n  ) external;\n\n  function withdrawLink(uint256 amount) external;\n\n  function withdrawNative(uint256 amount) external;\n\n  // ============ VIEW FUNCTIONS ============\n\n  function getVRFRequest(\n    uint256 requestId\n  ) external view returns (address requester, bool fulfilled, uint256[] memory randomWords, uint256 timestamp);\n\n  function getVRFConfig()\n    external\n    view\n    returns (\n      uint256 _subscriptionId,\n      bytes32 _keyHash,\n      uint32 _callbackGasLimit,\n      uint16 _requestConfirmations,\n      uint32 _numWords\n    );\n\n  function isAuthorizedCaller(address caller) external view returns (bool);\n\n  function getStats() external view returns (uint256 _totalRequests, uint256 _totalFulfillments, bool _vrfEnabled);\n\n  function getLocalVRFConfig() external view returns (LocalVRFConfig memory);\n\n  function isLocalCallerAuthorized(address caller) external view returns (bool);\n\n  function getLocalRequest(uint256 requestId) external view returns (VRFRequest memory);\n\n  function getLocalRequestStatus(\n    uint256 requestId\n  ) external view returns (bool fulfilled, uint256[] memory randomWords);\n\n  // ============ CALLBACK INTERFACE ============\n\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external;\n}"
    },
    "contracts/interfaces/vrf/IRandomWordsCallbackV2_5.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IRandomWordsCallbackV2_5\n * @dev Interface for receiving random words from Chainlink VRF V2.5\n */\ninterface IRandomWordsCallbackV2_5 {\n  /**\n   * @notice Receive random words from Chainlink VRF\n   * @param randomWords Array of random words\n   * @param sequence Sequence number for the request\n   */\n  function receiveRandomWords(uint256[] memory randomWords, uint256 sequence) external;\n}"
    },
    "contracts/libraries/core/DragonDateTimeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Time management utilities for veDRAGON lockups,\n * jackpot scheduling, and special event bonuses\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonic_reddragon_bot\n */\n\npragma solidity ^0.8.20;\n\n/**\n * @title DragonDateTimeLib\n * @dev Date and time utilities for Dragon ecosystem\n */\nlibrary DragonDateTimeLib {\n  // Constants for time calculations\n  uint256 public constant SECONDS_PER_MINUTE = 60;\n  uint256 public constant SECONDS_PER_HOUR = 60 * 60;\n  uint256 public constant SECONDS_PER_DAY = 86400;\n  uint256 public constant SECONDS_PER_WEEK = 604800;\n  uint256 public constant SECONDS_PER_YEAR = 31536000;\n\n  // Special events time constants\n  uint256 public constant TUESDAY = 2; // 1-indexed weekday (Monday = 1)\n  uint256 public constant FRIDAY = 5; // 1-indexed weekday (Monday = 1)\n\n  // Special event timestamps (example dates)\n  uint256 public constant DRAGON_YEAR_START = 1704067200; // Jan 1, 2024\n  uint256 public constant LUNAR_NEW_YEAR = 1707696000; // Feb 12, 2024\n  uint256 public constant DRAGON_FESTIVAL = 1718150400; // June 12, 2024\n\n  /**\n   * @dev Convert timestamp to day\n   * @param timestamp Unix timestamp\n   * @return day Days since epoch (Jan 1, 1970)\n   */\n  function timestampToDay(uint256 timestamp) internal pure returns (uint256 day) {\n    return timestamp / SECONDS_PER_DAY;\n  }\n\n  /**\n   * @dev Determine the day of the week from a timestamp\n   * @param timestamp Unix timestamp\n   * @return weekday The day of the week (1-indexed: Monday = 1, Sunday = 7)\n   */\n  function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 weekday) {\n    // January 1, 1970 was a Thursday (4)\n    uint256 daysSinceEpoch = timestampToDay(timestamp);\n    // +3 adjustment ensures Monday is 1\n    return ((daysSinceEpoch + 3) % 7) + 1;\n  }\n\n  /**\n   * @dev Checks if a timestamp falls on a specific day of the week\n   * @param timestamp Unix timestamp\n   * @param targetWeekday Target weekday (1-7, where 1 = Monday)\n   * @return result True if the timestamp is on the target weekday\n   * @return startOfDay Timestamp at 00:00:00 UTC of the day\n   */\n  function isDayOfWeek(\n    uint256 timestamp,\n    uint256 targetWeekday\n  ) internal pure returns (bool result, uint256 startOfDay) {\n    uint256 day = timestampToDay(timestamp);\n    startOfDay = day * SECONDS_PER_DAY;\n    result = getDayOfWeek(timestamp) == targetWeekday;\n  }\n\n  /**\n   * @dev Checks if a timestamp falls on a Tuesday\n   * @param timestamp Unix timestamp\n   * @return result True if the timestamp is on a Tuesday\n   * @return startOfDay Timestamp at 00:00:00 UTC of the day\n   */\n  function isTuesday(uint256 timestamp) internal pure returns (bool result, uint256 startOfDay) {\n    return isDayOfWeek(timestamp, TUESDAY);\n  }\n\n  /**\n   * @dev Checks if a timestamp falls on a Friday\n   * @param timestamp Unix timestamp\n   * @return result True if the timestamp is on a Friday\n   * @return startOfDay Timestamp at 00:00:00 UTC of the day\n   */\n  function isFriday(uint256 timestamp) internal pure returns (bool result, uint256 startOfDay) {\n    return isDayOfWeek(timestamp, FRIDAY);\n  }\n\n  /**\n   * @dev Get month number from a timestamp\n   * @param timestamp Unix timestamp\n   * @return month Month number (1-12)\n   */\n  function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n    uint256 epochDay = timestamp / SECONDS_PER_DAY;\n\n    // Howard Hinnant's algorithm for computing month from days\n    assembly {\n      epochDay := add(epochDay, 719468)\n      let doe := mod(epochDay, 146097)\n      let yoe := div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n      let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n      let mp := div(add(mul(5, doy), 2), 153)\n      month := sub(add(mp, 3), mul(gt(mp, 9), 12))\n    }\n  }\n\n  /**\n   * @dev Get day of month from a timestamp\n   * @param timestamp Unix timestamp\n   * @return day Day of month (1-31)\n   */\n  function getDayOfMonth(uint256 timestamp) internal pure returns (uint256 day) {\n    uint256 epochDay = timestamp / SECONDS_PER_DAY;\n\n    // Compute the day of month using modified Zeller's algorithm\n    assembly {\n      epochDay := add(epochDay, 719468)\n      let doe := mod(epochDay, 146097)\n      let yoe := div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n      let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n      let mp := div(add(mul(5, doy), 2), 153)\n      day := add(sub(doy, div(sub(add(mul(153, mp), 2), 5), 153)), 1)\n    }\n  }\n\n  /**\n   * @dev Check if a timestamp is in the first week of the month\n   * @param timestamp Unix timestamp\n   * @return result True if the day is in the first 7 days of the month\n   */\n  function isFirstWeekOfMonth(uint256 timestamp) internal pure returns (bool result) {\n    uint256 dayOfMonth = getDayOfMonth(timestamp);\n    return dayOfMonth <= 7;\n  }\n\n  /**\n   * @dev Check if a timestamp is the first occurrence of a specific weekday in the month\n   * @param timestamp Unix timestamp\n   * @param targetWeekday Target weekday (1-7, where 1 = Monday)\n   * @return result True if the timestamp is the first occurrence of that weekday in the month\n   */\n  function isFirstWeekdayOfMonth(uint256 timestamp, uint256 targetWeekday) internal pure returns (bool result) {\n    // Must be the target weekday\n    (bool isTargetDay, ) = isDayOfWeek(timestamp, targetWeekday);\n    if (!isTargetDay) return false;\n\n    // Get the day of month (1-31)\n    uint256 dayOfMonth = getDayOfMonth(timestamp);\n\n    // If it's days 1-7, we need to check if this is the first occurrence\n    if (dayOfMonth <= 7) {\n      // Check if there are any earlier days in the month with the same weekday\n      // Start from day 1 and check each day until we reach our current day\n      for (uint256 d = 1; d < dayOfMonth; d++) {\n        uint256 earlierTimestamp = timestamp - ((dayOfMonth - d) * SECONDS_PER_DAY);\n        if (getDayOfWeek(earlierTimestamp) == targetWeekday) {\n          // Found an earlier occurrence of this weekday\n          return false;\n        }\n      }\n      // No earlier occurrences found\n      return true;\n    }\n\n    // If we're beyond day 7, it can't be the first occurrence\n    return false;\n  }\n\n  /**\n   * @dev Check if a timestamp is the first Tuesday of the month\n   * @param timestamp Unix timestamp\n   * @return result True if the timestamp is the first Tuesday of the month\n   */\n  function isFirstTuesdayOfMonth(uint256 timestamp) internal pure returns (bool result) {\n    return isFirstWeekdayOfMonth(timestamp, TUESDAY);\n  }\n\n  /**\n   * @dev Check if a timestamp is the first Friday of the month\n   * @param timestamp Unix timestamp\n   * @return result True if the timestamp is the first Friday of the month\n   */\n  function isFirstFridayOfMonth(uint256 timestamp) internal pure returns (bool result) {\n    return isFirstWeekdayOfMonth(timestamp, FRIDAY);\n  }\n\n  /**\n   * @dev Calculate the timestamp of the next occurrence of a specific weekday\n   * @param timestamp Starting timestamp\n   * @param targetWeekday Target weekday (1-7, where 1 = Monday)\n   * @return nextOccurrence Timestamp of the next occurrence of the target weekday\n   */\n  function getNextWeekday(uint256 timestamp, uint256 targetWeekday) internal pure returns (uint256 nextOccurrence) {\n    uint256 currentWeekday = getDayOfWeek(timestamp);\n    uint256 daysToAdd;\n\n    if (currentWeekday < targetWeekday) {\n      // Target weekday is later in the current week\n      daysToAdd = targetWeekday - currentWeekday;\n    } else {\n      // Target weekday is in the next week\n      daysToAdd = 7 - (currentWeekday - targetWeekday);\n    }\n\n    // Align to the start of the day and add the required days\n    uint256 currentDay = timestampToDay(timestamp);\n    return (currentDay + daysToAdd) * SECONDS_PER_DAY;\n  }\n\n  /**\n   * @dev Calculate the timestamp of the next Tuesday\n   * @param timestamp Starting timestamp\n   * @return nextTuesday Timestamp of the next Tuesday at 00:00:00 UTC\n   */\n  function getNextTuesday(uint256 timestamp) internal pure returns (uint256 nextTuesday) {\n    return getNextWeekday(timestamp, TUESDAY);\n  }\n\n  /**\n   * @dev Calculate how many days until the first Tuesday of the next month\n   * @param timestamp Current timestamp\n   * @return daysUntil Number of days until the event\n   * @return eventTimestamp Timestamp of the event\n   */\n  function daysUntilFirstTuesdayOfNextMonth(\n    uint256 timestamp\n  ) internal pure returns (uint256 daysUntil, uint256 eventTimestamp) {\n    // Get the current month\n    uint256 currentMonth = getMonth(timestamp);\n    uint256 dayOfMonth = getDayOfMonth(timestamp);\n\n    // Calculate the first day of next month (approximate)\n    uint256 daysInMonth;\n    if (currentMonth == 2) {\n      // February special case\n      daysInMonth = 28; // Simplified, not handling leap years\n    } else if (currentMonth == 4 || currentMonth == 6 || currentMonth == 9 || currentMonth == 11) {\n      // 30-day months\n      daysInMonth = 30;\n    } else {\n      // 31-day months\n      daysInMonth = 31;\n    }\n\n    // Calculate days remaining in this month\n    uint256 daysRemainingInMonth = daysInMonth - dayOfMonth + 1;\n\n    // Calculate the first day of next month\n    uint256 firstDayOfNextMonth = timestampToDay(timestamp) + daysRemainingInMonth;\n    uint256 firstDayOfNextMonthTs = firstDayOfNextMonth * SECONDS_PER_DAY;\n\n    // Find the weekday of the first day of next month\n    uint256 firstDayWeekday = getDayOfWeek(firstDayOfNextMonthTs);\n\n    // Calculate the first Tuesday\n    uint256 daysToFirstTuesday;\n    if (firstDayWeekday <= TUESDAY) {\n      daysToFirstTuesday = TUESDAY - firstDayWeekday;\n    } else {\n      daysToFirstTuesday = 7 - (firstDayWeekday - TUESDAY);\n    }\n\n    eventTimestamp = firstDayOfNextMonthTs + (daysToFirstTuesday * SECONDS_PER_DAY);\n    daysUntil = (eventTimestamp - timestamp) / SECONDS_PER_DAY;\n\n    return (daysUntil, eventTimestamp);\n  }\n\n  /**\n   * @dev Calculate aligned lock end time (rounds to nearest week)\n   * @param startTime Start timestamp\n   * @param lockDuration Duration in seconds\n   * @return Aligned end timestamp\n   */\n  function calculateLockEndAligned(uint256 startTime, uint256 lockDuration) internal pure returns (uint256) {\n    uint256 endTime = startTime + lockDuration;\n\n    // Align to the nearest Thursday (like veCRV)\n    uint256 weekStart = (endTime / SECONDS_PER_WEEK) * SECONDS_PER_WEEK;\n    uint256 thursday = weekStart + (4 * SECONDS_PER_DAY); // Thursday is day 4\n\n    // If we're past Thursday, move to next Thursday\n    if (endTime > thursday) {\n      thursday += SECONDS_PER_WEEK;\n    }\n\n    return thursday;\n  }\n\n  /**\n   * @dev Check for special events that provide bonus multipliers\n   * @param timestamp Current timestamp\n   * @return isSpecialEvent Whether a special event is active\n   * @return eventMultiplier Multiplier for the event (in basis points, 10000 = 1x)\n   */\n  function checkForSpecialEvent(\n    uint256 timestamp\n  ) internal pure returns (bool isSpecialEvent, uint256 eventMultiplier) {\n    // Check for Dragon Year (Year of the Dragon)\n    if (isInDragonYear(timestamp)) {\n      return (true, 12000); // 1.2x multiplier during Dragon Year\n    }\n\n    // Check for Lunar New Year period (2 weeks)\n    if (timestamp >= LUNAR_NEW_YEAR && timestamp <= LUNAR_NEW_YEAR + (2 * SECONDS_PER_WEEK)) {\n      return (true, 15000); // 1.5x multiplier during Lunar New Year\n    }\n\n    // Check for Dragon Festival (1 week)\n    if (timestamp >= DRAGON_FESTIVAL && timestamp <= DRAGON_FESTIVAL + SECONDS_PER_WEEK) {\n      return (true, 13000); // 1.3x multiplier during Dragon Festival\n    }\n\n    // Check for weekend bonus (Saturday-Sunday)\n    uint256 dayOfWeek = ((timestamp / SECONDS_PER_DAY) + 4) % 7; // 0=Thursday, 6=Wednesday\n    if (dayOfWeek == 2 || dayOfWeek == 3) {\n      // Saturday or Sunday\n      return (true, 11000); // 1.1x multiplier on weekends\n    }\n\n    return (false, 10000); // No special event, 1x multiplier\n  }\n\n  /**\n   * @dev Check if timestamp is in a Dragon Year\n   * @param timestamp Timestamp to check\n   * @return Whether it's a Dragon Year\n   */\n  function isInDragonYear(uint256 timestamp) internal pure returns (bool) {\n    // Dragon years: 2024, 2036, 2048, etc. (every 12 years)\n    uint256 year = getYear(timestamp);\n    return (year - 2024) % 12 == 0 && year >= 2024;\n  }\n\n  /**\n   * @dev Get year from timestamp\n   * @param timestamp Unix timestamp\n   * @return year Year (e.g., 2024)\n   */\n  function getYear(uint256 timestamp) internal pure returns (uint256) {\n    // Simplified year calculation (approximate)\n    return 1970 + (timestamp / SECONDS_PER_YEAR);\n  }\n\n  /**\n   * @dev Check if timestamp is on weekend\n   * @param timestamp Unix timestamp\n   * @return Whether it's weekend\n   */\n  function isWeekend(uint256 timestamp) internal pure returns (bool) {\n    uint256 dayOfWeek = getDayOfWeek(timestamp);\n    return dayOfWeek == 0 || dayOfWeek == 6; // Sunday or Saturday\n  }\n\n  /**\n   * @dev Calculate next aligned timestamp for a given interval\n   * @param timestamp Current timestamp\n   * @param interval Interval in seconds\n   * @return Next aligned timestamp\n   */\n  function getNextAlignedTime(uint256 timestamp, uint256 interval) internal pure returns (uint256) {\n    return ((timestamp / interval) + 1) * interval;\n  }\n\n  /**\n   * @dev Calculate time until next special event\n   * @param timestamp Current timestamp\n   * @return timeUntilEvent Seconds until next special event\n   * @return eventType Type of next event (0=none, 1=weekend, 2=festival, 3=lunar_new_year)\n   */\n  function getTimeUntilNextEvent(uint256 timestamp) internal pure returns (uint256 timeUntilEvent, uint256 eventType) {\n    // Check for upcoming weekend\n    uint256 dayOfWeek = getDayOfWeek(timestamp);\n    if (dayOfWeek < 6) {\n      // Not Saturday yet\n      uint256 timeUntilSaturday = (6 - dayOfWeek) * SECONDS_PER_DAY;\n      timeUntilSaturday -= timestamp % SECONDS_PER_DAY; // Adjust for time of day\n      return (timeUntilSaturday, 1);\n    }\n\n    // Check for upcoming festivals (simplified)\n    if (timestamp < DRAGON_FESTIVAL) {\n      return (DRAGON_FESTIVAL - timestamp, 2);\n    }\n\n    // No specific event found\n    return (0, 0);\n  }\n}\n"
    },
    "contracts/libraries/DragonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title DragonErrors\n * @author 0xakita.eth\n * @notice Shared custom errors for the Dragon ecosystem\n * @dev Centralizes common error definitions to avoid duplication\n * \n * Social Links:\n * - Twitter: https://x.com/sonicreddragon\n * - Telegram: https://t.me/sonicreddragon\n */\nlibrary DragonErrors {\n    // ========== GENERAL ERRORS ==========\n    \n    /// @dev Thrown when a zero address is passed where it's not allowed\n    error ZeroAddress();\n    \n    /// @dev Thrown when an amount is zero where it's not allowed  \n    error ZeroAmount();\n    \n    /// @dev Thrown when a transfer operation fails\n    error TransferFailed();\n    \n    /// @dev Thrown when there's insufficient balance for an operation\n    error InsufficientBalance();\n    \n    /// @dev Thrown when an unauthorized address attempts an action\n    error UnauthorizedCaller();\n    \n    /// @dev Thrown when a contract is paused\n    error ContractPaused();\n    \n    // ========== VALIDATION ERRORS ==========\n    \n    /// @dev Thrown when invalid fee structure is provided\n    error InvalidFeeStructure();\n    \n    /// @dev Thrown when invalid fee configuration is set\n    error InvalidFeeConfiguration();\n    \n    /// @dev Thrown when transfer amount exceeds maximum allowed\n    error MaxTransferExceeded();\n    \n    /// @dev Thrown when amount is below minimum threshold\n    error AmountBelowMinimum();\n    \n    // ========== STATE ERRORS ==========\n    \n    /// @dev Thrown when trading is disabled\n    error TradingDisabled();\n    \n    /// @dev Thrown when emergency mode is disabled but emergency action is attempted\n    error EmergencyModeDisabled();\n    \n    /// @dev Thrown when operation is attempted with no available jackpot\n    error NoJackpotToPay();\n    \n    /// @dev Thrown when wrapped token is not set but required\n    error WrappedTokenNotSet();\n}"
    },
    "contracts/libraries/LayerZeroOptionsHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title LayerZeroOptionsHelper\n * @dev Library for creating proper LayerZero V2 extraOptions to avoid LZ_ULN_InvalidWorkerOptions\n * @notice This library implements the fix for the 0x6592671c error by providing Legacy Type 1 options\n *\n * KEY LEARNING: Never use empty options (\"0x\") - always use Legacy Type 1 format!\n *\n * The breakthrough discovery was that LayerZero V2's quoteSend() fails with error 0x6592671c\n * (LZ_ULN_InvalidWorkerOptions) when using empty extraOptions (\"0x\").\n *\n * SOLUTION: Use Legacy Type 1 options format:\n * - Type: 0x0001 (2 bytes)\n * - Gas: 32 bytes of gas amount\n * - Total: 34 bytes\n *\n * Example: 0x00010000000000000000000000000000000000000000000000000000000000030d40\n * (Type 1 + 200,000 gas)\n */\nlibrary LayerZeroOptionsHelper {\n  // Constants\n  uint16 internal constant LEGACY_TYPE_1 = 1;\n  uint32 internal constant DEFAULT_GAS_LIMIT = 200000;\n  uint32 internal constant MIN_GAS_LIMIT = 100000;\n  uint32 internal constant MAX_GAS_LIMIT = 2000000;\n\n  /**\n   * @dev Creates Legacy Type 1 options for LayerZero V2\n   * @param gasLimit The gas limit for the destination chain execution\n   * @return options The properly formatted Legacy Type 1 options\n   *\n   * Format: [type:2bytes][gasLimit:32bytes] = 34 bytes total\n   * - type: 0x0001 (Legacy Type 1)\n   * - gasLimit: 32-byte big-endian encoded gas limit\n   */\n  function createLegacyType1Options(uint32 gasLimit) internal pure returns (bytes memory) {\n    require(gasLimit >= MIN_GAS_LIMIT && gasLimit <= MAX_GAS_LIMIT, \"Invalid gas limit\");\n\n    // Encode as: [type:2bytes][gasLimit:32bytes]\n    return abi.encodePacked(LEGACY_TYPE_1, uint256(gasLimit));\n  }\n\n  /**\n   * @dev Creates Legacy Type 1 options with default gas limit\n   * @return options The properly formatted Legacy Type 1 options with 200,000 gas\n   */\n  function createDefaultLegacyType1Options() internal pure returns (bytes memory) {\n    return createLegacyType1Options(DEFAULT_GAS_LIMIT);\n  }\n\n  /**\n   * @dev Validates that options are not empty (which causes LZ_ULN_InvalidWorkerOptions)\n   * @param options The options to validate\n   * @return isValid True if options are valid (not empty)\n   */\n  function validateOptions(bytes memory options) internal pure returns (bool isValid) {\n    return options.length > 0;\n  }\n\n  /**\n   * @dev Checks if options are Legacy Type 1 format\n   * @param options The options to check\n   * @return True if options are Legacy Type 1 format\n   */\n  function isLegacyType1(bytes memory options) internal pure returns (bool) {\n    if (options.length != 34) return false;\n\n    uint16 optionType;\n    assembly {\n      optionType := mload(add(options, 2))\n    }\n    return optionType == LEGACY_TYPE_1;\n  }\n\n  /**\n   * @dev Extracts gas limit from Legacy Type 1 options\n   * @param options The Legacy Type 1 options\n   * @return gasLimit The gas limit encoded in the options\n   */\n  function extractGasLimit(bytes memory options) internal pure returns (uint32 gasLimit) {\n    require(isLegacyType1(options), \"Not Legacy Type 1 options\");\n\n    uint256 fullGasLimit;\n    assembly {\n      fullGasLimit := mload(add(options, 34)) // Skip 2 bytes type + read 32 bytes\n    }\n\n    require(fullGasLimit <= type(uint32).max, \"Gas limit too large\");\n    return uint32(fullGasLimit);\n  }\n\n  /**\n   * @dev Emergency function to convert empty options to Legacy Type 1\n   * @param options The options to fix (if empty)\n   * @return fixedOptions The options, converted to Legacy Type 1 if they were empty\n   */\n  function ensureValidOptions(bytes memory options) internal pure returns (bytes memory fixedOptions) {\n    if (options.length == 0) {\n      return createDefaultLegacyType1Options();\n    }\n    return options;\n  }\n\n  /**\n   * @dev Creates Legacy Type 1 options with custom gas for specific networks\n   * @param chainId The destination chain ID\n   * @return options The properly formatted Legacy Type 1 options with chain-specific gas\n   */\n  function createChainSpecificOptions(uint256 chainId) internal pure returns (bytes memory) {\n    uint32 gasLimit;\n\n    if (chainId == 1) {\n      // Ethereum\n      gasLimit = 300000;\n    } else if (chainId == 42161) {\n      // Arbitrum\n      gasLimit = 250000;\n    } else if (chainId == 43114) {\n      // Avalanche\n      gasLimit = 250000;\n    } else if (chainId == 146) {\n      // Sonic\n      gasLimit = 200000;\n    } else {\n      gasLimit = DEFAULT_GAS_LIMIT; // Default for other chains\n    }\n\n    return createLegacyType1Options(gasLimit);\n  }\n}"
    },
    "contracts/libraries/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n   * with further edits by Uniswap Labs also under MIT license.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2^256 + prod0.\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division.\n      if (prod1 == 0) {\n        return prod0 / denominator;\n      }\n\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0].\n      uint256 remainder;\n      assembly {\n        // Compute remainder using mulmod.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n      // See https://cs.stackexchange.com/q/138556/92363.\n\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\n      uint256 twos = denominator & (~denominator + 1);\n      assembly {\n        // Divide denominator by twos.\n        denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by twos.\n        prod0 := div(prod0, twos)\n\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n\n      // Shift in bits from prod1 into prod0.\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n      // four bits. That is, denominator * inv = 1 mod 2^4.\n      uint256 inverse = (3 * denominator) ^ 2;\n\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n      // in modular arithmetic, doubling the correct bits in each step.\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inverse;\n      return result;\n    }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n   */\n  function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n   *\n   * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n   */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n    unchecked {\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      result = (result + a / result) >> 1;\n      return min(result, a / result);\n    }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n   */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = sqrt(a);\n      return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 128;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 64;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 32;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 16;\n      }\n      if (value >> 8 > 0) {\n        value >>= 8;\n        result += 8;\n      }\n      if (value >> 4 > 0) {\n        value >>= 4;\n        result += 4;\n      }\n      if (value >> 2 > 0) {\n        value >>= 2;\n        result += 2;\n      }\n      if (value >> 1 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log2(value);\n      return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >= 10 ** 64) {\n        value /= 10 ** 64;\n        result += 64;\n      }\n      if (value >= 10 ** 32) {\n        value /= 10 ** 32;\n        result += 32;\n      }\n      if (value >= 10 ** 16) {\n        value /= 10 ** 16;\n        result += 16;\n      }\n      if (value >= 10 ** 8) {\n        value /= 10 ** 8;\n        result += 8;\n      }\n      if (value >= 10 ** 4) {\n        value /= 10 ** 4;\n        result += 4;\n      }\n      if (value >= 10 ** 2) {\n        value /= 10 ** 2;\n        result += 2;\n      }\n      if (value >= 10 ** 1) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log10(value);\n      return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n    }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n   * Returns 0 if given 0.\n   *\n   * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n   */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n    unchecked {\n      if (value >> 128 > 0) {\n        value >>= 128;\n        result += 16;\n      }\n      if (value >> 64 > 0) {\n        value >>= 64;\n        result += 8;\n      }\n      if (value >> 32 > 0) {\n        value >>= 32;\n        result += 4;\n      }\n      if (value >> 16 > 0) {\n        value >>= 16;\n        result += 2;\n      }\n      if (value >> 8 > 0) {\n        result += 1;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n   * Returns 0 if given 0.\n   */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n    unchecked {\n      uint256 result = log256(value);\n      return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n    }\n  }\n}\n"
    },
    "contracts/libraries/math/veDRAGONMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title veDRAGONMath\n * @notice Unified mathematical library for veDRAGON voting power calculations\n * @dev Combines simple linear calculations with advanced cube root scaling and ecosystem math\n *\n * Handles complex time-based voting power decay and boost calculations\n * Implements non-linear scaling for optimal governance participation incentives\n * Provides lottery, jackpot, and fee allocation calculations\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary veDRAGONMath {\n  using Math for uint256;\n\n  // ========== CORE CONSTANTS ==========\n\n  // Time calculations\n  uint256 public constant WEEK = 7 * 86400; // 7 days in seconds\n  uint256 public constant MAX_LOCK_TIME = 4 * 365 * 86400; // 4 years in seconds\n  uint256 public constant MAX_LOCK_WEEKS = MAX_LOCK_TIME / WEEK; // ~208 weeks\n  uint256 public constant MIN_LOCK_TIME = 7 * 86400; // 1 week in seconds\n\n  // Legacy constants for backward compatibility\n  uint256 public constant MAX_LOCK_DURATION = MAX_LOCK_TIME;\n  uint256 public constant MIN_LOCK_DURATION = MIN_LOCK_TIME;\n\n  // Precision and scaling\n  uint256 public constant PRECISION = 1e18; // High precision for calculations\n  uint256 public constant BPS_MAX = 10000; // 100% in basis points\n  uint256 public constant PERCENTAGE_SCALE = 100;\n\n  // ========== BOOST PARAMETERS ==========\n\n  uint256 public constant BASE_BOOST_BPS = 10000; // 100% = 1.0x boost\n  uint256 public constant MAX_BOOST_BPS = 25000; // 250% = 2.5x max boost\n  uint256 public constant MIN_LP_FOR_MAX_BOOST = 1000 ether; // 1000 LP tokens for max boost\n\n  // ========== FEE DISTRIBUTION PARAMETERS ==========\n\n  // Base fee allocations (in basis points)\n  uint256 public constant BASE_JACKPOT_BPS = 690; // 69.0%\n  uint256 public constant BASE_LP_BPS = 241; // 24.1%\n  uint256 public constant BASE_BURN_BPS = 69; // 6.9%\n\n  // Minimum fee allocations (in basis points)\n  uint256 public constant MIN_JACKPOT_BPS = 400; // 40.0% minimum to jackpot\n  uint256 public constant MIN_LP_BPS = 150; // 15.0% minimum to LPs\n  uint256 public constant MIN_BURN_BPS = 30; // 3.0% minimum burn\n\n  // ========== JACKPOT PARAMETERS ==========\n\n  uint256 public constant BASE_JACKPOT_PAYOUT_BPS = 6900; // 69.0% base payout\n  uint256 public constant MIN_JACKPOT_PAYOUT_BPS = 5000; // 50.0% minimum payout\n\n  // ========== LOTTERY PARAMETERS ==========\n\n  // Note: Using scaled values since Solidity doesn't support decimals\n  // BASE_WIN_PROB_SCALED = 4 represents 0.4 basis points (0.004%)\n  // MAX_WIN_PROB_BPS = 400 represents 400 basis points (4%)\n  uint256 public constant BASE_WIN_PROB_SCALED = 4; // 0.004% base win probability at $10 (scaled by 10)\n  uint256 public constant MAX_WIN_PROB_BPS = 400; // 4% maximum win probability at $10,000\n  uint256 public constant MIN_AMOUNT_USD = 10 ether; // $10 minimum swap amount\n  uint256 public constant MAX_AMOUNT_USD = 10000 ether; // $10,000 for max probability\n\n  // ========== CORE VOTING POWER CALCULATIONS ==========\n\n  /**\n   * @notice Calculate voting power based on amount and lock duration (linear scaling)\n   * @dev Simple linear implementation for basic use cases\n   * @param amount Amount of tokens locked\n   * @param lockDuration Duration of lock in seconds\n   * @return Voting power with precision\n   */\n  function calculateVotingPower(uint256 amount, uint256 lockDuration) internal pure returns (uint256) {\n    if (lockDuration < MIN_LOCK_DURATION) {\n      return 0;\n    }\n\n    if (lockDuration > MAX_LOCK_DURATION) {\n      lockDuration = MAX_LOCK_DURATION;\n    }\n\n    // Linear scaling: 1 week = minimum, 4 years = 1x\n    uint256 multiplier = (lockDuration * PRECISION) / MAX_LOCK_DURATION;\n\n    return (amount * multiplier) / PRECISION;\n  }\n\n  /**\n   * @notice Calculate time-weighted voting power (decays over time)\n   * @dev Linear decay implementation\n   * @param amount Original locked amount\n   * @param lockEnd Lock end timestamp\n   * @param currentTime Current timestamp\n   * @return Current voting power\n   */\n  function calculateDecayedVotingPower(\n    uint256 amount,\n    uint256 lockEnd,\n    uint256 currentTime\n  ) internal pure returns (uint256) {\n    if (currentTime >= lockEnd) {\n      return 0;\n    }\n\n    uint256 remainingTime = lockEnd - currentTime;\n    return calculateVotingPower(amount, remainingTime);\n  }\n\n  /**\n   * @notice Calculate boost multiplier based on lock duration (linear)\n   * @dev Simple boost calculation for basic implementations\n   * @param lockDuration Duration of lock in seconds\n   * @return Boost multiplier with precision (1x to 4x)\n   */\n  function calculateBoostMultiplier(uint256 lockDuration) internal pure returns (uint256) {\n    if (lockDuration == 0) {\n      return PRECISION; // 1x\n    }\n\n    if (lockDuration > MAX_LOCK_DURATION) {\n      lockDuration = MAX_LOCK_DURATION;\n    }\n\n    // Boost from 1x to 4x based on lock duration\n    uint256 additionalBoost = (3 * PRECISION * lockDuration) / MAX_LOCK_DURATION;\n\n    return PRECISION + additionalBoost;\n  }\n\n  // ========== ADVANCED VOTING POWER CALCULATIONS ==========\n\n  /**\n   * @notice Calculate cube root (implementation specific to our precision needs)\n   * @dev Advanced mathematical function for non-linear scaling\n   * @param n The number to find the cube root of\n   * @return The cube root of n, with precision\n   */\n  function cubeRoot(uint256 n) internal pure returns (uint256) {\n    if (n == 0) return 0;\n\n    // Use improved initial guess for faster convergence\n    uint256 x;\n    if (n <= PRECISION) {\n      // For values <= 1, start with a value close to 1\n      x = (n + 2 * PRECISION) / 3;\n    } else {\n      // For values > 1, use a logarithmic approximation for initial guess\n      uint256 log2n = 0;\n      uint256 temp = n;\n      while (temp > PRECISION) {\n        temp = temp / 2;\n        log2n++;\n      }\n      x = 1 << (log2n / 3);\n\n      // Ensure x is not zero (fallback)\n      if (x == 0) x = n / 3;\n    }\n\n    // Apply Newton's method with improved convergence check\n    for (uint256 i = 0; i < 8; i++) {\n      uint256 x2 = (x * x) / PRECISION;\n      if (x2 == 0) break;\n\n      uint256 xCubed = (x * x2) / PRECISION;\n\n      // If we're already very close, break early\n      if (xCubed > (n * 995) / 1000 && xCubed < (n * 1005) / 1000) {\n        break;\n      }\n\n      // y = (2*x + n/x^2)/3\n      uint256 term1 = 2 * x;\n      uint256 term2;\n\n      // Handle potential underflow in division\n      if (x2 > 0) {\n        term2 = (n * PRECISION) / x2;\n        uint256 y = (term1 + term2 / x) / 3;\n\n        // Check for convergence with tighter tolerance\n        if ((y >= x && y - x < PRECISION / 10000) || (y < x && x - y < PRECISION / 10000)) {\n          x = y;\n          break;\n        }\n\n        x = y;\n      } else {\n        break;\n      }\n    }\n\n    return x;\n  }\n\n  /**\n   * @notice Calculate voting power using cube root normalization for equitable distribution\n   * @dev Advanced implementation for fairer voting power distribution\n   * @param amount The amount of tokens\n   * @return votingPower The calculated voting power\n   */\n  function calculateAdvancedVotingPower(uint256 amount) internal pure returns (uint256 votingPower) {\n    if (amount == 0) return 0;\n\n    // Use cube root for more equitable voting power distribution\n    return cubeRoot(amount * PRECISION) * 100;\n  }\n\n  /**\n   * @notice Calculate voting power based on locked amount and lock duration (cube root scaling)\n   * @dev Advanced implementation with non-linear boost\n   * @param lockedAmount Amount of tokens locked\n   * @param lockDuration Duration of the lock in seconds\n   * @return votingPower The calculated voting power\n   */\n  function calculateVotingPowerWithLock(\n    uint256 lockedAmount,\n    uint256 lockDuration\n  ) internal pure returns (uint256 votingPower) {\n    if (lockedAmount == 0) return 0;\n\n    // Ensure lock duration is capped at MAX_LOCK_TIME\n    lockDuration = Math.min(lockDuration, MAX_LOCK_TIME);\n\n    // Calculate time ratio (0-1 scaled by PRECISION)\n    uint256 timeRatio = (lockDuration * PRECISION) / MAX_LOCK_TIME;\n\n    // Apply cube root scaling for non-linear boost\n    uint256 nonLinearBoost = cubeRoot(timeRatio);\n\n    // Scale by MAX_BOOST_BPS and apply to locked amount\n    uint256 boostMultiplier = (nonLinearBoost * (MAX_BOOST_BPS - BASE_BOOST_BPS)) / PRECISION;\n    uint256 effectiveBoost = BASE_BOOST_BPS + boostMultiplier;\n\n    // Calculate boosted amount\n    return (lockedAmount * effectiveBoost) / BPS_MAX;\n  }\n\n  /**\n   * @notice Calculate effective voting power at a specific timestamp\n   * @dev Time-decayed voting power calculation\n   * @param lockedAmount Amount of tokens locked\n   * @param lockEnd Timestamp when lock expires\n   * @param timestamp Current timestamp to calculate voting power at\n   * @return effectiveVotingPower The time-decayed voting power\n   */\n  function calculateEffectiveVotingPower(\n    uint256 lockedAmount,\n    uint256 lockEnd,\n    uint256 timestamp\n  ) public pure returns (uint256 effectiveVotingPower) {\n    // If lock has expired, voting power is 0\n    if (timestamp >= lockEnd) return 0;\n\n    // Calculate remaining lock duration\n    uint256 remainingLockTime = lockEnd - timestamp;\n\n    // Calculate effective voting power\n    return calculateVotingPowerWithLock(lockedAmount, remainingLockTime);\n  }\n\n  // ========== BOOST CALCULATIONS ==========\n\n  /**\n   * @notice Calculate boost multiplier based on user's voting power\n   * @dev Advanced boost calculation with configurable maximum\n   * @param votingPower User's voting power\n   * @param maxBoostBps Maximum boost in basis points (default 25000 = 2.5x)\n   * @return boostMultiplier The boost multiplier in basis points (10000 = 1.0x)\n   */\n  function calculateAdvancedBoostMultiplier(\n    uint256 votingPower,\n    uint256 maxBoostBps\n  ) internal pure returns (uint256 boostMultiplier) {\n    // If no voting power, return base boost (1.0x)\n    if (votingPower == 0) return BASE_BOOST_BPS;\n\n    // If max boost not specified, use the default\n    if (maxBoostBps == 0) maxBoostBps = MAX_BOOST_BPS;\n\n    // Effective boost increases linearly with voting power up to the maximum\n    uint256 effectiveAmount = Math.min(votingPower, MIN_LP_FOR_MAX_BOOST);\n\n    // Calculate boost: BASE_BOOST + (MAX_BOOST - BASE_BOOST) * (effectiveAmount / MIN_LP_FOR_MAX_BOOST)\n    uint256 additionalBoost = ((maxBoostBps - BASE_BOOST_BPS) * effectiveAmount) / MIN_LP_FOR_MAX_BOOST;\n\n    return BASE_BOOST_BPS + additionalBoost;\n  }\n\n  /**\n   * @notice Calculate normalized boost multiplier based on user's share\n   * @dev Uses cube root compression for fairer distribution\n   * @param userBalance User's token balance\n   * @param totalSupply Total token supply\n   * @param maxBoostBps Maximum boost in basis points (default 25000 = 2.5x)\n   * @return multiplier The calculated boost multiplier\n   */\n  function calculateNormalizedBoostMultiplier(\n    uint256 userBalance,\n    uint256 totalSupply,\n    uint256 maxBoostBps\n  ) internal pure returns (uint256 multiplier) {\n    if (userBalance == 0 || totalSupply == 0) {\n      return BASE_BOOST_BPS; // Default to base boost if no balance\n    }\n\n    // If max boost not specified, use the default\n    if (maxBoostBps == 0) maxBoostBps = MAX_BOOST_BPS;\n\n    // Calculate user's share using cube root for compression\n    uint256 userVotingPower = calculateAdvancedVotingPower(userBalance);\n    uint256 totalVotingPower = calculateAdvancedVotingPower(totalSupply);\n\n    // Calculate compressed share percentage with high precision\n    uint256 compressedSharePct = (userVotingPower * PRECISION) / totalVotingPower;\n\n    // Calculate boost within range from base to max\n    uint256 boostRange = maxBoostBps - BASE_BOOST_BPS;\n    uint256 additionalBoost = (boostRange * compressedSharePct) / PRECISION;\n\n    // Ensure we don't exceed maxBoost\n    uint256 calculatedBoost = BASE_BOOST_BPS + additionalBoost;\n    return calculatedBoost > maxBoostBps ? maxBoostBps : calculatedBoost;\n  }\n\n  // ========== LOTTERY CALCULATIONS ==========\n\n  /**\n   * @notice Calculate lottery win probability boost based on user's veDRAGON balance\n   * @dev Applies voting power boost to base win probability\n   * @param baseWinProbability Base win probability without boost (in basis points)\n   * @param votingPower User's voting power\n   * @return boostedProbability The boosted win probability in basis points\n   */\n  function calculateBoostedWinProbability(\n    uint256 /* swapAmount */,\n    uint256 baseWinProbability,\n    uint256 votingPower\n  ) internal pure returns (uint256 boostedProbability) {\n    // Get boost multiplier (10000 = 1.0x, 25000 = 2.5x)\n    uint256 boostMultiplier = calculateAdvancedBoostMultiplier(votingPower, MAX_BOOST_BPS);\n\n    // Apply boost to the base probability\n    boostedProbability = (baseWinProbability * boostMultiplier) / BPS_MAX;\n\n    // Cap at maximum probability (0.4%)\n    return Math.min(boostedProbability, MAX_WIN_PROB_BPS);\n  }\n\n  /**\n   * @notice Calculate win threshold for lottery based on swap amount and veDRAGON boost\n   * @dev Converts probability to threshold for random number comparison\n   * @param swapAmountUSD Swap amount in USD (scaled by 1e18)\n   * @param veDRAGONBalance veDRAGON balance of the user (if any)\n   * @return threshold Random number threshold for win (higher = more likely to win)\n   */\n  function calculateWinThreshold(\n    uint256 swapAmountUSD,\n    uint256 veDRAGONBalance\n  ) internal pure returns (uint256 threshold) {\n    // Calculate base win probability\n    uint256 winProbabilityBPS;\n\n    if (swapAmountUSD <= MIN_AMOUNT_USD) {\n      winProbabilityBPS = BASE_WIN_PROB_SCALED / 10; // Convert scaled value to basis points\n    } else {\n      uint256 baseBPS = BASE_WIN_PROB_SCALED / 10;\n      uint256 additionalProb = swapAmountUSD > MAX_AMOUNT_USD\n        ? (MAX_WIN_PROB_BPS - baseBPS)\n        : ((swapAmountUSD - MIN_AMOUNT_USD) * (MAX_WIN_PROB_BPS - baseBPS)) / (MAX_AMOUNT_USD - MIN_AMOUNT_USD);\n\n      winProbabilityBPS = baseBPS + additionalProb;\n    }\n\n    // Apply veDRAGON boost (up to 2.5x)\n    if (veDRAGONBalance > 0) {\n      // Calculate boost factor (1.0 to 2.5 based on balance)\n      uint256 boostFactor;\n\n      if (veDRAGONBalance >= MIN_LP_FOR_MAX_BOOST) {\n        boostFactor = 250; // 2.5x\n      } else {\n        // Linear increase between 1.0x and 2.5x\n        boostFactor = 100 + ((veDRAGONBalance * 150) / MIN_LP_FOR_MAX_BOOST);\n      }\n\n      // Apply boost\n      winProbabilityBPS = (winProbabilityBPS * boostFactor) / 100;\n\n      // Cap at max probability\n      winProbabilityBPS = Math.min(MAX_WIN_PROB_BPS, winProbabilityBPS);\n    }\n\n    // Convert probability to threshold\n    // For example, a 0.01% chance = 1/10000 = threshold of 10000/1 = 10000\n    // So if random number % 10000 == 0, the user wins (1 in 10000 chance)\n    if (winProbabilityBPS == 0) return 1; // Avoid division by zero\n\n    threshold = (BPS_MAX * BPS_MAX) / winProbabilityBPS;\n    return threshold;\n  }\n\n  // ========== JACKPOT CALCULATIONS ==========\n\n  /**\n   * @notice Calculate the jackpot payout percentage based on jackpot size\n   * @dev Dynamic payout calculation based on market conditions\n   * @param jackpotSize Current jackpot size (in wei)\n   * @param marketConditionFactor Market condition factor (0-100) that can adjust payout\n   * @return payoutBps Basis points for jackpot payout (e.g. 6900 = 69%)\n   */\n  function calculateJackpotPayoutPercentage(\n    uint256 jackpotSize,\n    uint256 marketConditionFactor\n  ) internal pure returns (uint256 payoutBps) {\n    // Start with base payout (69%)\n    uint256 basePayout = BASE_JACKPOT_PAYOUT_BPS;\n    uint256 reduction = 0;\n\n    // For large jackpots, reduce the percentage to create sustainability\n    if (jackpotSize > 10000 ether) {\n      // Calculate log10 approximation\n      uint256 magnitude = 0;\n      uint256 value = jackpotSize / 1 ether;\n\n      while (value >= 10) {\n        value /= 10;\n        magnitude++;\n      }\n\n      // Each order of magnitude reduces by 3%\n      reduction = Math.min(1900, magnitude * 300); // Cap at 19% reduction (50% floor)\n    }\n\n    // Apply market condition factor - can adjust +/- 5% based on conditions\n    if (marketConditionFactor > 50) {\n      // High market factor increases payout (better conditions)\n      uint256 marketBoost = Math.min(500, (marketConditionFactor - 50) * 10);\n\n      // Ensure we don't exceed the base payout\n      reduction = reduction > marketBoost ? reduction - marketBoost : 0;\n    } else if (marketConditionFactor < 50) {\n      // Low market factor decreases payout (worse conditions)\n      uint256 marketPenalty = Math.min(500, (50 - marketConditionFactor) * 10);\n      reduction += marketPenalty;\n    }\n\n    // Apply reduction with floor check\n    uint256 finalPayout = basePayout - reduction;\n    return finalPayout < MIN_JACKPOT_PAYOUT_BPS ? MIN_JACKPOT_PAYOUT_BPS : finalPayout;\n  }\n\n  // ========== FEE ALLOCATION CALCULATIONS ==========\n\n  /**\n   * @notice Calculate dynamic fee allocation based on market conditions\n   * @dev Optimized to avoid stack too deep errors\n   * @param lpTVL Total value locked in LP pools (in wei)\n   * @param jackpotTVL Current jackpot size (in wei)\n   * @param volume24h 24-hour trading volume (in wei)\n   * @param lastWinTimestamp Timestamp of the last jackpot win\n   * @param numStakers Number of active LP stakers\n   * @param marketVolatility Market volatility metric (0-100 scale)\n   * @return jackpotBps Basis points allocated to jackpot (e.g. 690 = 69.0%)\n   * @return lpBps Basis points allocated to LPs\n   * @return burnBps Basis points allocated to burning\n   */\n  function calculateFeeAllocation(\n    uint256 lpTVL,\n    uint256 jackpotTVL,\n    uint256 volume24h,\n    uint256 lastWinTimestamp,\n    uint256 numStakers,\n    uint256 marketVolatility\n  ) internal view returns (uint256 jackpotBps, uint256 lpBps, uint256 burnBps) {\n    // Calculate market-based adjustments\n    (int256 jackpotAdjustment, int256 lpAdjustment) = _calculateMarketAdjustments(\n      lpTVL,\n      jackpotTVL,\n      volume24h,\n      lastWinTimestamp,\n      numStakers,\n      marketVolatility\n    );\n\n    // Apply adjustments and finalize allocations\n    return _finalizeAllocations(jackpotAdjustment, lpAdjustment);\n  }\n\n  /**\n   * @dev Calculate all market-based adjustment factors\n   */\n  function _calculateMarketAdjustments(\n    uint256 lpTVL,\n    uint256 jackpotTVL,\n    uint256 volume24h,\n    uint256 lastWinTimestamp,\n    uint256 numStakers,\n    uint256 marketVolatility\n  ) private view returns (int256 jackpotAdjustment, int256 lpAdjustment) {\n    // Volume/LP ratio factor\n    if (volume24h > 0 && lpTVL > 0) {\n      uint256 volumeLPRatio = (volume24h * 1e18) / lpTVL;\n      if (volumeLPRatio > 2e17) {\n        // 0.2 with 18 decimals\n        uint256 scaledRatio = (volumeLPRatio - 2e17) / 1e16;\n        lpAdjustment += int256(Math.min(150, scaledRatio));\n      } else {\n        lpAdjustment -= 100;\n      }\n    }\n\n    // Jackpot size factor\n    if (jackpotTVL > 10000 ether) {\n      uint256 magnitude = _calculateMagnitude(jackpotTVL / 1 ether);\n      jackpotAdjustment -= int256(Math.min(200, magnitude * 10));\n    }\n\n    // Time factor\n    uint256 daysSinceWin = (block.timestamp - lastWinTimestamp) / 1 days;\n    if (daysSinceWin > 7) {\n      jackpotAdjustment += int256(Math.min(150, (daysSinceWin - 7) * 10));\n    }\n\n    // Staker factor\n    if (numStakers > 100) {\n      uint256 magnitude = _calculateMagnitude(numStakers);\n      lpAdjustment += int256(Math.min(100, magnitude * 20));\n    }\n\n    // Volatility factor\n    if (marketVolatility > 50) {\n      lpAdjustment += int256(Math.min(100, (marketVolatility - 50) * 2));\n    }\n  }\n\n  /**\n   * @dev Calculate magnitude (log10 approximation)\n   */\n  function _calculateMagnitude(uint256 value) private pure returns (uint256 magnitude) {\n    while (value >= 10) {\n      value /= 10;\n      magnitude++;\n    }\n  }\n\n  /**\n   * @dev Finalize fee allocations with proper bounds checking\n   */\n  function _finalizeAllocations(\n    int256 jackpotAdjustment,\n    int256 lpAdjustment\n  ) private pure returns (uint256, uint256, uint256) {\n    // Apply bounds to prevent negative allocations\n    int256 adjustedJackpotBps = int256(BASE_JACKPOT_BPS) + jackpotAdjustment;\n    int256 adjustedLPBps = int256(BASE_LP_BPS) + lpAdjustment;\n\n    // Ensure minimums\n    uint256 finalJackpotBps = Math.max(adjustedJackpotBps > 0 ? uint256(adjustedJackpotBps) : 0, MIN_JACKPOT_BPS);\n\n    uint256 finalLPBps = Math.max(adjustedLPBps > 0 ? uint256(adjustedLPBps) : 0, MIN_LP_BPS);\n\n    // Calculate burn with minimum\n    uint256 remainingForBurn = BPS_MAX - finalJackpotBps - finalLPBps;\n    uint256 finalBurnBps = Math.max(remainingForBurn, MIN_BURN_BPS);\n\n    // Handle overflow case\n    uint256 total = finalJackpotBps + finalLPBps + finalBurnBps;\n    if (total > BPS_MAX) {\n      return _handleOverflow(finalJackpotBps, finalLPBps, finalBurnBps, total);\n    }\n\n    return (finalJackpotBps, finalLPBps, finalBurnBps);\n  }\n\n  /**\n   * @dev Handle allocation overflow by scaling down proportionally\n   */\n  function _handleOverflow(\n    uint256 finalJackpotBps,\n    uint256 finalLPBps,\n    uint256 finalBurnBps,\n    uint256 total\n  ) private pure returns (uint256, uint256, uint256) {\n    uint256 excess = total - BPS_MAX;\n\n    uint256 jackpotAboveMin = finalJackpotBps > MIN_JACKPOT_BPS ? finalJackpotBps - MIN_JACKPOT_BPS : 0;\n    uint256 lpAboveMin = finalLPBps > MIN_LP_BPS ? finalLPBps - MIN_LP_BPS : 0;\n    uint256 burnAboveMin = finalBurnBps > MIN_BURN_BPS ? finalBurnBps - MIN_BURN_BPS : 0;\n    uint256 totalAboveMin = jackpotAboveMin + lpAboveMin + burnAboveMin;\n\n    if (totalAboveMin >= excess) {\n      // Scale down proportionally\n      finalJackpotBps -= (jackpotAboveMin * excess) / totalAboveMin;\n      finalLPBps -= (lpAboveMin * excess) / totalAboveMin;\n      finalBurnBps = BPS_MAX - finalJackpotBps - finalLPBps;\n    } else {\n      // Fallback to minimum distribution\n      finalJackpotBps = MIN_JACKPOT_BPS;\n      finalLPBps = MIN_LP_BPS;\n      finalBurnBps = MIN_BURN_BPS;\n\n      uint256 remaining = BPS_MAX - (MIN_JACKPOT_BPS + MIN_LP_BPS + MIN_BURN_BPS);\n      uint256 totalBase = BASE_JACKPOT_BPS + BASE_LP_BPS + BASE_BURN_BPS;\n\n      finalJackpotBps += (BASE_JACKPOT_BPS * remaining) / totalBase;\n      finalLPBps += (BASE_LP_BPS * remaining) / totalBase;\n      finalBurnBps = BPS_MAX - finalJackpotBps - finalLPBps;\n    }\n\n    return (finalJackpotBps, finalLPBps, finalBurnBps);\n  }\n\n  // ========== TIME UTILITY FUNCTIONS ==========\n\n  /**\n   * @notice Calculate lock end time for a new lock\n   * @dev Aligns to weekly boundaries for consistency\n   * @param currentTime Current timestamp\n   * @param lockDuration Duration to lock for in seconds\n   * @return lockEnd Timestamp when lock will expire\n   */\n  function calculateLockEnd(uint256 currentTime, uint256 lockDuration) internal pure returns (uint256 lockEnd) {\n    // Ensure lock duration is capped at MAX_LOCK_TIME\n    lockDuration = Math.min(lockDuration, MAX_LOCK_TIME);\n\n    // Align to weekly boundaries (Curve style)\n    uint256 unlockTime = ((currentTime + lockDuration) / WEEK) * WEEK;\n\n    return unlockTime;\n  }\n\n  /**\n   * @notice Convert seconds to weeks, rounded down\n   * @param timeInSeconds Time in seconds\n   * @return weeksCount Number of weeks\n   */\n  function secondsToWeeks(uint256 timeInSeconds) internal pure returns (uint256 weeksCount) {\n    return timeInSeconds / WEEK;\n  }\n\n  /**\n   * @notice Convert weeks to seconds\n   * @param weeksCount Number of weeks\n   * @return timeInSeconds Time in seconds\n   */\n  function weeksToSeconds(uint256 weeksCount) internal pure returns (uint256 timeInSeconds) {\n    return weeksCount * WEEK;\n  }\n\n  // ========== LEGACY COMPATIBILITY FUNCTIONS ==========\n\n  /**\n   * @notice Legacy function name for calculateVotingPower\n   * @dev Maintains backward compatibility\n   */\n  function calculateLinearVotingPower(uint256 amount, uint256 lockDuration) internal pure returns (uint256) {\n    return calculateVotingPower(amount, lockDuration);\n  }\n\n  /**\n   * @notice Legacy function name for calculateDecayedVotingPower\n   * @dev Maintains backward compatibility\n   */\n  function calculateTimeWeightedVotingPower(\n    uint256 amount,\n    uint256 lockEnd,\n    uint256 currentTime\n  ) internal pure returns (uint256) {\n    return calculateDecayedVotingPower(amount, lockEnd, currentTime);\n  }\n}\n"
    },
    "contracts/libraries/OmniDragonFeeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title OmniDragonFeeLib\n * @author 0xakita.eth\n * @dev Library for fee calculation and distribution logic\n * @notice Extracted from omniDRAGON to reduce contract size and improve modularity\n *\n * This library handles:\n * - Fee calculation with different rates for buy/sell\n * - Fee distribution to jackpot, veDRAGON, and burn\n * - Native token conversion and routing\n * - Emergency recovery mechanisms\n *\n * https://x.com/sonicreddragon\n * https://t.me/sonicreddragon\n */\nlibrary OmniDragonFeeLib {\n  using SafeERC20 for IERC20;\n\n  // ========== EVENTS ==========\n  event FeesDistributed(\n    address indexed token,\n    uint256 jackpotAmount,\n    uint256 veDragonAmount,\n    uint256 burnAmount,\n    uint256 totalFees\n  );\n  \n  event NativeConversion(\n    address indexed dexPair,\n    uint256 tokenAmount,\n    uint256 nativeReceived\n  );\n\n  // ========== STRUCTS ==========\n  \n  struct Fees {\n    uint256 jackpot;\n    uint256 veDRAGON;\n    uint256 burn;\n    uint256 total;\n  }\n\n  struct FeeAmounts {\n    uint256 jackpotFee;\n    uint256 veDragonFee;\n    uint256 burnFee;\n    uint256 totalFeeAmount;\n  }\n\n  struct FeeDistributionParams {\n    address token;\n    address jackpotVault;\n    address veDragonContract;\n    address burnAddress;\n    uint256 amount;\n  }\n\n  // ========== CORE FUNCTIONS ==========\n\n  /**\n   * @dev Calculate fee breakdown from total fee amount\n   * @param amount Total amount being transferred\n   * @param feeRates Fee rates structure\n   * @return feeAmounts Calculated fee amounts\n   */\n  function calculateFeeBreakdown(\n    uint256 amount,\n    Fees memory feeRates\n  ) internal pure returns (FeeAmounts memory feeAmounts) {\n    feeAmounts.totalFeeAmount = (amount * feeRates.total) / 10000;\n    \n    if (feeAmounts.totalFeeAmount > 0) {\n      feeAmounts.jackpotFee = (feeAmounts.totalFeeAmount * feeRates.jackpot) / feeRates.total;\n      feeAmounts.veDragonFee = (feeAmounts.totalFeeAmount * feeRates.veDRAGON) / feeRates.total;\n      feeAmounts.burnFee = (feeAmounts.totalFeeAmount * feeRates.burn) / feeRates.total;\n    }\n  }\n\n  /**\n   * @dev Execute fee distribution to all destinations\n   * @param params Distribution parameters\n   */\n  function executeFeeDistribution(FeeDistributionParams memory params) internal {\n    require(params.amount > 0, \"OmniDragonFeeLib: Zero amount\");\n    require(params.token != address(0), \"OmniDragonFeeLib: Zero token address\");\n\n    // Calculate individual amounts (simple equal distribution for now)\n    uint256 thirdAmount = params.amount / 3;\n    uint256 remainder = params.amount - (thirdAmount * 3);\n\n    // Distribute to jackpot vault\n    if (params.jackpotVault != address(0) && thirdAmount > 0) {\n      IERC20(params.token).safeTransfer(params.jackpotVault, thirdAmount);\n    }\n\n    // Distribute to veDRAGON contract\n    if (params.veDragonContract != address(0) && thirdAmount > 0) {\n      IERC20(params.token).safeTransfer(params.veDragonContract, thirdAmount);\n    }\n\n    // Burn tokens (send to burn address)\n    if (params.burnAddress != address(0) && (thirdAmount + remainder) > 0) {\n      IERC20(params.token).safeTransfer(params.burnAddress, thirdAmount + remainder);\n    }\n\n    emit FeesDistributed(\n      params.token,\n      thirdAmount,\n      thirdAmount,\n      thirdAmount + remainder,\n      params.amount\n    );\n  }\n\n  /**\n   * @dev Convert tokens to native currency via DEX pair\n   * @param token Token to convert\n   * @param amount Amount to convert\n   * @param dexPair DEX pair address for conversion\n   * @param recipient Recipient of native tokens\n   * @return nativeReceived Amount of native tokens received\n   */\n  function convertToNative(\n    address token,\n    uint256 amount,\n    address dexPair,\n    address recipient\n  ) internal returns (uint256 nativeReceived) {\n    require(token != address(0), \"OmniDragonFeeLib: Zero token address\");\n    require(dexPair != address(0), \"OmniDragonFeeLib: Zero DEX pair address\");\n    require(amount > 0, \"OmniDragonFeeLib: Zero amount\");\n\n    uint256 initialBalance = recipient.balance;\n\n    // Transfer tokens to DEX pair and execute swap\n    IERC20(token).safeTransfer(dexPair, amount);\n    \n    // Simple swap logic (would need to be customized for specific DEX)\n    (bool success, ) = dexPair.call(\n      abi.encodeWithSignature(\"swap(uint256,uint256,address,bytes)\", 0, amount, recipient, \"\")\n    );\n    \n    require(success, \"OmniDragonFeeLib: Swap failed\");\n\n    nativeReceived = recipient.balance - initialBalance;\n    \n    emit NativeConversion(dexPair, amount, nativeReceived);\n  }\n\n  /**\n   * @dev Calculate optimal fee split between different mechanisms\n   * @param totalAmount Total amount to process\n   * @param isBuy Whether this is a buy transaction\n   * @return jackpotShare Share for jackpot\n   * @return veDragonShare Share for veDRAGON\n   * @return burnShare Share for burn\n   */\n  function calculateOptimalSplit(\n    uint256 totalAmount,\n    bool isBuy\n  ) internal pure returns (uint256 jackpotShare, uint256 veDragonShare, uint256 burnShare) {\n    // Different allocation strategies for buy vs sell\n    if (isBuy) {\n      // Buy: More to jackpot and veDRAGON for user incentives\n      jackpotShare = (totalAmount * 4000) / 10000; // 40%\n      veDragonShare = (totalAmount * 4000) / 10000; // 40%\n      burnShare = (totalAmount * 2000) / 10000; // 20%\n    } else {\n      // Sell: More to burn for deflationary pressure\n      jackpotShare = (totalAmount * 3000) / 10000; // 30%\n      veDragonShare = (totalAmount * 3000) / 10000; // 30%\n      burnShare = (totalAmount * 4000) / 10000; // 40%\n    }\n  }\n\n  /**\n   * @dev Emergency function to rescue tokens\n   * @param token Token to rescue\n   * @param amount Amount to rescue\n   * @param to Recipient address\n   */\n  function emergencyRescue(\n    address token,\n    uint256 amount,\n    address to\n  ) internal {\n    require(to != address(0), \"OmniDragonFeeLib: Zero recipient address\");\n    require(amount > 0, \"OmniDragonFeeLib: Zero amount\");\n\n    if (token == address(0)) {\n      // Rescue native tokens\n      (bool success, ) = payable(to).call{value: amount}(\"\");\n      require(success, \"OmniDragonFeeLib: Native transfer failed\");\n    } else {\n      // Rescue ERC20 tokens\n      IERC20(token).safeTransfer(to, amount);\n    }\n  }\n\n  /**\n   * @dev Validate fee rates don't exceed maximum limits\n   * @param feeRates Fee rates to validate\n   * @param maxTotalFee Maximum allowed total fee (in basis points)\n   */\n  function validateFeeRates(Fees memory feeRates, uint256 maxTotalFee) internal pure {\n    require(feeRates.total <= maxTotalFee, \"OmniDragonFeeLib: Total fee too high\");\n    require(\n      feeRates.jackpot + feeRates.veDRAGON + feeRates.burn == feeRates.total,\n      \"OmniDragonFeeLib: Fee breakdown mismatch\"\n    );\n  }\n} "
    },
    "contracts/libraries/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    _nonReentrantBefore();\n    _;\n    _nonReentrantAfter();\n  }\n\n  function _nonReentrantBefore() private {\n    // On the first call to nonReentrant, _status will be _NOT_ENTERED\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n  }\n\n  function _nonReentrantAfter() private {\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n}\n"
    },
    "contracts/ovault/MyAssetOFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\nimport { OFT } from \"@layerzerolabs/oft-evm/contracts/OFT.sol\";\n\n/**\n * @title MyAssetOFT\n * @notice ERC20 representation of the vault's asset token on a spoke chain for cross-chain functionality\n */\ncontract MyAssetOFT is OFT {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _lzEndpoint,\n    address _delegate\n  ) OFT(_name, _symbol, _lzEndpoint, _delegate) {}\n}\n\n\n"
    },
    "contracts/ovault/MyAssetOFTAdapter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\nimport { OFTAdapter } from \"@layerzerolabs/oft-evm/contracts/OFTAdapter.sol\";\n\n/**\n * @title MyAssetOFTAdapter\n * @notice Lockbox adapter for the ERC20 asset token (LP) on hub\n */\ncontract MyAssetOFTAdapter is OFTAdapter {\n  constructor(address _token, address _lzEndpoint, address _delegate)\n    OFTAdapter(_token, _lzEndpoint, _delegate)\n  {}\n}\n\n\n\n"
    },
    "contracts/ovault/MyERC4626.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n/**\n * @title MyERC4626\n * @notice Tokenized vault for OVault hub operations (wraps an LP token on hub)\n */\ncontract MyERC4626 is ERC4626 {\n  constructor(string memory _name, string memory _symbol, IERC20 _asset)\n    ERC20(_name, _symbol)\n    ERC4626(_asset)\n  {}\n}\n\n\n"
    },
    "contracts/ovault/MyOVaultComposer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport { VaultComposerSync } from \"@layerzerolabs/ovault-evm/contracts/VaultComposerSync.sol\";\n\n/**\n * @title MyOVaultComposer\n * @notice Cross-chain vault composer enabling omnichain vault operations via LayerZero\n */\ncontract MyOVaultComposer is VaultComposerSync {\n  constructor(address _ovault, address _assetOFT, address _shareOFT)\n    VaultComposerSync(_ovault, _assetOFT, _shareOFT)\n  {}\n}\n\n\n"
    },
    "contracts/ovault/MyShareOFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\nimport { OFT } from \"@layerzerolabs/oft-evm/contracts/OFT.sol\";\n\n/**\n * @title MyShareOFT\n * @notice ERC20 representation of the vault's share token on spoke chains\n */\ncontract MyShareOFT is OFT {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _lzEndpoint,\n    address _delegate\n  ) OFT(_name, _symbol, _lzEndpoint, _delegate) {}\n}\n\n\n\n"
    },
    "contracts/ovault/MyShareOFTAdapter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\nimport { OFTAdapter } from \"@layerzerolabs/oft-evm/contracts/OFTAdapter.sol\";\n\n/**\n * @title MyShareOFTAdapter\n * @notice Lockbox adapter for the ERC4626 share token on hub\n */\ncontract MyShareOFTAdapter is OFTAdapter {\n  constructor(address _token, address _lzEndpoint, address _delegate)\n    OFTAdapter(_token, _lzEndpoint, _delegate)\n  {}\n}\n\n\n"
    },
    "contracts/test/MockContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title MockContract\n * @dev Generic mock contract for testing DEX integrations\n */\ncontract MockContract {\n    \n    mapping(address => uint256) public tokenBalances;\n    \n    event TokenReceived(address token, uint256 amount, address from);\n    event MockFunctionCalled(address caller);\n    \n    // Basic mock function\n    function mockFunction() external pure returns (bool) {\n        return true;\n    }\n    \n    // Mock swap function (for testing purposes)\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) external returns (uint256 amountOut) {\n        // Simple mock swap - just transfer tokens\n        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        \n        // Mock 1:1 swap for testing\n        amountOut = amountIn;\n        \n        // Would normally swap, but for testing just return the input amount\n        return amountOut;\n    }\n    \n    // Mock add liquidity function\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        address to\n    ) external returns (uint256 liquidity) {\n        // Mock liquidity addition\n        IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);\n        IERC20(tokenB).transferFrom(msg.sender, address(this), amountB);\n        \n        return amountA + amountB; // Mock liquidity amount\n    }\n    \n    // Receive function for ETH\n    receive() external payable {\n        emit TokenReceived(address(0), msg.value, msg.sender);\n    }\n    \n    // Fallback for unknown calls\n    fallback() external payable {\n        emit MockFunctionCalled(msg.sender);\n    }\n    \n    // Helper to check token balances in contract\n    function getTokenBalance(address token) external view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n}"
    },
    "contracts/test/MockLotteryManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title MockLotteryManager\n * @dev Mock contract for testing lottery integration\n */\ncontract MockLotteryManager {\n    uint256 private nextEntryId = 1;\n    \n    mapping(uint256 => address) public entryTraders;\n    mapping(uint256 => uint256) public entryAmounts;\n    \n    event LotteryProcessed(\n        uint256 indexed entryId,\n        address indexed trader,\n        address tokenIn,\n        uint256 amountIn,\n        uint256 swapValueUSD\n    );\n    \n    function processSwapLottery(\n        address trader,\n        address tokenIn,\n        uint256 amountIn,\n        uint256 swapValueUSD\n    ) external returns (uint256 entryId) {\n        entryId = nextEntryId++;\n        \n        entryTraders[entryId] = trader;\n        entryAmounts[entryId] = amountIn;\n        \n        emit LotteryProcessed(entryId, trader, tokenIn, amountIn, swapValueUSD);\n        \n        return entryId;\n    }\n    \n    function getEntry(uint256 entryId) external view returns (address trader, uint256 amount) {\n        return (entryTraders[entryId], entryAmounts[entryId]);\n    }\n}"
    },
    "lib/chainlink-vrf-v2.5/IVRFCoordinatorV2Plus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title VRF V2.5 Coordinator Interface\n/// @notice This interface defines the functions for Chainlink VRF V2.5\ninterface IVRFCoordinatorV2Plus {\n    /**\n     * @notice Request randomness from the VRF V2.5 service\n     * @param req The VRF request parameters\n     * @return requestId The request ID for tracking the randomness request\n     */\n    function requestRandomWords(VRFV2PlusClient.RandomWordsRequest calldata req) external returns (uint256 requestId);\n\n    /**\n     * @notice Get subscription information\n     * @param subscriptionId The subscription ID\n     * @return balance The LINK balance of the subscription\n     * @return nativeBalance The native token balance of the subscription\n     * @return reqCount The number of requests for this subscription\n     * @return subOwner The owner of the subscription\n     * @return consumers Array of consumer addresses\n     */\n    function getSubscription(\n        uint256 subscriptionId\n    )\n        external\n        view\n        returns (\n            uint96 balance,\n            uint96 nativeBalance,\n            uint64 reqCount,\n            address subOwner,\n            address[] memory consumers\n        );\n\n    /**\n     * @notice Check if a subscription exists and is valid\n     * @param subscriptionId The subscription ID to check\n     * @return exists True if the subscription exists\n     */\n    function subscriptionExists(uint256 subscriptionId) external view returns (bool exists);\n}\n\n/// @title VRF V2.5 Client Library\nlibrary VRFV2PlusClient {\n    struct RandomWordsRequest {\n        bytes32 keyHash;\n        uint256 subId;\n        uint16 requestConfirmations;\n        uint32 callbackGasLimit;\n        uint32 numWords;\n        bytes extraArgs;\n    }\n\n    // Additional constants for VRF V2.5\n    bytes4 internal constant EXTRA_ARGS_V1_TAG = 0x181dcf10;\n\n    /**\n     * @notice Encode extra arguments for VRF V2.5 requests\n     * @param nativePayment Whether to pay in native tokens\n     * @return Encoded extra arguments\n     */\n    function _argsToBytes(bool nativePayment) internal pure returns (bytes memory) {\n        return abi.encodeWithSelector(EXTRA_ARGS_V1_TAG, nativePayment);\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // We're using the unchecked block below because otherwise execution ends \n        // with the native overflow error code.\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n        }\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "solmate/src/tokens/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {\n                success := iszero(or(iszero(extcodesize(token)), returndatasize())) \n            }\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {\n                success := iszero(or(iszero(extcodesize(token)), returndatasize())) \n            }\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.\n            if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {\n                success := iszero(or(iszero(extcodesize(token)), returndatasize())) \n            }\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}