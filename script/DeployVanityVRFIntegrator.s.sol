// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../contracts/core/vrf/ChainlinkVRFIntegratorV2_5.sol";

contract DeployVanityVRFIntegrator is Script {
    // VANITY ADDRESS CONFIGURATION
    // Generated by Rust vanity generator - 0x69...777 pattern
    bytes32 constant VRF_INTEGRATOR_VANITY_SALT = 0xb994843c4032d083151c133af52a78b382fff8039f46944d2d2c23b7dc828ae0;
    address constant EXPECTED_VRF_INTEGRATOR_ADDRESS = 0x6982FD0D587942aE937729f320D0F05ecB74D777;
    
    // CREATE2 Factory with Ownership
    address constant OMNI_CREATE2_FACTORY = 0xAA28020DDA6b954D16208eccF873D79AC6533833;
    
    // LayerZero V2 Configuration (from .env)
    address constant SONIC_LZ_ENDPOINT_V2 = 0x1a44076050125825900e736c501f859c50fE728c;
    uint32 constant ARBITRUM_EID = 30110; // Arbitrum LayerZero EID
    
    // Owner configuration
    address constant OWNER = 0xDDd0050d1E084dFc72d5d06447Cc10bcD3fEF60F; // deployer address
    
    function run() external {
        vm.startBroadcast();
        
        console.log("==============================================");
        console.log("DEPLOYING CHAINLINK VRF INTEGRATOR V2.5 WITH VANITY ADDRESS");
        console.log("==============================================");
        console.log("");
        
        console.log("Configuration:");
        console.log("  CREATE2 Factory:", OMNI_CREATE2_FACTORY);
        console.log("  LayerZero Endpoint:", SONIC_LZ_ENDPOINT_V2);
        console.log("  Arbitrum EID:", ARBITRUM_EID);
        console.log("  Owner:", OWNER);
        console.log("  Salt:", vm.toString(VRF_INTEGRATOR_VANITY_SALT));
        console.log("  Expected Address:", EXPECTED_VRF_INTEGRATOR_ADDRESS);
        console.log("");
        
        // Encode constructor parameters (just registry address)
        bytes memory constructorArgs = abi.encode(
            0xB812B719A00123310751c7A82dEba38777cf0cC8   // OmniDragonRegistry address
        );
        
        // Get the bytecode with constructor args
        bytes memory creationBytecode = abi.encodePacked(
            type(ChainlinkVRFIntegratorV2_5).creationCode,
            constructorArgs
        );
        
        // Compute expected address
        address actualAddress = vm.computeCreate2Address(
            VRF_INTEGRATOR_VANITY_SALT,
            keccak256(creationBytecode),
            OMNI_CREATE2_FACTORY
        );
        
        // Verify address matches expected
        require(
            actualAddress == EXPECTED_VRF_INTEGRATOR_ADDRESS,
            string(abi.encodePacked(
                "Address mismatch! Expected: ",
                vm.toString(EXPECTED_VRF_INTEGRATOR_ADDRESS),
                ", Got: ",
                vm.toString(actualAddress)
            ))
        );
        
        console.log("Address verification passed!");
        console.log("");
        
        // Deploy via CREATE2 factory
        console.log("Deploying ChainlinkVRFIntegratorV2_5...");
        
        (bool success, bytes memory returnData) = OMNI_CREATE2_FACTORY.call(
            abi.encodeWithSignature(
                "deploy(bytes,bytes32,string)",
                creationBytecode,
                VRF_INTEGRATOR_VANITY_SALT,
                "ChainlinkVRFIntegratorV2_5"
            )
        );
        
        if (!success) {
            if (returnData.length > 0) {
                // Decode revert reason
                assembly {
                    let returnDataSize := mload(returnData)
                    revert(add(32, returnData), returnDataSize)
                }
            } else {
                revert("Factory deployment failed with no reason");
            }
        }
        
        // Get the deployed VRF integrator instance
        ChainlinkVRFIntegratorV2_5 vrfIntegrator = ChainlinkVRFIntegratorV2_5(payable(actualAddress));
        
        vm.stopBroadcast();
        
        console.log("");
        console.log("DEPLOYMENT SUCCESSFUL!");
        console.log("======================");
        console.log("VRF Integrator Address:", address(vrfIntegrator));
        console.log("Vanity Pattern: 0x69...777");
        console.log("Salt Used:", vm.toString(VRF_INTEGRATOR_VANITY_SALT));
        console.log("Owner:", vrfIntegrator.owner());
        console.log("LayerZero Endpoint:", address(vrfIntegrator.endpoint()));
        console.log("");
        
        console.log("NEXT STEPS:");
        console.log("===========");
        console.log("1. Fund contract with ETH for LayerZero fees:");
        console.log("   cast send", address(vrfIntegrator), "--value 0.01ether");
        console.log("");
        console.log("2. Set VRF Consumer peer on Arbitrum:");
        console.log("   vrfIntegrator.setPeer(", ARBITRUM_EID, ", vrfConsumerAddress)");
        console.log("");
        console.log("3. Configure LotteryManager to use this integrator:");
        console.log("   lotteryManager.setVRFIntegrator(", address(vrfIntegrator), ")");
        console.log("");
        console.log("4. Authorize LotteryManager for VRF requests:");
        console.log("   vrfIntegrator.setAuthorizedCaller(lotteryManagerAddress, true)");
        console.log("");
        
        // Verify deployment
        console.log("VERIFICATION:");
        console.log("=============");
        console.log("Contract Code Size:", address(vrfIntegrator).code.length, "bytes");
        console.log("ChainlinkVRFIntegratorV2_5 deployed successfully!");
    }
}