// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../contracts/core/tokens/omniDRAGON.sol";

contract DeployVanityOmniDragon is Script {
    // Registry address (same across all chains)
    address constant REGISTRY_ADDRESS = 0x6949936442425f4137807Ac5d269e6Ef66d50777;
    
    // Create2Factory with Ownership
    address constant OMNI_CREATE2_FACTORY = 0xAA28020DDA6b954D16208eccF873D79AC6533833;
    
    // Vanity salt for 0x69...7777 pattern (generated by Rust generator)
    bytes32 constant VANITY_SALT = 0x00000000000000000000000000000000000000000000000000000000ba7972a6; // Generated vanity salt
    
    // Expected vanity address (0x69...7777 pattern)
    address constant EXPECTED_ADDRESS = 0x69821FFA2312253209FdabB3D84f034B697E7777; // Generated vanity address
    
    // Token configuration
    string constant TOKEN_NAME = "Dragon";
    string constant TOKEN_SYMBOL = "DRAGON";
    uint256 constant INITIAL_SUPPLY = 6942000 * 1e18; // 6,942,000 tokens
    uint256 constant SONIC_CHAIN_ID = 146;
    
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address deployer = vm.addr(deployerPrivateKey);
        uint256 chainId = block.chainid;
        string memory chainName = getChainName(chainId);
        
        console.log("=== DEPLOYING VANITY OMNIDRAGON TOKEN ===");
        console.log("Network:", chainName);
        console.log("Chain ID:", chainId);
        console.log("Deployer:", deployer);
        console.log("Registry:", REGISTRY_ADDRESS);
        console.log("Token Name:", TOKEN_NAME);
        console.log("Token Symbol:", TOKEN_SYMBOL);
        console.log("Create2Factory:", OMNI_CREATE2_FACTORY);
        console.log("");
        
        // Generate bytecode with constructor parameters
        bytes memory bytecode = abi.encodePacked(
            type(omniDRAGON).creationCode,
            abi.encode(
                TOKEN_NAME,        // "Dragon"
                TOKEN_SYMBOL,      // "DRAGON"
                deployer,          // delegate
                REGISTRY_ADDRESS,  // registry
                deployer           // owner
            )
        );
        
        // Calculate actual address using the salt
        address actualAddress = vm.computeCreate2Address(
            VANITY_SALT,
            keccak256(bytecode),
            OMNI_CREATE2_FACTORY
        );
        
        console.log("Calculated Address:", actualAddress);
        console.log("Expected Vanity Address:", EXPECTED_ADDRESS);
        
        if (EXPECTED_ADDRESS != address(0) && actualAddress != EXPECTED_ADDRESS) {
            console.log("WARNING: Calculated address differs from expected vanity address");
            console.log("Using calculated address:", actualAddress);
        }
        
        vm.startBroadcast(deployerPrivateKey);
        
        // Deploy using CREATE2FactoryWithOwnership
        console.log("Deploying omniDRAGON with vanity address...");
        (bool success, bytes memory returnData) = OMNI_CREATE2_FACTORY.call(
            abi.encodeWithSignature("deploy(bytes,bytes32,string)", bytecode, VANITY_SALT, "omniDRAGON")
        );
        
        require(success, "Deployment failed");
        
        // Get the deployed contract
        omniDRAGON dragonToken = omniDRAGON(actualAddress);
        
        console.log("SUCCESS: omniDRAGON deployed at:", address(dragonToken));
        
        // Initial supply is automatically handled by constructor
        console.log("");
        if (chainId == SONIC_CHAIN_ID) {
            console.log("INITIAL SUPPLY MINTED ON SONIC (automatic)");
            console.log("Supply:", dragonToken.totalSupply() / 1e18, "DRAGON");
            console.log("SUCCESS: Initial supply minted to owner:", deployer);
        } else {
            console.log("INFO: No initial supply on this chain - only on Sonic");
            console.log("Current supply:", dragonToken.totalSupply() / 1e18, "DRAGON");
        }
        
        vm.stopBroadcast();
        
        // Verify deployment
        console.log("");
        console.log("DEPLOYMENT VERIFICATION:");
        console.log("==============================");
        console.log("Chain:", chainName);
        console.log("Chain ID:", chainId);
        console.log("Token Address:", address(dragonToken));
        console.log("Token Name:", dragonToken.name());
        console.log("Token Symbol:", dragonToken.symbol());
        console.log("Total Supply (DRAGON):", dragonToken.totalSupply() / 1e18);
        console.log("Owner:", dragonToken.owner());
        console.log("Registry:", address(dragonToken.REGISTRY()));
        console.log("LayerZero Endpoint:", address(dragonToken.endpoint()));
        
        // Vanity address verification
        string memory addressStr = vm.toString(address(dragonToken));
        bool startsWithOx69 = 
            bytes(addressStr)[2] == '6' && bytes(addressStr)[3] == '9';
        bool endsWithOx7777 = 
            bytes(addressStr)[38] == '7' && bytes(addressStr)[39] == '7' && 
            bytes(addressStr)[40] == '7' && bytes(addressStr)[41] == '7';
            
        console.log("");
        console.log("VANITY ADDRESS CHECK:");
        console.log("Starts with 0x69:", startsWithOx69 ? "YES" : "NO");
        console.log("Ends with 7777:", endsWithOx7777 ? "YES" : "NO");
        
        console.log("");
        console.log("TOKEN FEATURES:");
        console.log("- SUCCESS: LayerZero V2 OFT (Omnichain Fungible Token)");
        console.log("- SUCCESS: Smart fee detection (10% on trades, 0% on liquidity/bridging)");
        console.log("- SUCCESS: Lottery integration ready");
        console.log("- SUCCESS: Cross-chain transfers enabled");
        console.log("- SUCCESS: Registry integration for ecosystem");
        console.log("- SUCCESS: Vanity address pattern matching");
        
        console.log("");
        console.log("DEPLOYMENT SCHEDULE:");
        console.log("1. SUCCESS: Deploy on Sonic (with 6,942,000 initial supply)");
        console.log("2. PENDING: Deploy on Arbitrum (no initial supply)");
        console.log("3. PENDING: Deploy on Ethereum (no initial supply)");
        console.log("4. PENDING: Deploy on Base (no initial supply)");
        console.log("5. PENDING: Deploy on Avalanche (no initial supply)");
        console.log("6. PENDING: Configure LayerZero peers");
        console.log("7. PENDING: Test cross-chain transfers");
        
        console.log("");
        console.log("NEXT STEPS:");
        if (chainId == SONIC_CHAIN_ID) {
            console.log("SUCCESS: Sonic deployment complete with initial supply");
            console.log("NEXT: Now deploy on other chains using same script");
        } else {
            console.log("SUCCESS: Deployment complete on this chain");
            console.log("INFO: Token supply will come from Sonic via LayerZero");
        }
        
        console.log("");
        console.log("SAME ADDRESS ON ALL CHAINS:");
        console.log(address(dragonToken));
    }
    
    function getChainName(uint256 chainId) internal pure returns (string memory) {
        if (chainId == 146) return "Sonic";
        if (chainId == 42161) return "Arbitrum"; 
        if (chainId == 1) return "Ethereum";
        if (chainId == 8453) return "Base";
        if (chainId == 43114) return "Avalanche";
        if (chainId == 56) return "BSC";
        return "Unknown";
    }
}

// Helper script to calculate vanity salt
contract CalculateOmniDragonVanitySalt is Script {
    address constant REGISTRY_ADDRESS = 0x6949936442425f4137807Ac5d269e6Ef66d50777;
    address constant OMNI_CREATE2_FACTORY = 0xAA28020DDA6b954D16208eccF873D79AC6533833;
    string constant TOKEN_NAME = "Dragon";
    string constant TOKEN_SYMBOL = "DRAGON";
    
    function run() external view {
        address deployer = 0xDDd0050d1E084dFc72d5d06447Cc10bcD3fEF60F; // Your deployer
        
        console.log("=== CALCULATING VANITY SALT FOR OMNIDRAGON ===");
        console.log("Target pattern: 0x69...7777");
        console.log("Factory:", OMNI_CREATE2_FACTORY);
        console.log("");
        
        // Generate bytecode
        bytes memory bytecode = abi.encodePacked(
            type(omniDRAGON).creationCode,
            abi.encode(TOKEN_NAME, TOKEN_SYMBOL, deployer, REGISTRY_ADDRESS, deployer)
        );
        
        bytes32 bytecodeHash = keccak256(bytecode);
        console.log("Bytecode hash:", vm.toString(bytecodeHash));
        
        console.log("");
        console.log("Use a vanity address generator to find salt for pattern 0x69...7777");
        console.log("Factory:", OMNI_CREATE2_FACTORY);
        console.log("Bytecode hash:", vm.toString(bytecodeHash));
        console.log("Target: 0x69...7777");
    }
}
